
m2s010_som_sb_MSS_CM3_app:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  20000000  20000000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000330  20000190  20000190  00008190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00003d70  200004c0  200004c0  000084c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000020  20004230  20004230  0000c230  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000090  20004250  20004250  0000c250  2**4
                  ALLOC
  5 .heap         0000ad20  200042e0  200042e0  0000c250  2**4
                  ALLOC
  6 .stack        00001000  2000f000  2000f000  0000c250  2**4
                  ALLOC
  7 .comment      000000d7  00000000  00000000  0000c250  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000003e8  00000000  00000000  0000c327  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000935  00000000  00000000  0000c70f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000065df  00000000  00000000  0000d044  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000008f8  00000000  00000000  00013623  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00001eac  00000000  00000000  00013f1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000d90  00000000  00000000  00015dc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000300e  00000000  00000000  00016b58  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001752  00000000  00000000  00019b66  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 00025a23  00000000  00000000  0001b2b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .ARM.attributes 00000025  00000000  00000000  00040cdb  2**0
                  CONTENTS, READONLY
 18 .debug_ranges 000003c0  00000000  00000000  00040d00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .vector_table:

20000000 <__vector_table_start>:
20000000:	20010000 	.word	0x20010000
20000004:	20000191 	.word	0x20000191
20000008:	2000037f 	.word	0x2000037f
2000000c:	20000381 	.word	0x20000381
20000010:	20000383 	.word	0x20000383
20000014:	20000385 	.word	0x20000385
20000018:	20000387 	.word	0x20000387
	...
2000002c:	20000389 	.word	0x20000389
20000030:	2000038b 	.word	0x2000038b
20000034:	00000000 	.word	0x00000000
20000038:	2000038d 	.word	0x2000038d
2000003c:	2000038f 	.word	0x2000038f
20000040:	20000391 	.word	0x20000391
20000044:	20000393 	.word	0x20000393
20000048:	20000395 	.word	0x20000395
2000004c:	20000397 	.word	0x20000397
20000050:	20000399 	.word	0x20000399
20000054:	2000039b 	.word	0x2000039b
20000058:	2000039d 	.word	0x2000039d
2000005c:	2000039f 	.word	0x2000039f
20000060:	200003a1 	.word	0x200003a1
20000064:	200003a3 	.word	0x200003a3
20000068:	20002b91 	.word	0x20002b91
2000006c:	20002bb5 	.word	0x20002bb5
20000070:	200003a9 	.word	0x200003a9
20000074:	200003ab 	.word	0x200003ab
20000078:	200003ad 	.word	0x200003ad
2000007c:	200003af 	.word	0x200003af
20000080:	200003b1 	.word	0x200003b1
20000084:	200003b3 	.word	0x200003b3
20000088:	200003b5 	.word	0x200003b5
2000008c:	200003b7 	.word	0x200003b7
20000090:	200003b9 	.word	0x200003b9
20000094:	200003bb 	.word	0x200003bb
20000098:	200003bd 	.word	0x200003bd
2000009c:	200003bf 	.word	0x200003bf
200000a0:	200003c1 	.word	0x200003c1
200000a4:	200003c3 	.word	0x200003c3
200000a8:	200003c5 	.word	0x200003c5
200000ac:	200003c7 	.word	0x200003c7
200000b0:	200003c9 	.word	0x200003c9
200000b4:	200003cb 	.word	0x200003cb
200000b8:	200003cd 	.word	0x200003cd
200000bc:	200003cf 	.word	0x200003cf
200000c0:	200003d1 	.word	0x200003d1
200000c4:	200003d3 	.word	0x200003d3
200000c8:	200003d5 	.word	0x200003d5
200000cc:	200003d7 	.word	0x200003d7
200000d0:	200003d9 	.word	0x200003d9
200000d4:	200003db 	.word	0x200003db
200000d8:	200003dd 	.word	0x200003dd
200000dc:	200003df 	.word	0x200003df
200000e0:	200003e1 	.word	0x200003e1
200000e4:	200003e3 	.word	0x200003e3
200000e8:	200003e5 	.word	0x200003e5
200000ec:	200003e7 	.word	0x200003e7
200000f0:	200003e9 	.word	0x200003e9
200000f4:	200003eb 	.word	0x200003eb
200000f8:	200003ed 	.word	0x200003ed
200000fc:	200003ef 	.word	0x200003ef
20000100:	200003f1 	.word	0x200003f1
20000104:	200003f3 	.word	0x200003f3
20000108:	200003f5 	.word	0x200003f5
2000010c:	200003f7 	.word	0x200003f7
20000110:	200003f9 	.word	0x200003f9
20000114:	200003fb 	.word	0x200003fb
20000118:	200003fd 	.word	0x200003fd
2000011c:	200003ff 	.word	0x200003ff
20000120:	20000401 	.word	0x20000401
20000124:	20000403 	.word	0x20000403
20000128:	20000405 	.word	0x20000405
2000012c:	20000407 	.word	0x20000407
20000130:	20000409 	.word	0x20000409
20000134:	2000040b 	.word	0x2000040b
20000138:	2000040d 	.word	0x2000040d
2000013c:	2000040f 	.word	0x2000040f
20000140:	20000411 	.word	0x20000411
20000144:	20000413 	.word	0x20000413
20000148:	20000415 	.word	0x20000415
2000014c:	20000417 	.word	0x20000417
20000150:	20000419 	.word	0x20000419
20000154:	2000041b 	.word	0x2000041b
20000158:	2000041d 	.word	0x2000041d
2000015c:	2000041f 	.word	0x2000041f
20000160:	20000421 	.word	0x20000421
20000164:	20000423 	.word	0x20000423
20000168:	20000425 	.word	0x20000425
2000016c:	20000427 	.word	0x20000427
20000170:	20000429 	.word	0x20000429
20000174:	2000042b 	.word	0x2000042b
20000178:	2000042d 	.word	0x2000042d
2000017c:	2000042f 	.word	0x2000042f
20000180:	20000431 	.word	0x20000431
20000184:	20000433 	.word	0x20000433
	...

Disassembly of section .boot_code:

20000190 <Reset_Handler>:
20000190:	f04f 0b00 	mov.w	fp, #0
20000194:	f8df 02be 	ldr.w	r0, [pc, #702]	; 20000456 <SF2_MDDR_MODE_CR>
20000198:	6800      	ldr	r0, [r0, #0]
2000019a:	f8df 12b6 	ldr.w	r1, [pc, #694]	; 20000452 <SF2_EDAC_CR>
2000019e:	6809      	ldr	r1, [r1, #0]
200001a0:	f001 0103 	and.w	r1, r1, #3
200001a4:	f000 001c 	and.w	r0, r0, #28
200001a8:	2814      	cmp	r0, #20
200001aa:	d101      	bne.n	200001b0 <check_esram_edac>
200001ac:	f04b 0b02 	orr.w	fp, fp, #2

200001b0 <check_esram_edac>:
200001b0:	2900      	cmp	r1, #0
200001b2:	d001      	beq.n	200001b8 <check_stack_init>
200001b4:	f04b 0b01 	orr.w	fp, fp, #1

200001b8 <check_stack_init>:
200001b8:	f1bb 0f00 	cmp.w	fp, #0
200001bc:	d005      	beq.n	200001ca <system_init>

200001be <clear_stack>:
200001be:	48a7      	ldr	r0, [pc, #668]	; (2000045c <SF2_MDDR_MODE_CR+0x6>)
200001c0:	49a7      	ldr	r1, [pc, #668]	; (20000460 <SF2_MDDR_MODE_CR+0xa>)
200001c2:	f8df 2272 	ldr.w	r2, [pc, #626]	; 20000436 <RAM_INIT_PATTERN>
200001c6:	f000 f89f 	bl	20000308 <fill_memory>

200001ca <system_init>:
200001ca:	48a6      	ldr	r0, [pc, #664]	; (20000464 <SF2_MDDR_MODE_CR+0xe>)
200001cc:	4780      	blx	r0
200001ce:	f00b 0a02 	and.w	sl, fp, #2
200001d2:	f1ba 0f00 	cmp.w	sl, #0
200001d6:	d00c      	beq.n	200001f2 <remap_memory>
200001d8:	f8df 026e 	ldr.w	r0, [pc, #622]	; 2000044a <SF2_DDRB_NB_SIZE>
200001dc:	f8df 126e 	ldr.w	r1, [pc, #622]	; 2000044e <SF2_DDRB_CR>
200001e0:	6802      	ldr	r2, [r0, #0]
200001e2:	680b      	ldr	r3, [r1, #0]
200001e4:	b40f      	push	{r0, r1, r2, r3}
200001e6:	f04f 0200 	mov.w	r2, #0
200001ea:	f04f 03ff 	mov.w	r3, #255	; 0xff
200001ee:	6002      	str	r2, [r0, #0]
200001f0:	600b      	str	r3, [r1, #0]

200001f2 <remap_memory>:
200001f2:	489d      	ldr	r0, [pc, #628]	; (20000468 <SF2_MDDR_MODE_CR+0x12>)
200001f4:	4a9d      	ldr	r2, [pc, #628]	; (2000046c <SF2_MDDR_MODE_CR+0x16>)
200001f6:	4b9e      	ldr	r3, [pc, #632]	; (20000470 <SF2_MDDR_MODE_CR+0x1a>)
200001f8:	2802      	cmp	r0, #2
200001fa:	d108      	bne.n	2000020e <check_esram_remap>
200001fc:	f8df 123e 	ldr.w	r1, [pc, #574]	; 2000043e <SF2_ESRAM_CR>
20000200:	600a      	str	r2, [r1, #0]
20000202:	f8df 1242 	ldr.w	r1, [pc, #578]	; 20000446 <SF2_ENVM_REMAP_CR>
20000206:	600a      	str	r2, [r1, #0]
20000208:	f8df 1236 	ldr.w	r1, [pc, #566]	; 20000442 <SF2_DDR_CR>
2000020c:	600b      	str	r3, [r1, #0]

2000020e <check_esram_remap>:
2000020e:	2801      	cmp	r0, #1
20000210:	d108      	bne.n	20000224 <check_mirrored_nvm>
20000212:	f8df 122e 	ldr.w	r1, [pc, #558]	; 20000442 <SF2_DDR_CR>
20000216:	600a      	str	r2, [r1, #0]
20000218:	f8df 122a 	ldr.w	r1, [pc, #554]	; 20000446 <SF2_ENVM_REMAP_CR>
2000021c:	600a      	str	r2, [r1, #0]
2000021e:	f8df 121e 	ldr.w	r1, [pc, #542]	; 2000043e <SF2_ESRAM_CR>
20000222:	600b      	str	r3, [r1, #0]

20000224 <check_mirrored_nvm>:
20000224:	4893      	ldr	r0, [pc, #588]	; (20000474 <SF2_MDDR_MODE_CR+0x1e>)
20000226:	2800      	cmp	r0, #0
20000228:	d109      	bne.n	2000023e <copy_data>
2000022a:	4893      	ldr	r0, [pc, #588]	; (20000478 <SF2_MDDR_MODE_CR+0x22>)
2000022c:	4993      	ldr	r1, [pc, #588]	; (2000047c <SF2_MDDR_MODE_CR+0x26>)
2000022e:	4a94      	ldr	r2, [pc, #592]	; (20000480 <SF2_MDDR_MODE_CR+0x2a>)
20000230:	f000 f832 	bl	20000298 <block_copy>

20000234 <copy_text>:
20000234:	4893      	ldr	r0, [pc, #588]	; (20000484 <SF2_MDDR_MODE_CR+0x2e>)
20000236:	4994      	ldr	r1, [pc, #592]	; (20000488 <SF2_MDDR_MODE_CR+0x32>)
20000238:	4a94      	ldr	r2, [pc, #592]	; (2000048c <SF2_MDDR_MODE_CR+0x36>)
2000023a:	f000 f82d 	bl	20000298 <block_copy>

2000023e <copy_data>:
2000023e:	4894      	ldr	r0, [pc, #592]	; (20000490 <SF2_MDDR_MODE_CR+0x3a>)
20000240:	4994      	ldr	r1, [pc, #592]	; (20000494 <SF2_MDDR_MODE_CR+0x3e>)
20000242:	4a95      	ldr	r2, [pc, #596]	; (20000498 <SF2_MDDR_MODE_CR+0x42>)
20000244:	f000 f828 	bl	20000298 <block_copy>

20000248 <clear_bss>:
20000248:	4894      	ldr	r0, [pc, #592]	; (2000049c <SF2_MDDR_MODE_CR+0x46>)
2000024a:	4995      	ldr	r1, [pc, #596]	; (200004a0 <SF2_MDDR_MODE_CR+0x4a>)
2000024c:	f8df 21e6 	ldr.w	r2, [pc, #486]	; 20000436 <RAM_INIT_PATTERN>
20000250:	f000 f85a 	bl	20000308 <fill_memory>

20000254 <clear_heap>:
20000254:	f1bb 0f00 	cmp.w	fp, #0
20000258:	d012      	beq.n	20000280 <call_glob_ctor>
2000025a:	4892      	ldr	r0, [pc, #584]	; (200004a4 <SF2_MDDR_MODE_CR+0x4e>)
2000025c:	4992      	ldr	r1, [pc, #584]	; (200004a8 <SF2_MDDR_MODE_CR+0x52>)
2000025e:	f8df 21da 	ldr.w	r2, [pc, #474]	; 2000043a <HEAP_INIT_PATTERN>
20000262:	f000 f851 	bl	20000308 <fill_memory>
20000266:	f00b 0a02 	and.w	sl, fp, #2
2000026a:	f1ba 0f00 	cmp.w	sl, #0
2000026e:	d007      	beq.n	20000280 <call_glob_ctor>
20000270:	bc0f      	pop	{r0, r1, r2, r3}
20000272:	6002      	str	r2, [r0, #0]
20000274:	600b      	str	r3, [r1, #0]
20000276:	bf00      	nop
20000278:	f3af 8000 	nop.w
2000027c:	f3af 8000 	nop.w

20000280 <call_glob_ctor>:
20000280:	f8df 0228 	ldr.w	r0, [pc, #552]	; 200004ac <SF2_MDDR_MODE_CR+0x56>
20000284:	f20f 0e03 	addw	lr, pc, #3
20000288:	4700      	bx	r0

2000028a <branch_to_main>:
2000028a:	f04f 0000 	mov.w	r0, #0
2000028e:	f04f 0100 	mov.w	r1, #0
20000292:	f8df f21c 	ldr.w	pc, [pc, #540]	; 200004b0 <SF2_MDDR_MODE_CR+0x5a>

20000296 <ExitLoop>:
20000296:	e7fe      	b.n	20000296 <ExitLoop>

20000298 <block_copy>:
20000298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
2000029c:	4288      	cmp	r0, r1
2000029e:	d025      	beq.n	200002ec <block_copy_exit>
200002a0:	ebb2 0201 	subs.w	r2, r2, r1
200002a4:	d500      	bpl.n	200002a8 <block_copy_address_ok>
200002a6:	e7fe      	b.n	200002a6 <block_copy+0xe>

200002a8 <block_copy_address_ok>:
200002a8:	ea40 0301 	orr.w	r3, r0, r1
200002ac:	f013 0303 	ands.w	r3, r3, #3
200002b0:	d002      	beq.n	200002b8 <block_copy_continue>

200002b2 <block_copy_byte_copy>:
200002b2:	f000 f81d 	bl	200002f0 <block_copy_byte>
200002b6:	e019      	b.n	200002ec <block_copy_exit>

200002b8 <block_copy_continue>:
200002b8:	f04f 0300 	mov.w	r3, #0
200002bc:	4690      	mov	r8, r2
200002be:	1112      	asrs	r2, r2, #4
200002c0:	d0f7      	beq.n	200002b2 <block_copy_byte_copy>

200002c2 <block_copy_loop>:
200002c2:	429a      	cmp	r2, r3
200002c4:	bf1c      	itt	ne
200002c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
200002c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
200002ca:	f103 0301 	add.w	r3, r3, #1
200002ce:	d1f8      	bne.n	200002c2 <block_copy_loop>
200002d0:	f008 080f 	and.w	r8, r8, #15
200002d4:	f1b8 0f00 	cmp.w	r8, #0
200002d8:	d008      	beq.n	200002ec <block_copy_exit>

200002da <copy_spare_bytes>:
200002da:	7804      	ldrb	r4, [r0, #0]
200002dc:	700c      	strb	r4, [r1, #0]
200002de:	f100 0001 	add.w	r0, r0, #1
200002e2:	f101 0101 	add.w	r1, r1, #1
200002e6:	f1b8 0801 	subs.w	r8, r8, #1
200002ea:	d1f6      	bne.n	200002da <copy_spare_bytes>

200002ec <block_copy_exit>:
200002ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

200002f0 <block_copy_byte>:
200002f0:	b508      	push	{r3, lr}
200002f2:	f04f 0300 	mov.w	r3, #0

200002f6 <block_copy_byte_loop>:
200002f6:	7803      	ldrb	r3, [r0, #0]
200002f8:	700b      	strb	r3, [r1, #0]
200002fa:	f100 0001 	add.w	r0, r0, #1
200002fe:	f101 0101 	add.w	r1, r1, #1
20000302:	3a01      	subs	r2, #1
20000304:	d1f7      	bne.n	200002f6 <block_copy_byte_loop>
20000306:	bd08      	pop	{r3, pc}

20000308 <fill_memory>:
20000308:	4288      	cmp	r0, r1
2000030a:	d037      	beq.n	2000037c <fill_memory_exit>
2000030c:	f000 0603 	and.w	r6, r0, #3
20000310:	2e00      	cmp	r6, #0
20000312:	d014      	beq.n	2000033e <fill_memory_end_start>
20000314:	f04f 0504 	mov.w	r5, #4
20000318:	eba5 0406 	sub.w	r4, r5, r6
2000031c:	f04f 0708 	mov.w	r7, #8
20000320:	fb07 f806 	mul.w	r8, r7, r6
20000324:	4691      	mov	r9, r2
20000326:	fa69 f908 	ror.w	r9, r9, r8

2000032a <fill_memory_spare_bytes_start>:
2000032a:	2c00      	cmp	r4, #0
2000032c:	d007      	beq.n	2000033e <fill_memory_end_start>
2000032e:	f880 9000 	strb.w	r9, [r0]
20000332:	fa69 f907 	ror.w	r9, r9, r7
20000336:	f100 0001 	add.w	r0, r0, #1
2000033a:	3c01      	subs	r4, #1
2000033c:	e7f5      	b.n	2000032a <fill_memory_spare_bytes_start>

2000033e <fill_memory_end_start>:
2000033e:	f04f 0600 	mov.w	r6, #0
20000342:	460f      	mov	r7, r1
20000344:	1a09      	subs	r1, r1, r0
20000346:	4688      	mov	r8, r1
20000348:	1109      	asrs	r1, r1, #4
2000034a:	4691      	mov	r9, r2
2000034c:	4614      	mov	r4, r2
2000034e:	4615      	mov	r5, r2
20000350:	42b1      	cmp	r1, r6
20000352:	d006      	beq.n	20000362 <fill_memory_spare_bytes_end>

20000354 <fill_memory_loop>:
20000354:	bf18      	it	ne
20000356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
2000035a:	f106 0601 	add.w	r6, r6, #1
2000035e:	42b1      	cmp	r1, r6
20000360:	d1f8      	bne.n	20000354 <fill_memory_loop>

20000362 <fill_memory_spare_bytes_end>:
20000362:	f008 080f 	and.w	r8, r8, #15

20000366 <fill_memory_spare_end_loop>:
20000366:	f1b8 0f00 	cmp.w	r8, #0
2000036a:	d007      	beq.n	2000037c <fill_memory_exit>
2000036c:	7002      	strb	r2, [r0, #0]
2000036e:	ea4f 2232 	mov.w	r2, r2, ror #8
20000372:	f100 0001 	add.w	r0, r0, #1
20000376:	f1b8 0801 	subs.w	r8, r8, #1
2000037a:	e7f4      	b.n	20000366 <fill_memory_spare_end_loop>

2000037c <fill_memory_exit>:
2000037c:	4770      	bx	lr

2000037e <NMI_Handler>:
2000037e:	e7fe      	b.n	2000037e <NMI_Handler>

20000380 <HardFault_Handler>:
20000380:	e7fe      	b.n	20000380 <HardFault_Handler>

20000382 <MemManage_Handler>:
20000382:	e7fe      	b.n	20000382 <MemManage_Handler>

20000384 <BusFault_Handler>:
20000384:	e7fe      	b.n	20000384 <BusFault_Handler>

20000386 <UsageFault_Handler>:
20000386:	e7fe      	b.n	20000386 <UsageFault_Handler>

20000388 <SVC_Handler>:
20000388:	e7fe      	b.n	20000388 <SVC_Handler>

2000038a <DebugMon_Handler>:
2000038a:	e7fe      	b.n	2000038a <DebugMon_Handler>

2000038c <PendSV_Handler>:
2000038c:	e7fe      	b.n	2000038c <PendSV_Handler>

2000038e <SysTick_Handler>:
2000038e:	e7fe      	b.n	2000038e <SysTick_Handler>

20000390 <WdogWakeup_IRQHandler>:
20000390:	e7fe      	b.n	20000390 <WdogWakeup_IRQHandler>

20000392 <RTC_Wakeup_IRQHandler>:
20000392:	e7fe      	b.n	20000392 <RTC_Wakeup_IRQHandler>

20000394 <SPI0_IRQHandler>:
20000394:	e7fe      	b.n	20000394 <SPI0_IRQHandler>

20000396 <SPI1_IRQHandler>:
20000396:	e7fe      	b.n	20000396 <SPI1_IRQHandler>

20000398 <I2C0_IRQHandler>:
20000398:	e7fe      	b.n	20000398 <I2C0_IRQHandler>

2000039a <I2C0_SMBAlert_IRQHandler>:
2000039a:	e7fe      	b.n	2000039a <I2C0_SMBAlert_IRQHandler>

2000039c <I2C0_SMBus_IRQHandler>:
2000039c:	e7fe      	b.n	2000039c <I2C0_SMBus_IRQHandler>

2000039e <I2C1_IRQHandler>:
2000039e:	e7fe      	b.n	2000039e <I2C1_IRQHandler>

200003a0 <I2C1_SMBAlert_IRQHandler>:
200003a0:	e7fe      	b.n	200003a0 <I2C1_SMBAlert_IRQHandler>

200003a2 <I2C1_SMBus_IRQHandler>:
200003a2:	e7fe      	b.n	200003a2 <I2C1_SMBus_IRQHandler>
200003a4:	e7fe      	b.n	200003a4 <I2C1_SMBus_IRQHandler+0x2>
200003a6:	e7fe      	b.n	200003a6 <I2C1_SMBus_IRQHandler+0x4>

200003a8 <EthernetMAC_IRQHandler>:
200003a8:	e7fe      	b.n	200003a8 <EthernetMAC_IRQHandler>

200003aa <DMA_IRQHandler>:
200003aa:	e7fe      	b.n	200003aa <DMA_IRQHandler>

200003ac <Timer1_IRQHandler>:
200003ac:	e7fe      	b.n	200003ac <Timer1_IRQHandler>

200003ae <Timer2_IRQHandler>:
200003ae:	e7fe      	b.n	200003ae <Timer2_IRQHandler>

200003b0 <CAN_IRQHandler>:
200003b0:	e7fe      	b.n	200003b0 <CAN_IRQHandler>

200003b2 <ENVM0_IRQHandler>:
200003b2:	e7fe      	b.n	200003b2 <ENVM0_IRQHandler>

200003b4 <ENVM1_IRQHandler>:
200003b4:	e7fe      	b.n	200003b4 <ENVM1_IRQHandler>

200003b6 <ComBlk_IRQHandler>:
200003b6:	e7fe      	b.n	200003b6 <ComBlk_IRQHandler>

200003b8 <USB_IRQHandler>:
200003b8:	e7fe      	b.n	200003b8 <USB_IRQHandler>

200003ba <USB_DMA_IRQHandler>:
200003ba:	e7fe      	b.n	200003ba <USB_DMA_IRQHandler>

200003bc <PLL_Lock_IRQHandler>:
200003bc:	e7fe      	b.n	200003bc <PLL_Lock_IRQHandler>

200003be <PLL_LockLost_IRQHandler>:
200003be:	e7fe      	b.n	200003be <PLL_LockLost_IRQHandler>

200003c0 <CommSwitchError_IRQHandler>:
200003c0:	e7fe      	b.n	200003c0 <CommSwitchError_IRQHandler>

200003c2 <CacheError_IRQHandler>:
200003c2:	e7fe      	b.n	200003c2 <CacheError_IRQHandler>

200003c4 <DDR_IRQHandler>:
200003c4:	e7fe      	b.n	200003c4 <DDR_IRQHandler>

200003c6 <HPDMA_Complete_IRQHandler>:
200003c6:	e7fe      	b.n	200003c6 <HPDMA_Complete_IRQHandler>

200003c8 <HPDMA_Error_IRQHandler>:
200003c8:	e7fe      	b.n	200003c8 <HPDMA_Error_IRQHandler>

200003ca <ECC_Error_IRQHandler>:
200003ca:	e7fe      	b.n	200003ca <ECC_Error_IRQHandler>

200003cc <MDDR_IOCalib_IRQHandler>:
200003cc:	e7fe      	b.n	200003cc <MDDR_IOCalib_IRQHandler>

200003ce <FAB_PLL_Lock_IRQHandler>:
200003ce:	e7fe      	b.n	200003ce <FAB_PLL_Lock_IRQHandler>

200003d0 <FAB_PLL_LockLost_IRQHandler>:
200003d0:	e7fe      	b.n	200003d0 <FAB_PLL_LockLost_IRQHandler>

200003d2 <FIC64_IRQHandler>:
200003d2:	e7fe      	b.n	200003d2 <FIC64_IRQHandler>

200003d4 <FabricIrq0_IRQHandler>:
200003d4:	e7fe      	b.n	200003d4 <FabricIrq0_IRQHandler>

200003d6 <FabricIrq1_IRQHandler>:
200003d6:	e7fe      	b.n	200003d6 <FabricIrq1_IRQHandler>

200003d8 <FabricIrq2_IRQHandler>:
200003d8:	e7fe      	b.n	200003d8 <FabricIrq2_IRQHandler>

200003da <FabricIrq3_IRQHandler>:
200003da:	e7fe      	b.n	200003da <FabricIrq3_IRQHandler>

200003dc <FabricIrq4_IRQHandler>:
200003dc:	e7fe      	b.n	200003dc <FabricIrq4_IRQHandler>

200003de <FabricIrq5_IRQHandler>:
200003de:	e7fe      	b.n	200003de <FabricIrq5_IRQHandler>

200003e0 <FabricIrq6_IRQHandler>:
200003e0:	e7fe      	b.n	200003e0 <FabricIrq6_IRQHandler>

200003e2 <FabricIrq7_IRQHandler>:
200003e2:	e7fe      	b.n	200003e2 <FabricIrq7_IRQHandler>

200003e4 <FabricIrq8_IRQHandler>:
200003e4:	e7fe      	b.n	200003e4 <FabricIrq8_IRQHandler>

200003e6 <FabricIrq9_IRQHandler>:
200003e6:	e7fe      	b.n	200003e6 <FabricIrq9_IRQHandler>

200003e8 <FabricIrq10_IRQHandler>:
200003e8:	e7fe      	b.n	200003e8 <FabricIrq10_IRQHandler>

200003ea <FabricIrq11_IRQHandler>:
200003ea:	e7fe      	b.n	200003ea <FabricIrq11_IRQHandler>

200003ec <FabricIrq12_IRQHandler>:
200003ec:	e7fe      	b.n	200003ec <FabricIrq12_IRQHandler>

200003ee <FabricIrq13_IRQHandler>:
200003ee:	e7fe      	b.n	200003ee <FabricIrq13_IRQHandler>

200003f0 <FabricIrq14_IRQHandler>:
200003f0:	e7fe      	b.n	200003f0 <FabricIrq14_IRQHandler>

200003f2 <FabricIrq15_IRQHandler>:
200003f2:	e7fe      	b.n	200003f2 <FabricIrq15_IRQHandler>

200003f4 <GPIO0_IRQHandler>:
200003f4:	e7fe      	b.n	200003f4 <GPIO0_IRQHandler>

200003f6 <GPIO1_IRQHandler>:
200003f6:	e7fe      	b.n	200003f6 <GPIO1_IRQHandler>

200003f8 <GPIO2_IRQHandler>:
200003f8:	e7fe      	b.n	200003f8 <GPIO2_IRQHandler>

200003fa <GPIO3_IRQHandler>:
200003fa:	e7fe      	b.n	200003fa <GPIO3_IRQHandler>

200003fc <GPIO4_IRQHandler>:
200003fc:	e7fe      	b.n	200003fc <GPIO4_IRQHandler>

200003fe <GPIO5_IRQHandler>:
200003fe:	e7fe      	b.n	200003fe <GPIO5_IRQHandler>

20000400 <GPIO6_IRQHandler>:
20000400:	e7fe      	b.n	20000400 <GPIO6_IRQHandler>

20000402 <GPIO7_IRQHandler>:
20000402:	e7fe      	b.n	20000402 <GPIO7_IRQHandler>

20000404 <GPIO8_IRQHandler>:
20000404:	e7fe      	b.n	20000404 <GPIO8_IRQHandler>

20000406 <GPIO9_IRQHandler>:
20000406:	e7fe      	b.n	20000406 <GPIO9_IRQHandler>

20000408 <GPIO10_IRQHandler>:
20000408:	e7fe      	b.n	20000408 <GPIO10_IRQHandler>

2000040a <GPIO11_IRQHandler>:
2000040a:	e7fe      	b.n	2000040a <GPIO11_IRQHandler>

2000040c <GPIO12_IRQHandler>:
2000040c:	e7fe      	b.n	2000040c <GPIO12_IRQHandler>

2000040e <GPIO13_IRQHandler>:
2000040e:	e7fe      	b.n	2000040e <GPIO13_IRQHandler>

20000410 <GPIO14_IRQHandler>:
20000410:	e7fe      	b.n	20000410 <GPIO14_IRQHandler>

20000412 <GPIO15_IRQHandler>:
20000412:	e7fe      	b.n	20000412 <GPIO15_IRQHandler>

20000414 <GPIO16_IRQHandler>:
20000414:	e7fe      	b.n	20000414 <GPIO16_IRQHandler>

20000416 <GPIO17_IRQHandler>:
20000416:	e7fe      	b.n	20000416 <GPIO17_IRQHandler>

20000418 <GPIO18_IRQHandler>:
20000418:	e7fe      	b.n	20000418 <GPIO18_IRQHandler>

2000041a <GPIO19_IRQHandler>:
2000041a:	e7fe      	b.n	2000041a <GPIO19_IRQHandler>

2000041c <GPIO20_IRQHandler>:
2000041c:	e7fe      	b.n	2000041c <GPIO20_IRQHandler>

2000041e <GPIO21_IRQHandler>:
2000041e:	e7fe      	b.n	2000041e <GPIO21_IRQHandler>

20000420 <GPIO22_IRQHandler>:
20000420:	e7fe      	b.n	20000420 <GPIO22_IRQHandler>

20000422 <GPIO23_IRQHandler>:
20000422:	e7fe      	b.n	20000422 <GPIO23_IRQHandler>

20000424 <GPIO24_IRQHandler>:
20000424:	e7fe      	b.n	20000424 <GPIO24_IRQHandler>

20000426 <GPIO25_IRQHandler>:
20000426:	e7fe      	b.n	20000426 <GPIO25_IRQHandler>

20000428 <GPIO26_IRQHandler>:
20000428:	e7fe      	b.n	20000428 <GPIO26_IRQHandler>

2000042a <GPIO27_IRQHandler>:
2000042a:	e7fe      	b.n	2000042a <GPIO27_IRQHandler>

2000042c <GPIO28_IRQHandler>:
2000042c:	e7fe      	b.n	2000042c <GPIO28_IRQHandler>

2000042e <GPIO29_IRQHandler>:
2000042e:	e7fe      	b.n	2000042e <GPIO29_IRQHandler>

20000430 <GPIO30_IRQHandler>:
20000430:	e7fe      	b.n	20000430 <GPIO30_IRQHandler>

20000432 <GPIO31_IRQHandler>:
20000432:	e7fe      	b.n	20000432 <GPIO31_IRQHandler>

20000434 <mscc_post_hw_cfg_init>:
20000434:	4770      	bx	lr

20000436 <RAM_INIT_PATTERN>:
20000436:	0000      	.short	0x0000
	...

2000043a <HEAP_INIT_PATTERN>:
2000043a:	a2a2      	.short	0xa2a2
2000043c:	a2a2      	.short	0xa2a2

2000043e <SF2_ESRAM_CR>:
2000043e:	8000      	.short	0x8000
20000440:	4003      	.short	0x4003

20000442 <SF2_DDR_CR>:
20000442:	8008      	.short	0x8008
20000444:	4003      	.short	0x4003

20000446 <SF2_ENVM_REMAP_CR>:
20000446:	8010      	.short	0x8010
20000448:	4003      	.short	0x4003

2000044a <SF2_DDRB_NB_SIZE>:
2000044a:	8030      	.short	0x8030
2000044c:	4003      	.short	0x4003

2000044e <SF2_DDRB_CR>:
2000044e:	8034      	.short	0x8034
20000450:	4003      	.short	0x4003

20000452 <SF2_EDAC_CR>:
20000452:	8038      	.short	0x8038
20000454:	4003      	.short	0x4003

20000456 <SF2_MDDR_MODE_CR>:
20000456:	0818      	.short	0x0818
20000458:	00004002 	.word	0x00004002
2000045c:	2000f000 	.word	0x2000f000
20000460:	20010000 	.word	0x20010000
20000464:	20003475 	.word	0x20003475
	...
20000470:	00000001 	.word	0x00000001
20000474:	00000000 	.word	0x00000000
20000478:	20000000 	.word	0x20000000
2000047c:	20000000 	.word	0x20000000
20000480:	20000190 	.word	0x20000190
20000484:	200004c0 	.word	0x200004c0
20000488:	200004c0 	.word	0x200004c0
2000048c:	20004230 	.word	0x20004230
20000490:	20004230 	.word	0x20004230
20000494:	20004230 	.word	0x20004230
20000498:	20004250 	.word	0x20004250
2000049c:	20004250 	.word	0x20004250
200004a0:	200042e0 	.word	0x200042e0
200004a4:	200042e0 	.word	0x200042e0
200004a8:	2000f000 	.word	0x2000f000
200004ac:	2000374d 	.word	0x2000374d
200004b0:	20000a05 	.word	0x20000a05
200004b4:	f3af 8000 	nop.w
200004b8:	f3af 8000 	nop.w
200004bc:	f3af 8000 	nop.w

Disassembly of section .text:

200004c0 <__do_global_dtors_aux>:
200004c0:	f244 2350 	movw	r3, #16976	; 0x4250
200004c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200004c8:	781a      	ldrb	r2, [r3, #0]
200004ca:	b90a      	cbnz	r2, 200004d0 <__do_global_dtors_aux+0x10>
200004cc:	2001      	movs	r0, #1
200004ce:	7018      	strb	r0, [r3, #0]
200004d0:	4770      	bx	lr
200004d2:	bf00      	nop

200004d4 <frame_dummy>:
200004d4:	f244 2030 	movw	r0, #16944	; 0x4230
200004d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200004dc:	b508      	push	{r3, lr}
200004de:	6803      	ldr	r3, [r0, #0]
200004e0:	b12b      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004e2:	f240 0300 	movw	r3, #0
200004e6:	f2c0 0300 	movt	r3, #0
200004ea:	b103      	cbz	r3, 200004ee <frame_dummy+0x1a>
200004ec:	4798      	blx	r3
200004ee:	bd08      	pop	{r3, pc}

200004f0 <MSS_GPIO_set_outputs>:
static __INLINE void
MSS_GPIO_set_outputs
(
   uint32_t value
)
{
200004f0:	b480      	push	{r7}
200004f2:	b083      	sub	sp, #12
200004f4:	af00      	add	r7, sp, #0
200004f6:	6078      	str	r0, [r7, #4]
    GPIO->GPIO_OUT = value;
200004f8:	f243 0300 	movw	r3, #12288	; 0x3000
200004fc:	f2c4 0301 	movt	r3, #16385	; 0x4001
20000500:	687a      	ldr	r2, [r7, #4]
20000502:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
20000506:	f107 070c 	add.w	r7, r7, #12
2000050a:	46bd      	mov	sp, r7
2000050c:	bc80      	pop	{r7}
2000050e:	4770      	bx	lr

20000510 <MSS_GPIO_get_outputs>:
        gpio_outputs = MSS_GPIO_get_outputs();
    @endcode
 */
static __INLINE uint32_t
MSS_GPIO_get_outputs( void )
{
20000510:	b480      	push	{r7}
20000512:	af00      	add	r7, sp, #0
    return GPIO->GPIO_OUT;
20000514:	f243 0300 	movw	r3, #12288	; 0x3000
20000518:	f2c4 0301 	movt	r3, #16385	; 0x4001
2000051c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
}
20000520:	4618      	mov	r0, r3
20000522:	46bd      	mov	sp, r7
20000524:	bc80      	pop	{r7}
20000526:	4770      	bx	lr

20000528 <config_mddr_lpddr>:
#define RAM_BASE_ADDR	0xA0000000

uint32_t MDDR_status=0;

void config_mddr_lpddr(void)
{
20000528:	b480      	push	{r7}
2000052a:	af00      	add	r7, sp, #0
    MDDR->core.ddrc.DYN_SOFT_RESET_CR 		        = 0x0000;
2000052c:	f640 0300 	movw	r3, #2048	; 0x800
20000530:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000534:	f04f 0200 	mov.w	r2, #0
20000538:	601a      	str	r2, [r3, #0]
    MDDR->core.ddrc.DYN_REFRESH_1_CR 				= 0x27de;
2000053a:	f640 0300 	movw	r3, #2048	; 0x800
2000053e:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000542:	f242 72de 	movw	r2, #10206	; 0x27de
20000546:	609a      	str	r2, [r3, #8]
    MDDR->core.ddrc.DYN_REFRESH_2_CR 		        = 0x030f;
20000548:	f640 0300 	movw	r3, #2048	; 0x800
2000054c:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000550:	f240 320f 	movw	r2, #783	; 0x30f
20000554:	60da      	str	r2, [r3, #12]
    MDDR->core.ddrc.DYN_POWERDOWN_CR 		        = 0x0002;
20000556:	f640 0300 	movw	r3, #2048	; 0x800
2000055a:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000055e:	f04f 0202 	mov.w	r2, #2
20000562:	611a      	str	r2, [r3, #16]
    MDDR->core.ddrc.DYN_DEBUG_CR 		        	= 0x0000;
20000564:	f640 0300 	movw	r3, #2048	; 0x800
20000568:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000056c:	f04f 0200 	mov.w	r2, #0
20000570:	615a      	str	r2, [r3, #20]
    MDDR->core.ddrc.MODE_CR 			        	= 0x00C1;
20000572:	f640 0300 	movw	r3, #2048	; 0x800
20000576:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000057a:	f04f 02c1 	mov.w	r2, #193	; 0xc1
2000057e:	619a      	str	r2, [r3, #24]
    MDDR->core.ddrc.ADDR_MAP_BANK_CR 		        = 0x099f;
20000580:	f640 0300 	movw	r3, #2048	; 0x800
20000584:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000588:	f640 129f 	movw	r2, #2463	; 0x99f
2000058c:	61da      	str	r2, [r3, #28]
    MDDR->core.ddrc.ECC_DATA_MASK_CR 		        = 0x0000;
2000058e:	f640 0300 	movw	r3, #2048	; 0x800
20000592:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000596:	f04f 0200 	mov.w	r2, #0
2000059a:	621a      	str	r2, [r3, #32]
    MDDR->core.ddrc.ADDR_MAP_COL_1_CR 		        = 0x3333;
2000059c:	f640 0300 	movw	r3, #2048	; 0x800
200005a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005a4:	f243 3233 	movw	r2, #13107	; 0x3333
200005a8:	625a      	str	r2, [r3, #36]	; 0x24
    MDDR->core.ddrc.ADDR_MAP_COL_2_CR 		        = 0xffff;
200005aa:	f640 0300 	movw	r3, #2048	; 0x800
200005ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005b2:	f64f 72ff 	movw	r2, #65535	; 0xffff
200005b6:	629a      	str	r2, [r3, #40]	; 0x28
    MDDR->core.ddrc.ADDR_MAP_ROW_1_CR 		        = 0x7777;
200005b8:	f640 0300 	movw	r3, #2048	; 0x800
200005bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005c0:	f247 7277 	movw	r2, #30583	; 0x7777
200005c4:	62da      	str	r2, [r3, #44]	; 0x2c
    MDDR->core.ddrc.ADDR_MAP_ROW_2_CR 		        = 0x0fff;
200005c6:	f640 0300 	movw	r3, #2048	; 0x800
200005ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005ce:	f640 72ff 	movw	r2, #4095	; 0xfff
200005d2:	631a      	str	r2, [r3, #48]	; 0x30
    MDDR->core.ddrc.INIT_1_CR 			        	= 0x0001;
200005d4:	f640 0300 	movw	r3, #2048	; 0x800
200005d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005dc:	f04f 0201 	mov.w	r2, #1
200005e0:	635a      	str	r2, [r3, #52]	; 0x34
    MDDR->core.ddrc.CKE_RSTN_CYCLES_CR[0] 	       	= 0x4242;
200005e2:	f640 0300 	movw	r3, #2048	; 0x800
200005e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005ea:	f244 2242 	movw	r2, #16962	; 0x4242
200005ee:	639a      	str	r2, [r3, #56]	; 0x38
    MDDR->core.ddrc.CKE_RSTN_CYCLES_CR[1] 	       	= 0x0008;
200005f0:	f640 0300 	movw	r3, #2048	; 0x800
200005f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
200005f8:	f04f 0208 	mov.w	r2, #8
200005fc:	63da      	str	r2, [r3, #60]	; 0x3c
    MDDR->core.ddrc.INIT_MR_CR 			        	= 0x0033;
200005fe:	f640 0300 	movw	r3, #2048	; 0x800
20000602:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000606:	f04f 0233 	mov.w	r2, #51	; 0x33
2000060a:	641a      	str	r2, [r3, #64]	; 0x40
    MDDR->core.ddrc.INIT_EMR_CR 		        	= 0x0020;
2000060c:	f640 0300 	movw	r3, #2048	; 0x800
20000610:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000614:	f04f 0220 	mov.w	r2, #32
20000618:	645a      	str	r2, [r3, #68]	; 0x44
    MDDR->core.ddrc.INIT_EMR2_CR 		        	= 0x0000;
2000061a:	f640 0300 	movw	r3, #2048	; 0x800
2000061e:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000622:	f04f 0200 	mov.w	r2, #0
20000626:	649a      	str	r2, [r3, #72]	; 0x48
    MDDR->core.ddrc.INIT_EMR3_CR 		        	= 0x0000;
20000628:	f640 0300 	movw	r3, #2048	; 0x800
2000062c:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000630:	f04f 0200 	mov.w	r2, #0
20000634:	64da      	str	r2, [r3, #76]	; 0x4c
    MDDR->core.ddrc.DRAM_BANK_TIMING_PARAM_CR		= 0x00c0;
20000636:	f640 0300 	movw	r3, #2048	; 0x800
2000063a:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000063e:	f04f 02c0 	mov.w	r2, #192	; 0xc0
20000642:	651a      	str	r2, [r3, #80]	; 0x50
    MDDR->core.ddrc.DRAM_RD_WR_LATENCY_CR 	       	= 0x0023;
20000644:	f640 0300 	movw	r3, #2048	; 0x800
20000648:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000064c:	f04f 0223 	mov.w	r2, #35	; 0x23
20000650:	655a      	str	r2, [r3, #84]	; 0x54
    MDDR->core.ddrc.DRAM_RD_WR_PRE_CR 		        = 0x0235;
20000652:	f640 0300 	movw	r3, #2048	; 0x800
20000656:	f2c4 0302 	movt	r3, #16386	; 0x4002
2000065a:	f240 2235 	movw	r2, #565	; 0x235
2000065e:	659a      	str	r2, [r3, #88]	; 0x58
    MDDR->core.ddrc.DRAM_MR_TIMING_PARAM_CR			= 0x0064;
20000660:	f640 0300 	movw	r3, #2048	; 0x800
20000664:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000668:	f04f 0264 	mov.w	r2, #100	; 0x64
2000066c:	65da      	str	r2, [r3, #92]	; 0x5c
    MDDR->core.ddrc.DRAM_RAS_TIMING_CR 		        = 0x0108;
2000066e:	f640 0300 	movw	r3, #2048	; 0x800
20000672:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000676:	f44f 7284 	mov.w	r2, #264	; 0x108
2000067a:	661a      	str	r2, [r3, #96]	; 0x60
    MDDR->core.ddrc.DRAM_RD_WR_TRNARND_TIME_CR		= 0x0178;
2000067c:	f640 0300 	movw	r3, #2048	; 0x800
20000680:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000684:	f44f 72bc 	mov.w	r2, #376	; 0x178
20000688:	665a      	str	r2, [r3, #100]	; 0x64
    MDDR->core.ddrc.DRAM_T_PD_CR 		        	= 0x0033;
2000068a:	f640 0300 	movw	r3, #2048	; 0x800
2000068e:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000692:	f04f 0233 	mov.w	r2, #51	; 0x33
20000696:	669a      	str	r2, [r3, #104]	; 0x68
    MDDR->core.ddrc.DRAM_BANK_ACT_TIMING_CR			= 0x1947;
20000698:	f640 0300 	movw	r3, #2048	; 0x800
2000069c:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006a0:	f641 1247 	movw	r2, #6471	; 0x1947
200006a4:	66da      	str	r2, [r3, #108]	; 0x6c
    MDDR->core.ddrc.ODT_PARAM_1_CR					= 0x0010;
200006a6:	f640 0300 	movw	r3, #2048	; 0x800
200006aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006ae:	f04f 0210 	mov.w	r2, #16
200006b2:	671a      	str	r2, [r3, #112]	; 0x70
    MDDR->core.ddrc.ODT_PARAM_2_CR					= 0x0000;
200006b4:	f640 0300 	movw	r3, #2048	; 0x800
200006b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006bc:	f04f 0200 	mov.w	r2, #0
200006c0:	675a      	str	r2, [r3, #116]	; 0x74
    MDDR->core.ddrc.ADDR_MAP_COL_3_CR 		        = 0x3300;
200006c2:	f640 0300 	movw	r3, #2048	; 0x800
200006c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006ca:	f44f 524c 	mov.w	r2, #13056	; 0x3300
200006ce:	679a      	str	r2, [r3, #120]	; 0x78
    MDDR->core.ddrc.MODE_REG_RD_WR_CR 		        = 0x0000;
200006d0:	f640 0300 	movw	r3, #2048	; 0x800
200006d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006d8:	f04f 0200 	mov.w	r2, #0
200006dc:	67da      	str	r2, [r3, #124]	; 0x7c
    MDDR->core.ddrc.MODE_REG_DATA_CR 		        = 0x0000;
200006de:	f640 0300 	movw	r3, #2048	; 0x800
200006e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006e6:	f04f 0200 	mov.w	r2, #0
200006ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    MDDR->core.ddrc.PWR_SAVE_1_CR 		       		= 0x0514;
200006ee:	f640 0300 	movw	r3, #2048	; 0x800
200006f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200006f6:	f240 5214 	movw	r2, #1300	; 0x514
200006fa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    MDDR->core.ddrc.PWR_SAVE_2_CR 		       		= 0x0000;
200006fe:	f640 0300 	movw	r3, #2048	; 0x800
20000702:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000706:	f04f 0200 	mov.w	r2, #0
2000070a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    MDDR->core.ddrc.ZQ_LONG_TIME_CR 		        = 0x0200;
2000070e:	f640 0300 	movw	r3, #2048	; 0x800
20000712:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000716:	f44f 7200 	mov.w	r2, #512	; 0x200
2000071a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    MDDR->core.ddrc.ZQ_SHORT_TIME_CR 		        = 0x0040;
2000071e:	f640 0300 	movw	r3, #2048	; 0x800
20000722:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000726:	f04f 0240 	mov.w	r2, #64	; 0x40
2000072a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    MDDR->core.ddrc.ZQ_SHORT_INT_REFRESH_MARGIN_CR[0] 	= 0x0012;
2000072e:	f640 0300 	movw	r3, #2048	; 0x800
20000732:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000736:	f04f 0212 	mov.w	r2, #18
2000073a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    MDDR->core.ddrc.ZQ_SHORT_INT_REFRESH_MARGIN_CR[1] 	= 0x0002;
2000073e:	f640 0300 	movw	r3, #2048	; 0x800
20000742:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000746:	f04f 0202 	mov.w	r2, #2
2000074a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    MDDR->core.ddrc.PERF_PARAM_1_CR 			= 0x4000;
2000074e:	f640 0300 	movw	r3, #2048	; 0x800
20000752:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000756:	f44f 4280 	mov.w	r2, #16384	; 0x4000
2000075a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    MDDR->core.ddrc.HPR_QUEUE_PARAM_CR[0]	 	= 0x80f8;
2000075e:	f640 0300 	movw	r3, #2048	; 0x800
20000762:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000766:	f248 02f8 	movw	r2, #33016	; 0x80f8
2000076a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    MDDR->core.ddrc.HPR_QUEUE_PARAM_CR[1] 	 	= 0x0007;
2000076e:	f640 0300 	movw	r3, #2048	; 0x800
20000772:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000776:	f04f 0207 	mov.w	r2, #7
2000077a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
    MDDR->core.ddrc.LPR_QUEUE_PARAM_CR[0] 	 	= 0x80f8;
2000077e:	f640 0300 	movw	r3, #2048	; 0x800
20000782:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000786:	f248 02f8 	movw	r2, #33016	; 0x80f8
2000078a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    MDDR->core.ddrc.LPR_QUEUE_PARAM_CR[1] 	 	= 0x0007;
2000078e:	f640 0300 	movw	r3, #2048	; 0x800
20000792:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000796:	f04f 0207 	mov.w	r2, #7
2000079a:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    MDDR->core.ddrc.WR_QUEUE_PARAM_CR 	 		= 0x0200;
2000079e:	f640 0300 	movw	r3, #2048	; 0x800
200007a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007a6:	f44f 7200 	mov.w	r2, #512	; 0x200
200007aa:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    MDDR->core.ddrc.PERF_PARAM_2_CR 	 		= 0x0001;
200007ae:	f640 0300 	movw	r3, #2048	; 0x800
200007b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007b6:	f04f 0201 	mov.w	r2, #1
200007ba:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    MDDR->core.ddrc.PERF_PARAM_3_CR 	 		= 0x0000;
200007be:	f640 0300 	movw	r3, #2048	; 0x800
200007c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007c6:	f04f 0200 	mov.w	r2, #0
200007ca:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    MDDR->core.ddrc.DFI_RDDATA_EN_CR 	 		= 0x0003;
200007ce:	f640 0300 	movw	r3, #2048	; 0x800
200007d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007d6:	f04f 0203 	mov.w	r2, #3
200007da:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    MDDR->core.ddrc.DFI_MIN_CTRLUPD_TIMING_CR 	= 0x0003;
200007de:	f640 0300 	movw	r3, #2048	; 0x800
200007e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007e6:	f04f 0203 	mov.w	r2, #3
200007ea:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    MDDR->core.ddrc.DFI_MAX_CTRLUPD_TIMING_CR 	= 0x0040;
200007ee:	f640 0300 	movw	r3, #2048	; 0x800
200007f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200007f6:	f04f 0240 	mov.w	r2, #64	; 0x40
200007fa:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    MDDR->core.ddrc.DFI_WR_LVL_CONTROL_CR[0] 	= 0x0000;
200007fe:	f640 0300 	movw	r3, #2048	; 0x800
20000802:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000806:	f04f 0200 	mov.w	r2, #0
2000080a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    MDDR->core.ddrc.DFI_WR_LVL_CONTROL_CR[1] 	= 0x0000;
2000080e:	f640 0300 	movw	r3, #2048	; 0x800
20000812:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000816:	f04f 0200 	mov.w	r2, #0
2000081a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    MDDR->core.ddrc.DFI_RD_LVL_CONTROL_CR[0] 	= 0x0000;
2000081e:	f640 0300 	movw	r3, #2048	; 0x800
20000822:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000826:	f04f 0200 	mov.w	r2, #0
2000082a:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    MDDR->core.ddrc.DFI_RD_LVL_CONTROL_CR[1] 	= 0x0000;
2000082e:	f640 0300 	movw	r3, #2048	; 0x800
20000832:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000836:	f04f 0200 	mov.w	r2, #0
2000083a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    MDDR->core.ddrc.DFI_CTRLUPD_TIME_INTERVAL_CR	= 0x0309;
2000083e:	f640 0300 	movw	r3, #2048	; 0x800
20000842:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000846:	f240 3209 	movw	r2, #777	; 0x309
2000084a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    MDDR->core.ddrc.AXI_FABRIC_PRI_ID_CR 		= 0x0000;
2000084e:	f640 0300 	movw	r3, #2048	; 0x800
20000852:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000856:	f04f 0200 	mov.w	r2, #0
2000085a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    MDDR->core.ddrc.ECC_INT_CLR_REG 			= 0x0000;
2000085e:	f640 0300 	movw	r3, #2048	; 0x800
20000862:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000866:	f04f 0200 	mov.w	r2, #0
2000086a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140

    MDDR->core.phy.LOOPBACK_TEST_CR 			= 0x0000;
2000086e:	f640 0300 	movw	r3, #2048	; 0x800
20000872:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000876:	f04f 0200 	mov.w	r2, #0
2000087a:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    MDDR->core.phy.CTRL_SLAVE_RATIO_CR 			= 0x0080;
2000087e:	f640 0300 	movw	r3, #2048	; 0x800
20000882:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000886:	f04f 0280 	mov.w	r2, #128	; 0x80
2000088a:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224
    MDDR->core.phy.DATA_SLICE_IN_USE_CR 		= 0x0003;
2000088e:	f640 0300 	movw	r3, #2048	; 0x800
20000892:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000896:	f04f 0203 	mov.w	r2, #3
2000089a:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
    MDDR->core.phy.DQ_OFFSET_CR[0] 				= 0x00000000;
2000089e:	f640 0300 	movw	r3, #2048	; 0x800
200008a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008a6:	f04f 0200 	mov.w	r2, #0
200008aa:	f8c3 2238 	str.w	r2, [r3, #568]	; 0x238
    MDDR->core.phy.DQ_OFFSET_CR[2] 				= 0x0000;
200008ae:	f640 0300 	movw	r3, #2048	; 0x800
200008b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008b6:	f04f 0200 	mov.w	r2, #0
200008ba:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
    MDDR->core.phy.DLL_LOCK_DIFF_CR  			= 0x000B;
200008be:	f640 0300 	movw	r3, #2048	; 0x800
200008c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008c6:	f04f 020b 	mov.w	r2, #11
200008ca:	f8c3 2248 	str.w	r2, [r3, #584]	; 0x248
    MDDR->core.phy.FIFO_WE_SLAVE_RATIO_CR[0] 	= 0x0040;
200008ce:	f640 0300 	movw	r3, #2048	; 0x800
200008d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008d6:	f04f 0240 	mov.w	r2, #64	; 0x40
200008da:	f8c3 225c 	str.w	r2, [r3, #604]	; 0x25c
    MDDR->core.phy.FIFO_WE_SLAVE_RATIO_CR[1] 	= 0x0401;
200008de:	f640 0300 	movw	r3, #2048	; 0x800
200008e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008e6:	f240 4201 	movw	r2, #1025	; 0x401
200008ea:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260
    MDDR->core.phy.FIFO_WE_SLAVE_RATIO_CR[2] 	= 0x4010;
200008ee:	f640 0300 	movw	r3, #2048	; 0x800
200008f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200008f6:	f244 0210 	movw	r2, #16400	; 0x4010
200008fa:	f8c3 2264 	str.w	r2, [r3, #612]	; 0x264
    MDDR->core.phy.FIFO_WE_SLAVE_RATIO_CR[3] 	= 0x0000;
200008fe:	f640 0300 	movw	r3, #2048	; 0x800
20000902:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000906:	f04f 0200 	mov.w	r2, #0
2000090a:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
    MDDR->core.phy.LOCAL_ODT_CR  				= 0x0001;
2000090e:	f640 0300 	movw	r3, #2048	; 0x800
20000912:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000916:	f04f 0201 	mov.w	r2, #1
2000091a:	f8c3 2280 	str.w	r2, [r3, #640]	; 0x280
    MDDR->core.phy.RD_DQS_SLAVE_RATIO_CR[0]  	= 0x0040;
2000091e:	f640 0300 	movw	r3, #2048	; 0x800
20000922:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000926:	f04f 0240 	mov.w	r2, #64	; 0x40
2000092a:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
    MDDR->core.phy.RD_DQS_SLAVE_RATIO_CR[1]  	= 0x0401;
2000092e:	f640 0300 	movw	r3, #2048	; 0x800
20000932:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000936:	f240 4201 	movw	r2, #1025	; 0x401
2000093a:	f8c3 229c 	str.w	r2, [r3, #668]	; 0x29c
    MDDR->core.phy.RD_DQS_SLAVE_RATIO_CR[2]  	= 0x4010;
2000093e:	f640 0300 	movw	r3, #2048	; 0x800
20000942:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000946:	f244 0210 	movw	r2, #16400	; 0x4010
2000094a:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
    MDDR->core.phy.WR_DATA_SLAVE_RATIO_CR[0]  	= 0x0040;
2000094e:	f640 0300 	movw	r3, #2048	; 0x800
20000952:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000956:	f04f 0240 	mov.w	r2, #64	; 0x40
2000095a:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
    MDDR->core.phy.WR_DATA_SLAVE_RATIO_CR[1]  	= 0x0401;
2000095e:	f640 0300 	movw	r3, #2048	; 0x800
20000962:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000966:	f240 4201 	movw	r2, #1025	; 0x401
2000096a:	f8c3 22dc 	str.w	r2, [r3, #732]	; 0x2dc
    MDDR->core.phy.WR_DATA_SLAVE_RATIO_CR[2]  	= 0x4010;
2000096e:	f640 0300 	movw	r3, #2048	; 0x800
20000972:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000976:	f244 0210 	movw	r2, #16400	; 0x4010
2000097a:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
    MDDR->core.phy.WR_RD_RL_CR  				= 0x0021;
2000097e:	f640 0300 	movw	r3, #2048	; 0x800
20000982:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000986:	f04f 0221 	mov.w	r2, #33	; 0x21
2000098a:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
    MDDR->core.phy.RDC_WE_TO_RE_DELAY_CR  		= 0x0003;
2000098e:	f640 0300 	movw	r3, #2048	; 0x800
20000992:	f2c4 0302 	movt	r3, #16386	; 0x4002
20000996:	f04f 0203 	mov.w	r2, #3
2000099a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    MDDR->core.phy.USE_FIXED_RE_CR  			= 0x0001;
2000099e:	f640 0300 	movw	r3, #2048	; 0x800
200009a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009a6:	f04f 0201 	mov.w	r2, #1
200009aa:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    MDDR->core.phy.USE_RANK0_DELAYS_CR  		= 0x0001;
200009ae:	f640 0300 	movw	r3, #2048	; 0x800
200009b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009b6:	f04f 0201 	mov.w	r2, #1
200009ba:	f8c3 230c 	str.w	r2, [r3, #780]	; 0x30c
    MDDR->core.phy.CONFIG_CR  			 		= 0x0009;
200009be:	f640 0300 	movw	r3, #2048	; 0x800
200009c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009c6:	f04f 0209 	mov.w	r2, #9
200009ca:	f8c3 2314 	str.w	r2, [r3, #788]	; 0x314
    MDDR->core.phy.DYN_RESET_CR  				= 0x01;
200009ce:	f640 0300 	movw	r3, #2048	; 0x800
200009d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009d6:	f04f 0201 	mov.w	r2, #1
200009da:	f8c3 231c 	str.w	r2, [r3, #796]	; 0x31c
    MDDR->core.ddrc.DYN_SOFT_RESET_CR  			= 0x01;
200009de:	f640 0300 	movw	r3, #2048	; 0x800
200009e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009e6:	f04f 0201 	mov.w	r2, #1
200009ea:	601a      	str	r2, [r3, #0]

    while((MDDR->core.ddrc.DDRC_SR) == 0x0000)
200009ec:	f640 0300 	movw	r3, #2048	; 0x800
200009f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
200009f4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
200009f8:	2b00      	cmp	r3, #0
200009fa:	d0f7      	beq.n	200009ec <config_mddr_lpddr+0x4c4>
    {
        ;
    }
}
200009fc:	46bd      	mov	sp, r7
200009fe:	bc80      	pop	{r7}
20000a00:	4770      	bx	lr
20000a02:	bf00      	nop

20000a04 <main>:

void tohexstring(char [], int);

/* Main function */
void main()
{
20000a04:	b580      	push	{r7, lr}
20000a06:	f5ad 6d8a 	sub.w	sp, sp, #1104	; 0x450
20000a0a:	af02      	add	r7, sp, #8
  uint32_t temp;
  uint32_t LoopType;
  uint32_t TxBlaster;
  uint32_t gpio_outputs;
  
  char *memptr = (char *)RAM_BASE_ADDR;
20000a0c:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
20000a10:	f8c7 3444 	str.w	r3, [r7, #1092]	; 0x444

  const uint8_t greeting[]        = "\n\r Enter:  ";
20000a14:	463a      	mov	r2, r7
20000a16:	f643 6358 	movw	r3, #15960	; 0x3e58
20000a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20000a1e:	4694      	mov	ip, r2
20000a20:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
20000a24:	e88c 0007 	stmia.w	ip, {r0, r1, r2}

  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
20000a28:	f240 0314 	movw	r3, #20
20000a2c:	f2c5 0300 	movt	r3, #20480	; 0x5000
20000a30:	f8c7 340c 	str.w	r3, [r7, #1036]	; 0x40c
  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
20000a34:	f240 0310 	movw	r3, #16
20000a38:	f2c5 0300 	movt	r3, #20480	; 0x5000
20000a3c:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
  p_FPGA_high_addr_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x30;
20000a40:	f240 0330 	movw	r3, #48	; 0x30
20000a44:	f2c5 0300 	movt	r3, #20480	; 0x5000
20000a48:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
  p_FPGA_low_addr_reg        = (uint32_t)COMMSFPGA_TOP_0 + 0x34;
20000a4c:	f240 0334 	movw	r3, #52	; 0x34
20000a50:	f2c5 0300 	movt	r3, #20480	; 0x5000
20000a54:	f8c7 3418 	str.w	r3, [r7, #1048]	; 0x418
    
  /*
   * Initialize MSS GPIOs.
   */
  MSS_GPIO_init();
20000a58:	f002 fc98 	bl	2000338c <MSS_GPIO_init>

    /*
     * Configure MSS GPIOs.
     */
    MSS_GPIO_config( MSS_GPIO_0 , MSS_GPIO_INOUT_MODE  );
20000a5c:	f04f 0000 	mov.w	r0, #0
20000a60:	f04f 0103 	mov.w	r1, #3
20000a64:	f002 fce8 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_1 , MSS_GPIO_OUTPUT_MODE );
20000a68:	f04f 0001 	mov.w	r0, #1
20000a6c:	f04f 0105 	mov.w	r1, #5
20000a70:	f002 fce2 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_2 , MSS_GPIO_INPUT_MODE  );
20000a74:	f04f 0002 	mov.w	r0, #2
20000a78:	f04f 0102 	mov.w	r1, #2
20000a7c:	f002 fcdc 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_3 , MSS_GPIO_INOUT_MODE  );
20000a80:	f04f 0003 	mov.w	r0, #3
20000a84:	f04f 0103 	mov.w	r1, #3
20000a88:	f002 fcd6 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_4 , MSS_GPIO_INOUT_MODE  );
20000a8c:	f04f 0004 	mov.w	r0, #4
20000a90:	f04f 0103 	mov.w	r1, #3
20000a94:	f002 fcd0 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_5 , MSS_GPIO_OUTPUT_MODE );
20000a98:	f04f 0005 	mov.w	r0, #5
20000a9c:	f04f 0105 	mov.w	r1, #5
20000aa0:	f002 fcca 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_6 , MSS_GPIO_OUTPUT_MODE );
20000aa4:	f04f 0006 	mov.w	r0, #6
20000aa8:	f04f 0105 	mov.w	r1, #5
20000aac:	f002 fcc4 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_7 , MSS_GPIO_OUTPUT_MODE );
20000ab0:	f04f 0007 	mov.w	r0, #7
20000ab4:	f04f 0105 	mov.w	r1, #5
20000ab8:	f002 fcbe 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_8 , MSS_GPIO_OUTPUT_MODE );
20000abc:	f04f 0008 	mov.w	r0, #8
20000ac0:	f04f 0105 	mov.w	r1, #5
20000ac4:	f002 fcb8 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_9 , MSS_GPIO_INPUT_MODE  );
20000ac8:	f04f 0009 	mov.w	r0, #9
20000acc:	f04f 0102 	mov.w	r1, #2
20000ad0:	f002 fcb2 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_10, MSS_GPIO_INPUT_MODE  );
20000ad4:	f04f 000a 	mov.w	r0, #10
20000ad8:	f04f 0102 	mov.w	r1, #2
20000adc:	f002 fcac 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_11, MSS_GPIO_OUTPUT_MODE );
20000ae0:	f04f 000b 	mov.w	r0, #11
20000ae4:	f04f 0105 	mov.w	r1, #5
20000ae8:	f002 fca6 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_12, MSS_GPIO_INOUT_MODE  );
20000aec:	f04f 000c 	mov.w	r0, #12
20000af0:	f04f 0103 	mov.w	r1, #3
20000af4:	f002 fca0 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_13, MSS_GPIO_OUTPUT_MODE );
20000af8:	f04f 000d 	mov.w	r0, #13
20000afc:	f04f 0105 	mov.w	r1, #5
20000b00:	f002 fc9a 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_14, MSS_GPIO_INOUT_MODE  );
20000b04:	f04f 000e 	mov.w	r0, #14
20000b08:	f04f 0103 	mov.w	r1, #3
20000b0c:	f002 fc94 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_15, MSS_GPIO_INOUT_MODE  );
20000b10:	f04f 000f 	mov.w	r0, #15
20000b14:	f04f 0103 	mov.w	r1, #3
20000b18:	f002 fc8e 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_16, MSS_GPIO_INOUT_MODE  );
20000b1c:	f04f 0010 	mov.w	r0, #16
20000b20:	f04f 0103 	mov.w	r1, #3
20000b24:	f002 fc88 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_17, MSS_GPIO_INOUT_MODE  );
20000b28:	f04f 0011 	mov.w	r0, #17
20000b2c:	f04f 0103 	mov.w	r1, #3
20000b30:	f002 fc82 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_18, MSS_GPIO_INOUT_MODE  );
20000b34:	f04f 0012 	mov.w	r0, #18
20000b38:	f04f 0103 	mov.w	r1, #3
20000b3c:	f002 fc7c 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_19, MSS_GPIO_INPUT_MODE  );
20000b40:	f04f 0013 	mov.w	r0, #19
20000b44:	f04f 0102 	mov.w	r1, #2
20000b48:	f002 fc76 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_20, MSS_GPIO_OUTPUT_MODE );
20000b4c:	f04f 0014 	mov.w	r0, #20
20000b50:	f04f 0105 	mov.w	r1, #5
20000b54:	f002 fc70 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_21, MSS_GPIO_OUTPUT_MODE );
20000b58:	f04f 0015 	mov.w	r0, #21
20000b5c:	f04f 0105 	mov.w	r1, #5
20000b60:	f002 fc6a 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_22, MSS_GPIO_OUTPUT_MODE );
20000b64:	f04f 0016 	mov.w	r0, #22
20000b68:	f04f 0105 	mov.w	r1, #5
20000b6c:	f002 fc64 	bl	20003438 <MSS_GPIO_config>

    MSS_GPIO_config( MSS_GPIO_24, MSS_GPIO_OUTPUT_MODE );
20000b70:	f04f 0018 	mov.w	r0, #24
20000b74:	f04f 0105 	mov.w	r1, #5
20000b78:	f002 fc5e 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_25, MSS_GPIO_INOUT_MODE  );
20000b7c:	f04f 0019 	mov.w	r0, #25
20000b80:	f04f 0103 	mov.w	r1, #3
20000b84:	f002 fc58 	bl	20003438 <MSS_GPIO_config>
    MSS_GPIO_config( MSS_GPIO_26, MSS_GPIO_INOUT_MODE  );
20000b88:	f04f 001a 	mov.w	r0, #26
20000b8c:	f04f 0103 	mov.w	r1, #3
20000b90:	f002 fc52 	bl	20003438 <MSS_GPIO_config>

    MSS_GPIO_config( MSS_GPIO_28 , MSS_GPIO_OUTPUT_MODE );
20000b94:	f04f 001c 	mov.w	r0, #28
20000b98:	f04f 0105 	mov.w	r1, #5
20000b9c:	f002 fc4c 	bl	20003438 <MSS_GPIO_config>

    MSS_GPIO_config( MSS_GPIO_31, MSS_GPIO_INOUT_MODE  );
20000ba0:	f04f 001f 	mov.w	r0, #31
20000ba4:	f04f 0103 	mov.w	r1, #3
20000ba8:	f002 fc46 	bl	20003438 <MSS_GPIO_config>

    /*
     * Initialize and configure uart0.
     */  
    MSS_UART_init
20000bac:	f244 2094 	movw	r0, #17044	; 0x4294
20000bb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bb4:	f44f 4161 	mov.w	r1, #57600	; 0xe100
20000bb8:	f04f 0203 	mov.w	r2, #3
20000bbc:	f001 fe60 	bl	20002880 <MSS_UART_init>
      MSS_UART_57600_BAUD,
      MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT
    );

  /* Send the Microsemi Logo over the UART_1 */
  MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000bc0:	f244 2094 	movw	r0, #17044	; 0x4294
20000bc4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bc8:	f243 719c 	movw	r1, #14236	; 0x379c
20000bcc:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000bd0:	f001 ff0a 	bl	200029e8 <MSS_UART_polled_tx_string>

  /* Send greeting message over the UART_1 */
  MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000bd4:	463b      	mov	r3, r7
20000bd6:	f244 2094 	movw	r0, #17044	; 0x4294
20000bda:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000bde:	4619      	mov	r1, r3
20000be0:	f04f 020c 	mov.w	r2, #12
20000be4:	f001 fe8e 	bl	20002904 <MSS_UART_polled_tx>


  /* Take FPGA out of Reset */
  gpio_outputs = MSS_GPIO_get_outputs();
20000be8:	f7ff fc92 	bl	20000510 <MSS_GPIO_get_outputs>
20000bec:	4603      	mov	r3, r0
20000bee:	f8c7 3440 	str.w	r3, [r7, #1088]	; 0x440
  gpio_outputs &= ~( MSS_GPIO_28_MASK );
20000bf2:	f8d7 3440 	ldr.w	r3, [r7, #1088]	; 0x440
20000bf6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20000bfa:	f8c7 3440 	str.w	r3, [r7, #1088]	; 0x440
  MSS_GPIO_set_outputs( gpio_outputs );
20000bfe:	f8d7 0440 	ldr.w	r0, [r7, #1088]	; 0x440
20000c02:	f7ff fc75 	bl	200004f0 <MSS_GPIO_set_outputs>


  /*                           */
  /* Initialize the DDR Memory */
  /*                           */
    config_mddr_lpddr();
20000c06:	f7ff fc8f 	bl	20000528 <config_mddr_lpddr>

  /* Reset FIFOs    */
  tx_fifo_reset();
20000c0a:	f000 fea7 	bl	2000195c <tx_fifo_reset>
  rx_fifo_reset();
20000c0e:	f000 fecb 	bl	200019a8 <rx_fifo_reset>

  /* Clear an Interrupts */
  temp = *p_FPGA_interrupt_reg;
20000c12:	f8d7 340c 	ldr.w	r3, [r7, #1036]	; 0x40c
20000c16:	681b      	ldr	r3, [r3, #0]
20000c18:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434

  /* Initialize FPGA Address Register (aka Consumer Register */
  *p_FPGA_high_addr_reg = 0x00000002;
20000c1c:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
20000c20:	f04f 0202 	mov.w	r2, #2
20000c24:	601a      	str	r2, [r3, #0]
  *p_FPGA_low_addr_reg  = 0x000000A9;
20000c26:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
20000c2a:	f04f 02a9 	mov.w	r2, #169	; 0xa9
20000c2e:	601a      	str	r2, [r3, #0]

  /* Disable Loopback */
  *p_FPGA_control_reg = 0x00000000;
20000c30:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
20000c34:	f04f 0200 	mov.w	r2, #0
20000c38:	601a      	str	r2, [r3, #0]
  
//  packet_length    = 0x200;   // 512 bytes
  TxBlaster              = 1;
20000c3a:	f04f 0301 	mov.w	r3, #1
20000c3e:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
  packet_length          = 0x08;
20000c42:	f04f 0308 	mov.w	r3, #8
20000c46:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
  packet_iterations_init = 0x7D0;  //0x406;
20000c4a:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
20000c4e:	f8c7 3430 	str.w	r3, [r7, #1072]	; 0x430
  packet_iterations = packet_iterations_init;  //0x406;
20000c52:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
20000c56:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
  consumer_address = 0x000002A9;
20000c5a:	f240 23a9 	movw	r3, #681	; 0x2a9
20000c5e:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
20000c62:	e000      	b.n	20000c66 <main+0x262>
            	  MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
            	break;
          }
        }    
  }
20000c64:	bf00      	nop
  packet_iterations = packet_iterations_init;  //0x406;
  consumer_address = 0x000002A9;

  while(1)
  {
      uart0_rx_size = MSS_UART_get_rx( &g_mss_uart0, uart0_rx_buff, sizeof(uart0_rx_buff) );
20000c66:	f107 0318 	add.w	r3, r7, #24
20000c6a:	f1a3 030c 	sub.w	r3, r3, #12
20000c6e:	f244 2094 	movw	r0, #17044	; 0x4294
20000c72:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000c76:	4619      	mov	r1, r3
20000c78:	f44f 6280 	mov.w	r2, #1024	; 0x400
20000c7c:	f001 ff1a 	bl	20002ab4 <MSS_UART_get_rx>
20000c80:	4603      	mov	r3, r0
20000c82:	f8c7 3420 	str.w	r3, [r7, #1056]	; 0x420
      num_press = *uart0_rx_buff;
20000c86:	f107 0318 	add.w	r3, r7, #24
20000c8a:	f1a3 030c 	sub.w	r3, r3, #12
20000c8e:	781b      	ldrb	r3, [r3, #0]
20000c90:	f887 341f 	strb.w	r3, [r7, #1055]	; 0x41f

      if (uart0_rx_size > 0)
20000c94:	f8d7 3420 	ldr.w	r3, [r7, #1056]	; 0x420
20000c98:	2b00      	cmp	r3, #0
20000c9a:	d0e3      	beq.n	20000c64 <main+0x260>
        {
          MSS_UART_polled_tx( &g_mss_uart0, uart0_rx_buff, uart0_rx_size );
20000c9c:	f107 0318 	add.w	r3, r7, #24
20000ca0:	f1a3 030c 	sub.w	r3, r3, #12
20000ca4:	f244 2094 	movw	r0, #17044	; 0x4294
20000ca8:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000cac:	4619      	mov	r1, r3
20000cae:	f8d7 2420 	ldr.w	r2, [r7, #1056]	; 0x420
20000cb2:	f001 fe27 	bl	20002904 <MSS_UART_polled_tx>

            switch ( num_press ) {
20000cb6:	f897 341f 	ldrb.w	r3, [r7, #1055]	; 0x41f
20000cba:	f1a3 0331 	sub.w	r3, r3, #49	; 0x31
20000cbe:	2b39      	cmp	r3, #57	; 0x39
20000cc0:	f200 8411 	bhi.w	200014e6 <main+0xae2>
20000cc4:	a201      	add	r2, pc, #4	; (adr r2, 20000ccc <main+0x2c8>)
20000cc6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20000cca:	bf00      	nop
20000ccc:	20000db5 	.word	0x20000db5
20000cd0:	20000df7 	.word	0x20000df7
20000cd4:	20000e39 	.word	0x20000e39
20000cd8:	20000e7b 	.word	0x20000e7b
20000cdc:	20000edd 	.word	0x20000edd
20000ce0:	20000f2b 	.word	0x20000f2b
20000ce4:	20000f9b 	.word	0x20000f9b
20000ce8:	20000ffd 	.word	0x20000ffd
20000cec:	2000104b 	.word	0x2000104b
20000cf0:	200014e7 	.word	0x200014e7
20000cf4:	200014e7 	.word	0x200014e7
20000cf8:	200014e7 	.word	0x200014e7
20000cfc:	200014e7 	.word	0x200014e7
20000d00:	200014e7 	.word	0x200014e7
20000d04:	200014e7 	.word	0x200014e7
20000d08:	200014e7 	.word	0x200014e7
20000d0c:	200014e7 	.word	0x200014e7
20000d10:	200014e7 	.word	0x200014e7
20000d14:	200014e7 	.word	0x200014e7
20000d18:	200014e7 	.word	0x200014e7
20000d1c:	200014e7 	.word	0x200014e7
20000d20:	200014e7 	.word	0x200014e7
20000d24:	200014e7 	.word	0x200014e7
20000d28:	200014e7 	.word	0x200014e7
20000d2c:	200014e7 	.word	0x200014e7
20000d30:	200014e7 	.word	0x200014e7
20000d34:	200014e7 	.word	0x200014e7
20000d38:	200014e7 	.word	0x200014e7
20000d3c:	200014e7 	.word	0x200014e7
20000d40:	200014e7 	.word	0x200014e7
20000d44:	200014e7 	.word	0x200014e7
20000d48:	200014e7 	.word	0x200014e7
20000d4c:	200014e7 	.word	0x200014e7
20000d50:	200014e7 	.word	0x200014e7
20000d54:	200014e7 	.word	0x200014e7
20000d58:	200014e7 	.word	0x200014e7
20000d5c:	200014e7 	.word	0x200014e7
20000d60:	200014e7 	.word	0x200014e7
20000d64:	200014e7 	.word	0x200014e7
20000d68:	200014e7 	.word	0x200014e7
20000d6c:	200014e7 	.word	0x200014e7
20000d70:	200014e7 	.word	0x200014e7
20000d74:	200014e7 	.word	0x200014e7
20000d78:	200014e7 	.word	0x200014e7
20000d7c:	200014e7 	.word	0x200014e7
20000d80:	200014e7 	.word	0x200014e7
20000d84:	200014e7 	.word	0x200014e7
20000d88:	200014e7 	.word	0x200014e7
20000d8c:	200010bb 	.word	0x200010bb
20000d90:	20001129 	.word	0x20001129
20000d94:	2000118b 	.word	0x2000118b
20000d98:	20001205 	.word	0x20001205
20000d9c:	20001273 	.word	0x20001273
20000da0:	20001305 	.word	0x20001305
20000da4:	20001347 	.word	0x20001347
20000da8:	200014e7 	.word	0x200014e7
20000dac:	200013bf 	.word	0x200013bf
20000db0:	20001447 	.word	0x20001447
              case '1':
                print_registers();
20000db4:	f000 fbba 	bl	2000152c <print_registers>
               	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r" );
20000db8:	f244 2094 	movw	r0, #17044	; 0x4294
20000dbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dc0:	f643 21c4 	movw	r1, #15044	; 0x3ac4
20000dc4:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000dc8:	f001 fe0e 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000dcc:	f244 2094 	movw	r0, #17044	; 0x4294
20000dd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dd4:	f243 719c 	movw	r1, #14236	; 0x379c
20000dd8:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000ddc:	f001 fe04 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000de0:	463b      	mov	r3, r7
20000de2:	f244 2094 	movw	r0, #17044	; 0x4294
20000de6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dea:	4619      	mov	r1, r3
20000dec:	f04f 020c 	mov.w	r2, #12
20000df0:	f001 fd88 	bl	20002904 <MSS_UART_polled_tx>
            	  break;
20000df4:	e397      	b.n	20001526 <main+0xb22>
              case '2':
               	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Reset Receive FIFO... \n\r" );
20000df6:	f244 2094 	movw	r0, #17044	; 0x4294
20000dfa:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000dfe:	f643 21cc 	movw	r1, #15052	; 0x3acc
20000e02:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e06:	f001 fdef 	bl	200029e8 <MSS_UART_polled_tx_string>
              	rx_fifo_reset();
20000e0a:	f000 fdcd 	bl	200019a8 <rx_fifo_reset>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000e0e:	f244 2094 	movw	r0, #17044	; 0x4294
20000e12:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e16:	f243 719c 	movw	r1, #14236	; 0x379c
20000e1a:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e1e:	f001 fde3 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000e22:	463b      	mov	r3, r7
20000e24:	f244 2094 	movw	r0, #17044	; 0x4294
20000e28:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e2c:	4619      	mov	r1, r3
20000e2e:	f04f 020c 	mov.w	r2, #12
20000e32:	f001 fd67 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000e36:	e376      	b.n	20001526 <main+0xb22>
              case '3':
               	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Reset Transmit FIFO... \n\r" );
20000e38:	f244 2094 	movw	r0, #17044	; 0x4294
20000e3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e40:	f643 21ec 	movw	r1, #15084	; 0x3aec
20000e44:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e48:	f001 fdce 	bl	200029e8 <MSS_UART_polled_tx_string>
              	tx_fifo_reset();
20000e4c:	f000 fd86 	bl	2000195c <tx_fifo_reset>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000e50:	f244 2094 	movw	r0, #17044	; 0x4294
20000e54:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e58:	f243 719c 	movw	r1, #14236	; 0x379c
20000e5c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e60:	f001 fdc2 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000e64:	463b      	mov	r3, r7
20000e66:	f244 2094 	movw	r0, #17044	; 0x4294
20000e6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e6e:	4619      	mov	r1, r3
20000e70:	f04f 020c 	mov.w	r2, #12
20000e74:	f001 fd46 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000e78:	e355      	b.n	20001526 <main+0xb22>
              case '4':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmitting Single Packet - Internal Loopback... \n\r" );
20000e7a:	f244 2094 	movw	r0, #17044	; 0x4294
20000e7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000e82:	f643 310c 	movw	r1, #15116	; 0x3b0c
20000e86:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000e8a:	f001 fdad 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType = 0x00000001;
20000e8e:	f04f 0301 	mov.w	r3, #1
20000e92:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster = 0;
20000e96:	f04f 0300 	mov.w	r3, #0
20000e9a:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                fill_tx_message ( consumer_address, packet_length, LoopType, TxBlaster  );
20000e9e:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20000ea2:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20000ea6:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
20000eaa:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
20000eae:	f000 fc63 	bl	20001778 <fill_tx_message>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000eb2:	f244 2094 	movw	r0, #17044	; 0x4294
20000eb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000eba:	f243 719c 	movw	r1, #14236	; 0x379c
20000ebe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000ec2:	f001 fd91 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000ec6:	463b      	mov	r3, r7
20000ec8:	f244 2094 	movw	r0, #17044	; 0x4294
20000ecc:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ed0:	4619      	mov	r1, r3
20000ed2:	f04f 020c 	mov.w	r2, #12
20000ed6:	f001 fd15 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000eda:	e324      	b.n	20001526 <main+0xb22>
              case '5':
              	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Receive Signle Packet and Check - Internal Loopback... \n\r" );
20000edc:	f244 2094 	movw	r0, #17044	; 0x4294
20000ee0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ee4:	f643 3148 	movw	r1, #15176	; 0x3b48
20000ee8:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000eec:	f001 fd7c 	bl	200029e8 <MSS_UART_polled_tx_string>
              	check_rx_message ( consumer_address, packet_length, 0 );
20000ef0:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20000ef4:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20000ef8:	f04f 0200 	mov.w	r2, #0
20000efc:	f000 fd9a 	bl	20001a34 <check_rx_message>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000f00:	f244 2094 	movw	r0, #17044	; 0x4294
20000f04:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f08:	f243 719c 	movw	r1, #14236	; 0x379c
20000f0c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f10:	f001 fd6a 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000f14:	463b      	mov	r3, r7
20000f16:	f244 2094 	movw	r0, #17044	; 0x4294
20000f1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f1e:	4619      	mov	r1, r3
20000f20:	f04f 020c 	mov.w	r2, #12
20000f24:	f001 fcee 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000f28:	e2fd      	b.n	20001526 <main+0xb22>
              case '6':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Looping Back Packets Ranging in Size from 8 Bytes to 2008 Bytes - Internal Loopback...  \n\r" );
20000f2a:	f244 2094 	movw	r0, #17044	; 0x4294
20000f2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f32:	f643 3188 	movw	r1, #15240	; 0x3b88
20000f36:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f3a:	f001 fd55 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType = 0x00000001;
20000f3e:	f04f 0301 	mov.w	r3, #1
20000f42:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster = 1;
20000f46:	f04f 0301 	mov.w	r3, #1
20000f4a:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                packet_iterations = packet_iterations_init;  //0x406;
20000f4e:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
20000f52:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                packet_loopback ( consumer_address, packet_length, packet_iterations, LoopType, TxBlaster  );
20000f56:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
20000f5a:	9300      	str	r3, [sp, #0]
20000f5c:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20000f60:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20000f64:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
20000f68:	f8d7 3438 	ldr.w	r3, [r7, #1080]	; 0x438
20000f6c:	f000 feb4 	bl	20001cd8 <packet_loopback>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000f70:	f244 2094 	movw	r0, #17044	; 0x4294
20000f74:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f78:	f243 719c 	movw	r1, #14236	; 0x379c
20000f7c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000f80:	f001 fd32 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000f84:	463b      	mov	r3, r7
20000f86:	f244 2094 	movw	r0, #17044	; 0x4294
20000f8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000f8e:	4619      	mov	r1, r3
20000f90:	f04f 020c 	mov.w	r2, #12
20000f94:	f001 fcb6 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000f98:	e2c5      	b.n	20001526 <main+0xb22>
              case '7':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmitting Single Packet - EXTERNAL Loopback... \n\r" );
20000f9a:	f244 2094 	movw	r0, #17044	; 0x4294
20000f9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000fa2:	f643 31e8 	movw	r1, #15336	; 0x3be8
20000fa6:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000faa:	f001 fd1d 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType = 0x00000002;
20000fae:	f04f 0302 	mov.w	r3, #2
20000fb2:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster = 1;
20000fb6:	f04f 0301 	mov.w	r3, #1
20000fba:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                fill_tx_message ( consumer_address, packet_length, LoopType, TxBlaster  );
20000fbe:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20000fc2:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20000fc6:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
20000fca:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
20000fce:	f000 fbd3 	bl	20001778 <fill_tx_message>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20000fd2:	f244 2094 	movw	r0, #17044	; 0x4294
20000fd6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000fda:	f243 719c 	movw	r1, #14236	; 0x379c
20000fde:	f2c2 0100 	movt	r1, #8192	; 0x2000
20000fe2:	f001 fd01 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20000fe6:	463b      	mov	r3, r7
20000fe8:	f244 2094 	movw	r0, #17044	; 0x4294
20000fec:	f2c2 0000 	movt	r0, #8192	; 0x2000
20000ff0:	4619      	mov	r1, r3
20000ff2:	f04f 020c 	mov.w	r2, #12
20000ff6:	f001 fc85 	bl	20002904 <MSS_UART_polled_tx>
                break;
20000ffa:	e294      	b.n	20001526 <main+0xb22>
              case '8':
              	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Receive Single Packet and Check - EXTERNAL Loopback... \n\r" );
20000ffc:	f244 2094 	movw	r0, #17044	; 0x4294
20001000:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001004:	f643 4124 	movw	r1, #15396	; 0x3c24
20001008:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000100c:	f001 fcec 	bl	200029e8 <MSS_UART_polled_tx_string>
              	check_rx_message ( consumer_address, packet_length, 0 );
20001010:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001014:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001018:	f04f 0200 	mov.w	r2, #0
2000101c:	f000 fd0a 	bl	20001a34 <check_rx_message>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001020:	f244 2094 	movw	r0, #17044	; 0x4294
20001024:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001028:	f243 719c 	movw	r1, #14236	; 0x379c
2000102c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001030:	f001 fcda 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20001034:	463b      	mov	r3, r7
20001036:	f244 2094 	movw	r0, #17044	; 0x4294
2000103a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000103e:	4619      	mov	r1, r3
20001040:	f04f 020c 	mov.w	r2, #12
20001044:	f001 fc5e 	bl	20002904 <MSS_UART_polled_tx>
                break;
20001048:	e26d      	b.n	20001526 <main+0xb22>
              case '9':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Looping Back Packets Range 8 to 2008 Bytes - EXTERNAL Loopback...  \n\r" );
2000104a:	f244 2094 	movw	r0, #17044	; 0x4294
2000104e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001052:	f643 4164 	movw	r1, #15460	; 0x3c64
20001056:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000105a:	f001 fcc5 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType = 0x00000002;
2000105e:	f04f 0302 	mov.w	r3, #2
20001062:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster = 1;
20001066:	f04f 0301 	mov.w	r3, #1
2000106a:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                packet_iterations = packet_iterations_init;  //0x406;
2000106e:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
20001072:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                packet_loopback ( consumer_address, packet_length, packet_iterations, LoopType, TxBlaster  );
20001076:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
2000107a:	9300      	str	r3, [sp, #0]
2000107c:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001080:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001084:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
20001088:	f8d7 3438 	ldr.w	r3, [r7, #1080]	; 0x438
2000108c:	f000 fe24 	bl	20001cd8 <packet_loopback>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001090:	f244 2094 	movw	r0, #17044	; 0x4294
20001094:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001098:	f243 719c 	movw	r1, #14236	; 0x379c
2000109c:	f2c2 0100 	movt	r1, #8192	; 0x2000
200010a0:	f001 fca2 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
200010a4:	463b      	mov	r3, r7
200010a6:	f244 2094 	movw	r0, #17044	; 0x4294
200010aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200010ae:	4619      	mov	r1, r3
200010b0:	f04f 020c 	mov.w	r2, #12
200010b4:	f001 fc26 	bl	20002904 <MSS_UART_polled_tx>
                break; 
200010b8:	e235      	b.n	20001526 <main+0xb22>
              case 'a':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmiting Board to Board Single Packet... \n\r" );
200010ba:	f244 2094 	movw	r0, #17044	; 0x4294
200010be:	f2c2 0000 	movt	r0, #8192	; 0x2000
200010c2:	f643 41b0 	movw	r1, #15536	; 0x3cb0
200010c6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200010ca:	f001 fc8d 	bl	200029e8 <MSS_UART_polled_tx_string>
                packet_length    = 0x3F9;  //0x08 0x3F9;;
200010ce:	f240 33f9 	movw	r3, #1017	; 0x3f9
200010d2:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                consumer_address = 0x000002A8; 
200010d6:	f44f 732a 	mov.w	r3, #680	; 0x2a8
200010da:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                TxBlaster        = 1;
200010de:	f04f 0301 	mov.w	r3, #1
200010e2:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                b2b_single_tx_message_send ( consumer_address, packet_length, TxBlaster );
200010e6:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
200010ea:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
200010ee:	f8d7 243c 	ldr.w	r2, [r7, #1084]	; 0x43c
200010f2:	f000 fe31 	bl	20001d58 <b2b_single_tx_message_send>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
200010f6:	f244 2094 	movw	r0, #17044	; 0x4294
200010fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
200010fe:	f243 719c 	movw	r1, #14236	; 0x379c
20001102:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001106:	f001 fc6f 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
2000110a:	463b      	mov	r3, r7
2000110c:	f244 2094 	movw	r0, #17044	; 0x4294
20001110:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001114:	4619      	mov	r1, r3
20001116:	f04f 020c 	mov.w	r2, #12
2000111a:	f001 fbf3 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address = 0x000002A9;
2000111e:	f240 23a9 	movw	r3, #681	; 0x2a9
20001122:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                break;
20001126:	e1fe      	b.n	20001526 <main+0xb22>
              case 'b':
              	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Receiving Board to Board Single Packet and Check... \n\r" );
20001128:	f244 2094 	movw	r0, #17044	; 0x4294
2000112c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001130:	f643 41e4 	movw	r1, #15588	; 0x3ce4
20001134:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001138:	f001 fc56 	bl	200029e8 <MSS_UART_polled_tx_string>
              	packet_length    = 0x3F9;  //0x08;
2000113c:	f240 33f9 	movw	r3, #1017	; 0x3f9
20001140:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                consumer_address = 0x000002A8;
20001144:	f44f 732a 	mov.w	r3, #680	; 0x2a8
20001148:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
              	b2b_single_rx_message_check ( consumer_address, packet_length );
2000114c:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001150:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001154:	f000 fe92 	bl	20001e7c <b2b_single_rx_message_check>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001158:	f244 2094 	movw	r0, #17044	; 0x4294
2000115c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001160:	f243 719c 	movw	r1, #14236	; 0x379c
20001164:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001168:	f001 fc3e 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
2000116c:	463b      	mov	r3, r7
2000116e:	f244 2094 	movw	r0, #17044	; 0x4294
20001172:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001176:	4619      	mov	r1, r3
20001178:	f04f 020c 	mov.w	r2, #12
2000117c:	f001 fbc2 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address = 0x000002A9;
20001180:	f240 23a9 	movw	r3, #681	; 0x2a9
20001184:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                break;
20001188:	e1cd      	b.n	20001526 <main+0xb22>
              case 'c':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmitting Board to Board Multiple Packets... \n\r" );
2000118a:	f244 2094 	movw	r0, #17044	; 0x4294
2000118e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001192:	f643 5120 	movw	r1, #15648	; 0x3d20
20001196:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000119a:	f001 fc25 	bl	200029e8 <MSS_UART_polled_tx_string>
                packet_length    = 0x08;
2000119e:	f04f 0308 	mov.w	r3, #8
200011a2:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                consumer_address = 0x000002A8;
200011a6:	f44f 732a 	mov.w	r3, #680	; 0x2a8
200011aa:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                TxBlaster        = 1;
200011ae:	f04f 0301 	mov.w	r3, #1
200011b2:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                packet_iterations = packet_iterations_init;  //0x406;
200011b6:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
200011ba:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                b2b_multiple_tx_message_send ( consumer_address, packet_length, packet_iterations, TxBlaster );
200011be:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
200011c2:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
200011c6:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
200011ca:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
200011ce:	f001 f94d 	bl	2000246c <b2b_multiple_tx_message_send>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
200011d2:	f244 2094 	movw	r0, #17044	; 0x4294
200011d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011da:	f243 719c 	movw	r1, #14236	; 0x379c
200011de:	f2c2 0100 	movt	r1, #8192	; 0x2000
200011e2:	f001 fc01 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
200011e6:	463b      	mov	r3, r7
200011e8:	f244 2094 	movw	r0, #17044	; 0x4294
200011ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
200011f0:	4619      	mov	r1, r3
200011f2:	f04f 020c 	mov.w	r2, #12
200011f6:	f001 fb85 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address = 0x000002A9;
200011fa:	f240 23a9 	movw	r3, #681	; 0x2a9
200011fe:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                break;
20001202:	e190      	b.n	20001526 <main+0xb22>
              case 'd':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Receiving Board to Board Multiple Packets... \n\r" );
20001204:	f244 2094 	movw	r0, #17044	; 0x4294
20001208:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000120c:	f643 5158 	movw	r1, #15704	; 0x3d58
20001210:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001214:	f001 fbe8 	bl	200029e8 <MSS_UART_polled_tx_string>
                packet_length    = 0x08;
20001218:	f04f 0308 	mov.w	r3, #8
2000121c:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                consumer_address = 0x000002A8;
20001220:	f44f 732a 	mov.w	r3, #680	; 0x2a8
20001224:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                packet_iterations = packet_iterations_init;  //0x406;
20001228:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
2000122c:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                b2b_multiple_rx_message_check ( consumer_address, packet_length, packet_iterations );
20001230:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001234:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001238:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
2000123c:	f001 f962 	bl	20002504 <b2b_multiple_rx_message_check>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001240:	f244 2094 	movw	r0, #17044	; 0x4294
20001244:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001248:	f243 719c 	movw	r1, #14236	; 0x379c
2000124c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001250:	f001 fbca 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20001254:	463b      	mov	r3, r7
20001256:	f244 2094 	movw	r0, #17044	; 0x4294
2000125a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000125e:	4619      	mov	r1, r3
20001260:	f04f 020c 	mov.w	r2, #12
20001264:	f001 fb4e 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address = 0x000002A9;
20001268:	f240 23a9 	movw	r3, #681	; 0x2a9
2000126c:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                break;
20001270:	e159      	b.n	20001526 <main+0xb22>
              case 'e':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmit Packet Blaster. \n\r" );
20001272:	f244 2094 	movw	r0, #17044	; 0x4294
20001276:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000127a:	f643 5190 	movw	r1, #15760	; 0x3d90
2000127e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001282:	f001 fbb1 	bl	200029e8 <MSS_UART_polled_tx_string>
                consumer_address = 0x00000200;
20001286:	f44f 7300 	mov.w	r3, #512	; 0x200
2000128a:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                packet_length    = 0x03E8;
2000128e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
20001292:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                packet_iterations = 0x10000;
20001296:	f44f 3380 	mov.w	r3, #65536	; 0x10000
2000129a:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                TxBlaster        = 1;
2000129e:	f04f 0301 	mov.w	r3, #1
200012a2:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                b2b_multiple_tx_message_blast ( consumer_address, packet_length, packet_iterations, TxBlaster );
200012a6:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
200012aa:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
200012ae:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
200012b2:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
200012b6:	f001 f95d 	bl	20002574 <b2b_multiple_tx_message_blast>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
200012ba:	f244 2094 	movw	r0, #17044	; 0x4294
200012be:	f2c2 0000 	movt	r0, #8192	; 0x2000
200012c2:	f243 719c 	movw	r1, #14236	; 0x379c
200012c6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200012ca:	f001 fb8d 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
200012ce:	463b      	mov	r3, r7
200012d0:	f244 2094 	movw	r0, #17044	; 0x4294
200012d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200012d8:	4619      	mov	r1, r3
200012da:	f04f 020c 	mov.w	r2, #12
200012de:	f001 fb11 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address = 0x000002A9;
200012e2:	f240 23a9 	movw	r3, #681	; 0x2a9
200012e6:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                packet_length    = 0x08;
200012ea:	f04f 0308 	mov.w	r3, #8
200012ee:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                packet_iterations = packet_iterations_init;
200012f2:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
200012f6:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                TxBlaster         = 1;
200012fa:	f04f 0301 	mov.w	r3, #1
200012fe:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                break;  
20001302:	e110      	b.n	20001526 <main+0xb22>
              case 'f':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Reset FPGA Logic. \n\r" );
20001304:	f244 2094 	movw	r0, #17044	; 0x4294
20001308:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000130c:	f643 51b4 	movw	r1, #15796	; 0x3db4
20001310:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001314:	f001 fb68 	bl	200029e8 <MSS_UART_polled_tx_string>
                SW_reset();
20001318:	f000 fb68 	bl	200019ec <SW_reset>
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
2000131c:	f244 2094 	movw	r0, #17044	; 0x4294
20001320:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001324:	f243 719c 	movw	r1, #14236	; 0x379c
20001328:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000132c:	f001 fb5c 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20001330:	463b      	mov	r3, r7
20001332:	f244 2094 	movw	r0, #17044	; 0x4294
20001336:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000133a:	4619      	mov	r1, r3
2000133c:	f04f 020c 	mov.w	r2, #12
20001340:	f001 fae0 	bl	20002904 <MSS_UART_polled_tx>
                break; 
20001344:	e0ef      	b.n	20001526 <main+0xb22>
              case 'g':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Blaster Packet Loopback \n\r" );
20001346:	f244 2094 	movw	r0, #17044	; 0x4294
2000134a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000134e:	f643 51d0 	movw	r1, #15824	; 0x3dd0
20001352:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001356:	f001 fb47 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType          = 0x00000002;
2000135a:	f04f 0302 	mov.w	r3, #2
2000135e:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster         = 1;
20001362:	f04f 0301 	mov.w	r3, #1
20001366:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                consumer_address  = 0x000002A9;
2000136a:	f240 23a9 	movw	r3, #681	; 0x2a9
2000136e:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                packet_iterations = packet_iterations_init;  //0x406;
20001372:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
20001376:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                blaster_packet_loopback ( consumer_address, packet_length, 
2000137a:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
2000137e:	9300      	str	r3, [sp, #0]
20001380:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001384:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001388:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
2000138c:	f8d7 3438 	ldr.w	r3, [r7, #1080]	; 0x438
20001390:	f001 f938 	bl	20002604 <blaster_packet_loopback>
                                          packet_iterations, LoopType, TxBlaster );
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001394:	f244 2094 	movw	r0, #17044	; 0x4294
20001398:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000139c:	f243 719c 	movw	r1, #14236	; 0x379c
200013a0:	f2c2 0100 	movt	r1, #8192	; 0x2000
200013a4:	f001 fb20 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
200013a8:	463b      	mov	r3, r7
200013aa:	f244 2094 	movw	r0, #17044	; 0x4294
200013ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
200013b2:	4619      	mov	r1, r3
200013b4:	f04f 020c 	mov.w	r2, #12
200013b8:	f001 faa4 	bl	20002904 <MSS_UART_polled_tx>
                break;    
200013bc:	e0b3      	b.n	20001526 <main+0xb22>
              case 'i':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Transmit B2B Blaster Packet \n\r" );
200013be:	f244 2094 	movw	r0, #17044	; 0x4294
200013c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200013c6:	f643 51f0 	movw	r1, #15856	; 0x3df0
200013ca:	f2c2 0100 	movt	r1, #8192	; 0x2000
200013ce:	f001 fb0b 	bl	200029e8 <MSS_UART_polled_tx_string>
                LoopType          = 0x00000000;
200013d2:	f04f 0300 	mov.w	r3, #0
200013d6:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
                TxBlaster         = 1;
200013da:	f04f 0301 	mov.w	r3, #1
200013de:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
                consumer_address  = 0x000002A9;
200013e2:	f240 23a9 	movw	r3, #681	; 0x2a9
200013e6:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                packet_length     = 0x08;
200013ea:	f04f 0308 	mov.w	r3, #8
200013ee:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                packet_iterations = 0x0F;
200013f2:	f04f 030f 	mov.w	r3, #15
200013f6:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                TX_blaster_packet ( consumer_address, packet_length, 
200013fa:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
200013fe:	9300      	str	r3, [sp, #0]
20001400:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001404:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001408:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
2000140c:	f8d7 3438 	ldr.w	r3, [r7, #1080]	; 0x438
20001410:	f001 f95a 	bl	200026c8 <TX_blaster_packet>
                                    packet_iterations, LoopType, TxBlaster );
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
20001414:	f244 2094 	movw	r0, #17044	; 0x4294
20001418:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000141c:	f243 719c 	movw	r1, #14236	; 0x379c
20001420:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001424:	f001 fae0 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
20001428:	463b      	mov	r3, r7
2000142a:	f244 2094 	movw	r0, #17044	; 0x4294
2000142e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001432:	4619      	mov	r1, r3
20001434:	f04f 020c 	mov.w	r2, #12
20001438:	f001 fa64 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address  = 0x000002A9;
2000143c:	f240 23a9 	movw	r3, #681	; 0x2a9
20001440:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                break; 
20001444:	e06f      	b.n	20001526 <main+0xb22>
              case 'j':
                MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Receive B2B Blaster Packet \n\r" );
20001446:	f244 2094 	movw	r0, #17044	; 0x4294
2000144a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000144e:	f643 6114 	movw	r1, #15892	; 0x3e14
20001452:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001456:	f001 fac7 	bl	200029e8 <MSS_UART_polled_tx_string>
                consumer_address      = 0x000002A9;
2000145a:	f240 23a9 	movw	r3, #681	; 0x2a9
2000145e:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                *p_FPGA_high_addr_reg = 0x00000002;
20001462:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
20001466:	f04f 0202 	mov.w	r2, #2
2000146a:	601a      	str	r2, [r3, #0]
                *p_FPGA_low_addr_reg  = 0x000000A9;
2000146c:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
20001470:	f04f 02a9 	mov.w	r2, #169	; 0xa9
20001474:	601a      	str	r2, [r3, #0]
                *p_FPGA_control_reg   = 0x00000000;  // Disable Loopback
20001476:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
2000147a:	f04f 0200 	mov.w	r2, #0
2000147e:	601a      	str	r2, [r3, #0]
                packet_length         = 0x08;
20001480:	f04f 0308 	mov.w	r3, #8
20001484:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
                packet_iterations     = 0x0F;
20001488:	f04f 030f 	mov.w	r3, #15
2000148c:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
                RX_blaster_packet ( consumer_address, packet_length, 
20001490:	f8d7 0428 	ldr.w	r0, [r7, #1064]	; 0x428
20001494:	f8d7 1424 	ldr.w	r1, [r7, #1060]	; 0x424
20001498:	f8d7 242c 	ldr.w	r2, [r7, #1068]	; 0x42c
2000149c:	f001 f938 	bl	20002710 <RX_blaster_packet>
                                    packet_iterations );
                MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
200014a0:	f244 2094 	movw	r0, #17044	; 0x4294
200014a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200014a8:	f243 719c 	movw	r1, #14236	; 0x379c
200014ac:	f2c2 0100 	movt	r1, #8192	; 0x2000
200014b0:	f001 fa9a 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
200014b4:	463b      	mov	r3, r7
200014b6:	f244 2094 	movw	r0, #17044	; 0x4294
200014ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
200014be:	4619      	mov	r1, r3
200014c0:	f04f 020c 	mov.w	r2, #12
200014c4:	f001 fa1e 	bl	20002904 <MSS_UART_polled_tx>
                consumer_address      = 0x000002A9;
200014c8:	f240 23a9 	movw	r3, #681	; 0x2a9
200014cc:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
                *p_FPGA_high_addr_reg = 0x00000002;
200014d0:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
200014d4:	f04f 0202 	mov.w	r2, #2
200014d8:	601a      	str	r2, [r3, #0]
                *p_FPGA_low_addr_reg  = 0x000000A9;
200014da:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
200014de:	f04f 02a9 	mov.w	r2, #169	; 0xa9
200014e2:	601a      	str	r2, [r3, #0]
                break; 
200014e4:	e01f      	b.n	20001526 <main+0xb22>
              default:
              	MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r Press any number... \n\r\n\r" );
200014e6:	f244 2094 	movw	r0, #17044	; 0x4294
200014ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
200014ee:	f643 6138 	movw	r1, #15928	; 0x3e38
200014f2:	f2c2 0100 	movt	r1, #8192	; 0x2000
200014f6:	f001 fa77 	bl	200029e8 <MSS_UART_polled_tx_string>
            	  MSS_UART_polled_tx_string( &g_mss_uart0, (const uint8_t *)Menu);
200014fa:	f244 2094 	movw	r0, #17044	; 0x4294
200014fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001502:	f243 719c 	movw	r1, #14236	; 0x379c
20001506:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000150a:	f001 fa6d 	bl	200029e8 <MSS_UART_polled_tx_string>
                MSS_UART_polled_tx( &g_mss_uart0, greeting, sizeof(greeting) );
2000150e:	463b      	mov	r3, r7
20001510:	f244 2094 	movw	r0, #17044	; 0x4294
20001514:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001518:	4619      	mov	r1, r3
2000151a:	f04f 020c 	mov.w	r2, #12
2000151e:	f001 f9f1 	bl	20002904 <MSS_UART_polled_tx>
            	break;
          }
        }    
  }
20001522:	f7ff bba0 	b.w	20000c66 <main+0x262>
20001526:	f7ff bb9e 	b.w	20000c66 <main+0x262>
2000152a:	bf00      	nop

2000152c <print_registers>:
/*****************************************************************************
* This prototpye prints the FPGA registers and displays then on the console.
* (When I get the int to character function working)
******************************************************************************/
void print_registers()
{
2000152c:	b580      	push	{r7, lr}
2000152e:	b090      	sub	sp, #64	; 0x40
20001530:	af00      	add	r7, sp, #0
  uint8_t FPGA_address_high_reg;
  uint8_t FPGA_address_low_reg;

  char    UART_in_string [8];

  p_FPGA_revision_reg        = (uint32_t)COMMSFPGA_TOP_0;
20001532:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
20001536:	60fb      	str	r3, [r7, #12]
  p_FPGA_scratch_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x4;
20001538:	f240 0304 	movw	r3, #4
2000153c:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001540:	613b      	str	r3, [r7, #16]
  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
20001542:	f240 0310 	movw	r3, #16
20001546:	f2c5 0300 	movt	r3, #20480	; 0x5000
2000154a:	617b      	str	r3, [r7, #20]
  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
2000154c:	f240 0314 	movw	r3, #20
20001550:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001554:	61bb      	str	r3, [r7, #24]
  p_FPGA_interrupt_mask_reg  = (uint32_t)COMMSFPGA_TOP_0 + 0x18;
20001556:	f240 0318 	movw	r3, #24
2000155a:	f2c5 0300 	movt	r3, #20480	; 0x5000
2000155e:	61fb      	str	r3, [r7, #28]
  p_FPGA_status_reg          = (uint32_t)COMMSFPGA_TOP_0 + 0x1C;
20001560:	f240 031c 	movw	r3, #28
20001564:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001568:	623b      	str	r3, [r7, #32]
  p_FPGA_address_high_reg    = (uint32_t)COMMSFPGA_TOP_0 + 0x30;
2000156a:	f240 0330 	movw	r3, #48	; 0x30
2000156e:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001572:	62fb      	str	r3, [r7, #44]	; 0x2c
  p_FPGA_address_low_reg     = (uint32_t)COMMSFPGA_TOP_0 + 0x34;
20001574:	f240 0334 	movw	r3, #52	; 0x34
20001578:	f2c5 0300 	movt	r3, #20480	; 0x5000
2000157c:	633b      	str	r3, [r7, #48]	; 0x30

  MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r\n\r  FPGA Revision Register:       0x" );
2000157e:	f244 2094 	movw	r0, #17044	; 0x4294
20001582:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001586:	f643 6164 	movw	r1, #15972	; 0x3e64
2000158a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000158e:	f001 fa2b 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_revision_reg;
20001592:	68fb      	ldr	r3, [r7, #12]
20001594:	681b      	ldr	r3, [r3, #0]
20001596:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
20001598:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2000159a:	f107 0204 	add.w	r2, r7, #4
2000159e:	4610      	mov	r0, r2
200015a0:	4619      	mov	r1, r3
200015a2:	f000 fb51 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200015a6:	f107 0304 	add.w	r3, r7, #4
200015aa:	f244 2094 	movw	r0, #17044	; 0x4294
200015ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
200015b2:	4619      	mov	r1, r3
200015b4:	f04f 0208 	mov.w	r2, #8
200015b8:	f001 f9a4 	bl	20002904 <MSS_UART_polled_tx>
  //MSS_UART_polled_tx( &g_mss_uart0, p_FPGA_revision_reg, sizeof(p_FPGA_revision_reg) );

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Scratch Pad Register:    0x" );
200015bc:	f244 2094 	movw	r0, #17044	; 0x4294
200015c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200015c4:	f643 618c 	movw	r1, #16012	; 0x3e8c
200015c8:	f2c2 0100 	movt	r1, #8192	; 0x2000
200015cc:	f001 fa0c 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_scratch_reg;
200015d0:	693b      	ldr	r3, [r7, #16]
200015d2:	681b      	ldr	r3, [r3, #0]
200015d4:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
200015d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
200015d8:	f107 0204 	add.w	r2, r7, #4
200015dc:	4610      	mov	r0, r2
200015de:	4619      	mov	r1, r3
200015e0:	f000 fb32 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200015e4:	f107 0304 	add.w	r3, r7, #4
200015e8:	f244 2094 	movw	r0, #17044	; 0x4294
200015ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
200015f0:	4619      	mov	r1, r3
200015f2:	f04f 0208 	mov.w	r2, #8
200015f6:	f001 f985 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Control Register:        0x" );
200015fa:	f244 2094 	movw	r0, #17044	; 0x4294
200015fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001602:	f643 61b4 	movw	r1, #16052	; 0x3eb4
20001606:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000160a:	f001 f9ed 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_control_reg;
2000160e:	697b      	ldr	r3, [r7, #20]
20001610:	681b      	ldr	r3, [r3, #0]
20001612:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
20001614:	6b7b      	ldr	r3, [r7, #52]	; 0x34
20001616:	f107 0204 	add.w	r2, r7, #4
2000161a:	4610      	mov	r0, r2
2000161c:	4619      	mov	r1, r3
2000161e:	f000 fb13 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20001622:	f107 0304 	add.w	r3, r7, #4
20001626:	f244 2094 	movw	r0, #17044	; 0x4294
2000162a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000162e:	4619      	mov	r1, r3
20001630:	f04f 0208 	mov.w	r2, #8
20001634:	f001 f966 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Interrupt Register:      0x" );
20001638:	f244 2094 	movw	r0, #17044	; 0x4294
2000163c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001640:	f643 61dc 	movw	r1, #16092	; 0x3edc
20001644:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001648:	f001 f9ce 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_interrupt_reg;
2000164c:	69bb      	ldr	r3, [r7, #24]
2000164e:	681b      	ldr	r3, [r3, #0]
20001650:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
20001652:	6b7b      	ldr	r3, [r7, #52]	; 0x34
20001654:	f107 0204 	add.w	r2, r7, #4
20001658:	4610      	mov	r0, r2
2000165a:	4619      	mov	r1, r3
2000165c:	f000 faf4 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20001660:	f107 0304 	add.w	r3, r7, #4
20001664:	f244 2094 	movw	r0, #17044	; 0x4294
20001668:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000166c:	4619      	mov	r1, r3
2000166e:	f04f 0208 	mov.w	r2, #8
20001672:	f001 f947 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Interrupt Mask Register: 0x" );
20001676:	f244 2094 	movw	r0, #17044	; 0x4294
2000167a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000167e:	f643 7104 	movw	r1, #16132	; 0x3f04
20001682:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001686:	f001 f9af 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_interrupt_mask_reg;
2000168a:	69fb      	ldr	r3, [r7, #28]
2000168c:	681b      	ldr	r3, [r3, #0]
2000168e:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
20001690:	6b7b      	ldr	r3, [r7, #52]	; 0x34
20001692:	f107 0204 	add.w	r2, r7, #4
20001696:	4610      	mov	r0, r2
20001698:	4619      	mov	r1, r3
2000169a:	f000 fad5 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000169e:	f107 0304 	add.w	r3, r7, #4
200016a2:	f244 2094 	movw	r0, #17044	; 0x4294
200016a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200016aa:	4619      	mov	r1, r3
200016ac:	f04f 0208 	mov.w	r2, #8
200016b0:	f001 f928 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Status Register:         0x" );
200016b4:	f244 2094 	movw	r0, #17044	; 0x4294
200016b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200016bc:	f643 712c 	movw	r1, #16172	; 0x3f2c
200016c0:	f2c2 0100 	movt	r1, #8192	; 0x2000
200016c4:	f001 f990 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_status_reg;
200016c8:	6a3b      	ldr	r3, [r7, #32]
200016ca:	681b      	ldr	r3, [r3, #0]
200016cc:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
200016ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
200016d0:	f107 0204 	add.w	r2, r7, #4
200016d4:	4610      	mov	r0, r2
200016d6:	4619      	mov	r1, r3
200016d8:	f000 fab6 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200016dc:	f107 0304 	add.w	r3, r7, #4
200016e0:	f244 2094 	movw	r0, #17044	; 0x4294
200016e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200016e8:	4619      	mov	r1, r3
200016ea:	f04f 0208 	mov.w	r2, #8
200016ee:	f001 f909 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA High Address Register:   0x" );
200016f2:	f244 2094 	movw	r0, #17044	; 0x4294
200016f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200016fa:	f643 7154 	movw	r1, #16212	; 0x3f54
200016fe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001702:	f001 f971 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_address_high_reg;
20001706:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20001708:	681b      	ldr	r3, [r3, #0]
2000170a:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
2000170c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2000170e:	f107 0204 	add.w	r2, r7, #4
20001712:	4610      	mov	r0, r2
20001714:	4619      	mov	r1, r3
20001716:	f000 fa97 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000171a:	f107 0304 	add.w	r3, r7, #4
2000171e:	f244 2094 	movw	r0, #17044	; 0x4294
20001722:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001726:	4619      	mov	r1, r3
20001728:	f04f 0208 	mov.w	r2, #8
2000172c:	f001 f8ea 	bl	20002904 <MSS_UART_polled_tx>

  MSS_UART_polled_tx_string( &g_mss_uart0,     "\n\r  FPGA Low Address Register:    0x" );
20001730:	f244 2094 	movw	r0, #17044	; 0x4294
20001734:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001738:	f643 717c 	movw	r1, #16252	; 0x3f7c
2000173c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001740:	f001 f952 	bl	200029e8 <MSS_UART_polled_tx_string>
  reg_int = *p_FPGA_address_low_reg;
20001744:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20001746:	681b      	ldr	r3, [r3, #0]
20001748:	637b      	str	r3, [r7, #52]	; 0x34
  tohexstring(UART_in_string, reg_int);
2000174a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2000174c:	f107 0204 	add.w	r2, r7, #4
20001750:	4610      	mov	r0, r2
20001752:	4619      	mov	r1, r3
20001754:	f000 fa78 	bl	20001c48 <tohexstring>
  MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20001758:	f107 0304 	add.w	r3, r7, #4
2000175c:	f244 2094 	movw	r0, #17044	; 0x4294
20001760:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001764:	4619      	mov	r1, r3
20001766:	f04f 0208 	mov.w	r2, #8
2000176a:	f001 f8cb 	bl	20002904 <MSS_UART_polled_tx>

return;

}
2000176e:	f107 0740 	add.w	r7, r7, #64	; 0x40
20001772:	46bd      	mov	sp, r7
20001774:	bd80      	pop	{r7, pc}
20001776:	bf00      	nop

20001778 <fill_tx_message>:
  uint32_t length,
  uint32_t LoopType,   // LoopType = 1 then internal Loopback
                       // LoopType = 2 then external Loopback
  uint32_t TxBlaster       
)
{
20001778:	b580      	push	{r7, lr}
2000177a:	b098      	sub	sp, #96	; 0x60
2000177c:	af00      	add	r7, sp, #0
2000177e:	60f8      	str	r0, [r7, #12]
20001780:	60b9      	str	r1, [r7, #8]
20001782:	607a      	str	r2, [r7, #4]
20001784:	603b      	str	r3, [r7, #0]
  uint32_t data_count;

  uint32_t FPGA_int_read_data;
  uint32_t temp;
  
  p_FPGA_revision_reg        = (uint32_t)COMMSFPGA_TOP_0;
20001786:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
2000178a:	617b      	str	r3, [r7, #20]
  p_FPGA_scratch_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x4;
2000178c:	f240 0304 	movw	r3, #4
20001790:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001794:	61bb      	str	r3, [r7, #24]
  p_FPGA_tx_fifo_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x8;
20001796:	f240 0308 	movw	r3, #8
2000179a:	f2c5 0300 	movt	r3, #20480	; 0x5000
2000179e:	61fb      	str	r3, [r7, #28]
  p_FPGA_rx_fifo_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0xC;
200017a0:	f240 030c 	movw	r3, #12
200017a4:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017a8:	623b      	str	r3, [r7, #32]
  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
200017aa:	f240 0310 	movw	r3, #16
200017ae:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017b2:	627b      	str	r3, [r7, #36]	; 0x24
  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
200017b4:	f240 0314 	movw	r3, #20
200017b8:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017bc:	62bb      	str	r3, [r7, #40]	; 0x28
  p_FPGA_interrupt_mask_reg  = (uint32_t)COMMSFPGA_TOP_0 + 0x18;
200017be:	f240 0318 	movw	r3, #24
200017c2:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  p_FPGA_status_reg          = (uint32_t)COMMSFPGA_TOP_0 + 0x1C;
200017c8:	f240 031c 	movw	r3, #28
200017cc:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017d0:	633b      	str	r3, [r7, #48]	; 0x30
  p_FPGA_high_addr_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x30;
200017d2:	f240 0330 	movw	r3, #48	; 0x30
200017d6:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017da:	637b      	str	r3, [r7, #52]	; 0x34
  p_FPGA_low_addr_reg        = (uint32_t)COMMSFPGA_TOP_0 + 0x34;
200017dc:	f240 0334 	movw	r3, #52	; 0x34
200017e0:	f2c5 0300 	movt	r3, #20480	; 0x5000
200017e4:	63bb      	str	r3, [r7, #56]	; 0x38
  
  /* Clear Interrupts */
//  *p_FPGA_interrupt_reg = 0xFF;

  /* Correct length for header (4 bytes) and CRC (2 bytes) */
  length_minus6 = length - 6;
200017e6:	68bb      	ldr	r3, [r7, #8]
200017e8:	f1a3 0306 	sub.w	r3, r3, #6
200017ec:	63fb      	str	r3, [r7, #60]	; 0x3c
 // length_minus6 = length - 5;
  
  /* Put address in proper bits before placing into consumer length registers  */
  address_high2reg = address >> 8;
200017ee:	68fb      	ldr	r3, [r7, #12]
200017f0:	ea4f 2313 	mov.w	r3, r3, lsr #8
200017f4:	64bb      	str	r3, [r7, #72]	; 0x48
  address_low2reg  = address & 0x000000FF;
200017f6:	68fb      	ldr	r3, [r7, #12]
200017f8:	f003 03ff 	and.w	r3, r3, #255	; 0xff
200017fc:	64fb      	str	r3, [r7, #76]	; 0x4c
  
  *p_FPGA_high_addr_reg = address_high2reg; //0x00000002;
200017fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
20001800:	6cba      	ldr	r2, [r7, #72]	; 0x48
20001802:	601a      	str	r2, [r3, #0]
  *p_FPGA_low_addr_reg  = address_low2reg;  //0x000000A9;
20001804:	6bbb      	ldr	r3, [r7, #56]	; 0x38
20001806:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
20001808:	601a      	str	r2, [r3, #0]

  /* Create most significant bits of length to write to FIFO */
  length_shift = length >> 8;
2000180a:	68bb      	ldr	r3, [r7, #8]
2000180c:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001810:	653b      	str	r3, [r7, #80]	; 0x50

  /* Put address in proper bits before placing into tx fifo  */

  address_high2txfifo = address >> 2;
20001812:	68fb      	ldr	r3, [r7, #12]
20001814:	ea4f 0393 	mov.w	r3, r3, lsr #2
20001818:	643b      	str	r3, [r7, #64]	; 0x40
  address_low2txfifo  = address << 6;
2000181a:	68fb      	ldr	r3, [r7, #12]
2000181c:	ea4f 1383 	mov.w	r3, r3, lsl #6
20001820:	647b      	str	r3, [r7, #68]	; 0x44

  /* Load address/consumer into tx fifo */
  *p_FPGA_tx_fifo_reg = address_high2txfifo; /* Write high bits of address */
20001822:	69fb      	ldr	r3, [r7, #28]
20001824:	6c3a      	ldr	r2, [r7, #64]	; 0x40
20001826:	601a      	str	r2, [r3, #0]
  *p_FPGA_tx_fifo_reg = address_low2txfifo;  /* Write low bits of address  */
20001828:	69fb      	ldr	r3, [r7, #28]
2000182a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
2000182c:	601a      	str	r2, [r3, #0]

  *p_FPGA_tx_fifo_reg = length_shift;        /* Write MSB bits of length   */
2000182e:	69fb      	ldr	r3, [r7, #28]
20001830:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001832:	601a      	str	r2, [r3, #0]
  *p_FPGA_tx_fifo_reg = length;              /* Write LSB bits of length   */
20001834:	69fb      	ldr	r3, [r7, #28]
20001836:	68ba      	ldr	r2, [r7, #8]
20001838:	601a      	str	r2, [r3, #0]
  
  /* Load incrementing data pattern into tx fifo */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
2000183a:	f04f 0300 	mov.w	r3, #0
2000183e:	657b      	str	r3, [r7, #84]	; 0x54
20001840:	e006      	b.n	20001850 <fill_tx_message+0xd8>
      *p_FPGA_tx_fifo_reg = data_count;  
20001842:	69fb      	ldr	r3, [r7, #28]
20001844:	6d7a      	ldr	r2, [r7, #84]	; 0x54
20001846:	601a      	str	r2, [r3, #0]

  *p_FPGA_tx_fifo_reg = length_shift;        /* Write MSB bits of length   */
  *p_FPGA_tx_fifo_reg = length;              /* Write LSB bits of length   */
  
  /* Load incrementing data pattern into tx fifo */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20001848:	6d7b      	ldr	r3, [r7, #84]	; 0x54
2000184a:	f103 0301 	add.w	r3, r3, #1
2000184e:	657b      	str	r3, [r7, #84]	; 0x54
20001850:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
20001852:	f103 0201 	add.w	r2, r3, #1
20001856:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001858:	429a      	cmp	r2, r3
2000185a:	d8f2      	bhi.n	20001842 <fill_tx_message+0xca>
      *p_FPGA_tx_fifo_reg = data_count;  
  }
  
  /* Enable Control Register to Transmit Packet in Loop-back Mode */
  if ( LoopType == 1 ) {
2000185c:	687b      	ldr	r3, [r7, #4]
2000185e:	2b01      	cmp	r3, #1
20001860:	d104      	bne.n	2000186c <fill_tx_message+0xf4>
        *p_FPGA_control_reg = 0x00000030;   // internal loopback
20001862:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20001864:	f04f 0230 	mov.w	r2, #48	; 0x30
20001868:	601a      	str	r2, [r3, #0]
2000186a:	e00b      	b.n	20001884 <fill_tx_message+0x10c>
  }
  else if ( LoopType == 2 ) {
2000186c:	687b      	ldr	r3, [r7, #4]
2000186e:	2b02      	cmp	r3, #2
20001870:	d104      	bne.n	2000187c <fill_tx_message+0x104>
        *p_FPGA_control_reg = 0x00000022;   // external loopback
20001872:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20001874:	f04f 0222 	mov.w	r2, #34	; 0x22
20001878:	601a      	str	r2, [r3, #0]
2000187a:	e003      	b.n	20001884 <fill_tx_message+0x10c>
  } 
  else {
        *p_FPGA_control_reg = 0x00000020;   // No Loopback
2000187c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2000187e:	f04f 0220 	mov.w	r2, #32
20001882:	601a      	str	r2, [r3, #0]
  }

  /*
   * Poll for TX interrupt
   */
  FPGA_int_read_data = 0x00;
20001884:	f04f 0300 	mov.w	r3, #0
20001888:	65bb      	str	r3, [r7, #88]	; 0x58
  while ( (FPGA_int_read_data & 0xB1) == 0x00 ) {
2000188a:	e049      	b.n	20001920 <fill_tx_message+0x1a8>

  /*
   * Check for interrupt type
   */
  FPGA_int_read_data= *p_FPGA_interrupt_reg;
2000188c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000188e:	681b      	ldr	r3, [r3, #0]
20001890:	65bb      	str	r3, [r7, #88]	; 0x58

  // TX FIFO UNDERRUN
    if ( (FPGA_int_read_data & 0x20) > 0x00 )  {
20001892:	6dbb      	ldr	r3, [r7, #88]	; 0x58
20001894:	f003 0320 	and.w	r3, r3, #32
20001898:	2b00      	cmp	r3, #0
2000189a:	d00f      	beq.n	200018bc <fill_tx_message+0x144>
      *p_FPGA_interrupt_reg = 0x20; 
2000189c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000189e:	f04f 0220 	mov.w	r2, #32
200018a2:	601a      	str	r2, [r3, #0]
         MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  TX FIFO UNDERRUN INTERRUPT" );
200018a4:	f244 2094 	movw	r0, #17044	; 0x4294
200018a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200018ac:	f643 71a4 	movw	r1, #16292	; 0x3fa4
200018b0:	f2c2 0100 	movt	r1, #8192	; 0x2000
200018b4:	f001 f898 	bl	200029e8 <MSS_UART_polled_tx_string>
       tx_fifo_reset();
200018b8:	f000 f850 	bl	2000195c <tx_fifo_reset>
  }

  // TX FIFO OVERFLOW
    if ( (FPGA_int_read_data & 0x10) > 0x00 )  {
200018bc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
200018be:	f003 0310 	and.w	r3, r3, #16
200018c2:	2b00      	cmp	r3, #0
200018c4:	d00f      	beq.n	200018e6 <fill_tx_message+0x16e>
      *p_FPGA_interrupt_reg = 0x10; 
200018c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
200018c8:	f04f 0210 	mov.w	r2, #16
200018cc:	601a      	str	r2, [r3, #0]
       MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  TX FIFO OVERFLOW INTERRUPT" );
200018ce:	f244 2094 	movw	r0, #17044	; 0x4294
200018d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200018d6:	f643 71c4 	movw	r1, #16324	; 0x3fc4
200018da:	f2c2 0100 	movt	r1, #8192	; 0x2000
200018de:	f001 f883 	bl	200029e8 <MSS_UART_polled_tx_string>
       tx_fifo_reset();
200018e2:	f000 f83b 	bl	2000195c <tx_fifo_reset>
  }   
  
  // TX COLLISION DETECTED
    if ( (FPGA_int_read_data & 0x01) > 0x00 )  {
200018e6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
200018e8:	f003 0301 	and.w	r3, r3, #1
200018ec:	b2db      	uxtb	r3, r3
200018ee:	2b00      	cmp	r3, #0
200018f0:	d00d      	beq.n	2000190e <fill_tx_message+0x196>
        *p_FPGA_interrupt_reg = 0x01; 
200018f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
200018f4:	f04f 0201 	mov.w	r2, #1
200018f8:	601a      	str	r2, [r3, #0]
         MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  TX COLLISION INTERRUPT" );
200018fa:	f244 2094 	movw	r0, #17044	; 0x4294
200018fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001902:	f643 71e4 	movw	r1, #16356	; 0x3fe4
20001906:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000190a:	f001 f86d 	bl	200029e8 <MSS_UART_polled_tx_string>
    } 
  
    // TX PACKET AVAILABLE
    if ( (FPGA_int_read_data & 0x80) > 0x00 )  {
2000190e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
20001910:	f003 0380 	and.w	r3, r3, #128	; 0x80
20001914:	2b00      	cmp	r3, #0
20001916:	d003      	beq.n	20001920 <fill_tx_message+0x1a8>
        *p_FPGA_interrupt_reg = 0x80; 
20001918:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000191a:	f04f 0280 	mov.w	r2, #128	; 0x80
2000191e:	601a      	str	r2, [r3, #0]

  /*
   * Poll for TX interrupt
   */
  FPGA_int_read_data = 0x00;
  while ( (FPGA_int_read_data & 0xB1) == 0x00 ) {
20001920:	6dbb      	ldr	r3, [r7, #88]	; 0x58
20001922:	f003 03b1 	and.w	r3, r3, #177	; 0xb1
20001926:	2b00      	cmp	r3, #0
20001928:	d0b0      	beq.n	2000188c <fill_tx_message+0x114>
        *p_FPGA_interrupt_reg = 0x80; 
    }   

  }

  if (TxBlaster == 0 ) {
2000192a:	683b      	ldr	r3, [r7, #0]
2000192c:	2b00      	cmp	r3, #0
2000192e:	d111      	bne.n	20001954 <fill_tx_message+0x1dc>
    /* Delay Loop */
      for ( data_count = 0; data_count < 0x0003FFFF; data_count++ ) {
20001930:	f04f 0300 	mov.w	r3, #0
20001934:	657b      	str	r3, [r7, #84]	; 0x54
20001936:	e006      	b.n	20001946 <fill_tx_message+0x1ce>
    	temp = *p_FPGA_interrupt_reg; 
20001938:	6abb      	ldr	r3, [r7, #40]	; 0x28
2000193a:	681b      	ldr	r3, [r3, #0]
2000193c:	65fb      	str	r3, [r7, #92]	; 0x5c

  }

  if (TxBlaster == 0 ) {
    /* Delay Loop */
      for ( data_count = 0; data_count < 0x0003FFFF; data_count++ ) {
2000193e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001940:	f103 0301 	add.w	r3, r3, #1
20001944:	657b      	str	r3, [r7, #84]	; 0x54
20001946:	6d7a      	ldr	r2, [r7, #84]	; 0x54
20001948:	f64f 73fe 	movw	r3, #65534	; 0xfffe
2000194c:	f2c0 0303 	movt	r3, #3
20001950:	429a      	cmp	r2, r3
20001952:	d9f1      	bls.n	20001938 <fill_tx_message+0x1c0>
    }
  }
  
return;
             	
}
20001954:	f107 0760 	add.w	r7, r7, #96	; 0x60
20001958:	46bd      	mov	sp, r7
2000195a:	bd80      	pop	{r7, pc}

2000195c <tx_fifo_reset>:
*
*  INPUTS:      NONE
*
******************************************************************************/
void tx_fifo_reset()
{
2000195c:	b480      	push	{r7}
2000195e:	b085      	sub	sp, #20
20001960:	af00      	add	r7, sp, #0
  /* declare registers */

  /* other variable declarations */
  uint32_t data_count;

  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
20001962:	f240 0310 	movw	r3, #16
20001966:	f2c5 0300 	movt	r3, #20480	; 0x5000
2000196a:	607b      	str	r3, [r7, #4]

  /* Put TX FIFO into Reset */
  *p_FPGA_control_reg = 0x00000090;
2000196c:	687b      	ldr	r3, [r7, #4]
2000196e:	f04f 0290 	mov.w	r2, #144	; 0x90
20001972:	601a      	str	r2, [r3, #0]
  temp = *p_FPGA_control_reg;
20001974:	687b      	ldr	r3, [r7, #4]
20001976:	681b      	ldr	r3, [r3, #0]
20001978:	60bb      	str	r3, [r7, #8]

  /* Wait                   */
  for ( data_count = 0; data_count < 0x500; data_count++ ) {
2000197a:	f04f 0300 	mov.w	r3, #0
2000197e:	60fb      	str	r3, [r7, #12]
20001980:	e003      	b.n	2000198a <tx_fifo_reset+0x2e>
20001982:	68fb      	ldr	r3, [r7, #12]
20001984:	f103 0301 	add.w	r3, r3, #1
20001988:	60fb      	str	r3, [r7, #12]
2000198a:	68fa      	ldr	r2, [r7, #12]
2000198c:	f240 43ff 	movw	r3, #1279	; 0x4ff
20001990:	429a      	cmp	r2, r3
20001992:	d9f6      	bls.n	20001982 <tx_fifo_reset+0x26>

  }

  /* Take TX FIFO out of Reset */
  *p_FPGA_control_reg = 0x00000010;
20001994:	687b      	ldr	r3, [r7, #4]
20001996:	f04f 0210 	mov.w	r2, #16
2000199a:	601a      	str	r2, [r3, #0]

return;

}
2000199c:	f107 0714 	add.w	r7, r7, #20
200019a0:	46bd      	mov	sp, r7
200019a2:	bc80      	pop	{r7}
200019a4:	4770      	bx	lr
200019a6:	bf00      	nop

200019a8 <rx_fifo_reset>:
*
*  INPUTS:      NONE
*
******************************************************************************/
void rx_fifo_reset()
{
200019a8:	b480      	push	{r7}
200019aa:	b083      	sub	sp, #12
200019ac:	af00      	add	r7, sp, #0
  /* declare registers */

  /* other variable delarations */
  uint32_t data_count;

  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
200019ae:	f240 0310 	movw	r3, #16
200019b2:	f2c5 0300 	movt	r3, #20480	; 0x5000
200019b6:	603b      	str	r3, [r7, #0]

  /* Put TX FIFO into Reset */
  *p_FPGA_control_reg = 0x00000050;
200019b8:	683b      	ldr	r3, [r7, #0]
200019ba:	f04f 0250 	mov.w	r2, #80	; 0x50
200019be:	601a      	str	r2, [r3, #0]

  /* Wait                   */
  for ( data_count = 0; data_count < 0x200; data_count++ ) {
200019c0:	f04f 0300 	mov.w	r3, #0
200019c4:	607b      	str	r3, [r7, #4]
200019c6:	e003      	b.n	200019d0 <rx_fifo_reset+0x28>
200019c8:	687b      	ldr	r3, [r7, #4]
200019ca:	f103 0301 	add.w	r3, r3, #1
200019ce:	607b      	str	r3, [r7, #4]
200019d0:	687a      	ldr	r2, [r7, #4]
200019d2:	f240 13ff 	movw	r3, #511	; 0x1ff
200019d6:	429a      	cmp	r2, r3
200019d8:	d9f6      	bls.n	200019c8 <rx_fifo_reset+0x20>

  }

  /* Take TX FIFO out of Reset */
  *p_FPGA_control_reg = 0x00000010;
200019da:	683b      	ldr	r3, [r7, #0]
200019dc:	f04f 0210 	mov.w	r2, #16
200019e0:	601a      	str	r2, [r3, #0]

return;

}
200019e2:	f107 070c 	add.w	r7, r7, #12
200019e6:	46bd      	mov	sp, r7
200019e8:	bc80      	pop	{r7}
200019ea:	4770      	bx	lr

200019ec <SW_reset>:
*
*  INPUTS:      NONE
*
******************************************************************************/
void SW_reset()
{
200019ec:	b580      	push	{r7, lr}
200019ee:	b082      	sub	sp, #8
200019f0:	af00      	add	r7, sp, #0

  /* other variable declarations */
  uint32_t data_count;

  /* Put FPGA Into Reset */
  MSS_GPIO_set_outputs( MSS_GPIO_28_MASK );
200019f2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
200019f6:	f7fe fd7b 	bl	200004f0 <MSS_GPIO_set_outputs>

  /* Wait                   */
  for ( data_count = 0; data_count < 0x500; data_count++ ) {
200019fa:	f04f 0300 	mov.w	r3, #0
200019fe:	607b      	str	r3, [r7, #4]
20001a00:	e003      	b.n	20001a0a <SW_reset+0x1e>
20001a02:	687b      	ldr	r3, [r7, #4]
20001a04:	f103 0301 	add.w	r3, r3, #1
20001a08:	607b      	str	r3, [r7, #4]
20001a0a:	687a      	ldr	r2, [r7, #4]
20001a0c:	f240 43ff 	movw	r3, #1279	; 0x4ff
20001a10:	429a      	cmp	r2, r3
20001a12:	d9f6      	bls.n	20001a02 <SW_reset+0x16>

  }

  /* Take FPGA out of Reset */
  gpio_outputs = MSS_GPIO_get_outputs();
20001a14:	f7fe fd7c 	bl	20000510 <MSS_GPIO_get_outputs>
20001a18:	4603      	mov	r3, r0
20001a1a:	603b      	str	r3, [r7, #0]
  gpio_outputs &= ~( MSS_GPIO_28_MASK );
20001a1c:	683b      	ldr	r3, [r7, #0]
20001a1e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20001a22:	603b      	str	r3, [r7, #0]
  MSS_GPIO_set_outputs( gpio_outputs );
20001a24:	6838      	ldr	r0, [r7, #0]
20001a26:	f7fe fd63 	bl	200004f0 <MSS_GPIO_set_outputs>

return;

}
20001a2a:	f107 0708 	add.w	r7, r7, #8
20001a2e:	46bd      	mov	sp, r7
20001a30:	bd80      	pop	{r7, pc}
20001a32:	bf00      	nop

20001a34 <check_rx_message>:
(
  uint32_t address,
  uint32_t length,
  uint32_t supress
)
{
20001a34:	b590      	push	{r4, r7, lr}
20001a36:	b0a1      	sub	sp, #132	; 0x84
20001a38:	af00      	add	r7, sp, #0
20001a3a:	60f8      	str	r0, [r7, #12]
20001a3c:	60b9      	str	r1, [r7, #8]
20001a3e:	607a      	str	r2, [r7, #4]
  /* Delcare Constants */
  const uint8_t ERROR_RxFail[]        = "\n\r !!!!!! FAILED RX PACKET";
20001a40:	f244 035c 	movw	r3, #16476	; 0x405c
20001a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a48:	f107 0c28 	add.w	ip, r7, #40	; 0x28
20001a4c:	461c      	mov	r4, r3
20001a4e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
20001a50:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001a54:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
20001a58:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001a5c:	f8ac 2000 	strh.w	r2, [ip]
20001a60:	f10c 0c02 	add.w	ip, ip, #2
20001a64:	ea4f 4312 	mov.w	r3, r2, lsr #16
20001a68:	f88c 3000 	strb.w	r3, [ip]
  const uint8_t ERROR_RxPass[]        = "\n\r PASS RX PACKET";
20001a6c:	f244 0378 	movw	r3, #16504	; 0x4078
20001a70:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001a74:	f107 0c14 	add.w	ip, r7, #20
20001a78:	461c      	mov	r4, r3
20001a7a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
20001a7c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001a80:	6823      	ldr	r3, [r4, #0]
20001a82:	f8ac 3000 	strh.w	r3, [ip]
  uint32_t FPGA_int_read_data;
  uint32_t FPGA_stat_reg_data;

  uint32_t temp;

  p_FPGA_rx_fifo_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0xC;
20001a86:	f240 030c 	movw	r3, #12
20001a8a:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001a8e:	647b      	str	r3, [r7, #68]	; 0x44
  p_FPGA_status_reg          = (uint32_t)COMMSFPGA_TOP_0 + 0x1C;
20001a90:	f240 031c 	movw	r3, #28
20001a94:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001a98:	64bb      	str	r3, [r7, #72]	; 0x48
  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
20001a9a:	f240 0314 	movw	r3, #20
20001a9e:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001aa2:	64fb      	str	r3, [r7, #76]	; 0x4c
 
  /*
   * Correct length for header (4 bytes) and CRC (2 bytes)
   */
  length_minus6 = length - 6;
20001aa4:	68bb      	ldr	r3, [r7, #8]
20001aa6:	f1a3 0306 	sub.w	r3, r3, #6
20001aaa:	653b      	str	r3, [r7, #80]	; 0x50

  /*
   * Put address in proper bits before reading from rx fifo
   */
  address_high = address >> 2;
20001aac:	68fb      	ldr	r3, [r7, #12]
20001aae:	ea4f 0393 	mov.w	r3, r3, lsr #2
20001ab2:	657b      	str	r3, [r7, #84]	; 0x54
  address_low  = ( address << 6 ) & 0x000000FF;
20001ab4:	68fb      	ldr	r3, [r7, #12]
20001ab6:	ea4f 1383 	mov.w	r3, r3, lsl #6
20001aba:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001abe:	65bb      	str	r3, [r7, #88]	; 0x58

  /*
   * Create most significant bits of length
   */
  length_shift = length >> 8;
20001ac0:	68bb      	ldr	r3, [r7, #8]
20001ac2:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001ac6:	65fb      	str	r3, [r7, #92]	; 0x5c
  length_mask  = length & 0x000000FF;
20001ac8:	68bb      	ldr	r3, [r7, #8]
20001aca:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001ace:	663b      	str	r3, [r7, #96]	; 0x60

  /*
   * Poll Status Register for RX PACKET AVAILABLE or Error Condition
   */
  FPGA_stat_reg_data = 0x00;
20001ad0:	f04f 0300 	mov.w	r3, #0
20001ad4:	67bb      	str	r3, [r7, #120]	; 0x78
  FPGA_int_read_data = 0x00;
20001ad6:	f04f 0300 	mov.w	r3, #0
20001ada:	677b      	str	r3, [r7, #116]	; 0x74
    FPGA_stat_reg_data = *p_FPGA_status_reg    & 0x10;
    FPGA_int_read_data = *p_FPGA_interrupt_reg & 0x0E;
  }
   
    // RX FIFO UNDERRUN
    if ( (FPGA_int_read_data & 0x08) > 0x00 )  {
20001adc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
20001ade:	f003 0308 	and.w	r3, r3, #8
20001ae2:	2b00      	cmp	r3, #0
20001ae4:	d00d      	beq.n	20001b02 <check_rx_message+0xce>
        *p_FPGA_interrupt_reg = 0x08; 
20001ae6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001ae8:	f04f 0208 	mov.w	r2, #8
20001aec:	601a      	str	r2, [r3, #0]
         MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  RX FIFO UNDERRUN INTERRUPT" );
20001aee:	f244 2094 	movw	r0, #17044	; 0x4294
20001af2:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001af6:	f244 0100 	movw	r1, #16384	; 0x4000
20001afa:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001afe:	f000 ff73 	bl	200029e8 <MSS_UART_polled_tx_string>
    }  
     
    // RX FIFO OVERFLOW
    if ( (FPGA_int_read_data & 0x04) > 0x00 )  {
20001b02:	6f7b      	ldr	r3, [r7, #116]	; 0x74
20001b04:	f003 0304 	and.w	r3, r3, #4
20001b08:	2b00      	cmp	r3, #0
20001b0a:	d00d      	beq.n	20001b28 <check_rx_message+0xf4>
        *p_FPGA_interrupt_reg = 0x04; 
20001b0c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001b0e:	f04f 0204 	mov.w	r2, #4
20001b12:	601a      	str	r2, [r3, #0]
         MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  RX FIFO OVERFLOW INTERRUPT" );
20001b14:	f244 2094 	movw	r0, #17044	; 0x4294
20001b18:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001b1c:	f244 0120 	movw	r1, #16416	; 0x4020
20001b20:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001b24:	f000 ff60 	bl	200029e8 <MSS_UART_polled_tx_string>
    } 
     
    // RX CRC ERROR
    if ( (FPGA_int_read_data & 0x02) > 0x00 )  {
20001b28:	6f7b      	ldr	r3, [r7, #116]	; 0x74
20001b2a:	f003 0302 	and.w	r3, r3, #2
20001b2e:	2b00      	cmp	r3, #0
20001b30:	d00d      	beq.n	20001b4e <check_rx_message+0x11a>
        *p_FPGA_interrupt_reg = 0x02; 
20001b32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001b34:	f04f 0202 	mov.w	r2, #2
20001b38:	601a      	str	r2, [r3, #0]
         MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r  RX CRC ERROR INTERRUPT" );
20001b3a:	f244 2094 	movw	r0, #17044	; 0x4294
20001b3e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001b42:	f244 0140 	movw	r1, #16448	; 0x4040
20001b46:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001b4a:	f000 ff4d 	bl	200029e8 <MSS_UART_polled_tx_string>
    } 
    
    // Receive Packet Available
    if ( (FPGA_stat_reg_data & 0x10) > 0x00 )  {
20001b4e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
20001b50:	f003 0310 	and.w	r3, r3, #16
20001b54:	2b00      	cmp	r3, #0
20001b56:	d003      	beq.n	20001b60 <check_rx_message+0x12c>
        *p_FPGA_interrupt_reg = 0x40; 
20001b58:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001b5a:	f04f 0240 	mov.w	r2, #64	; 0x40
20001b5e:	601a      	str	r2, [r3, #0]
    }
  
  /*
   * Read first byte of rx FIFO  = high address/consumer and compare
   */
  data_fail = 0;
20001b60:	f04f 0300 	mov.w	r3, #0
20001b64:	66fb      	str	r3, [r7, #108]	; 0x6c

  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001b66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001b68:	681b      	ldr	r3, [r3, #0]
20001b6a:	673b      	str	r3, [r7, #112]	; 0x70
  
  if ( FPGA_rx_read_data != address_high ) {
20001b6c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
20001b6e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001b70:	429a      	cmp	r2, r3
20001b72:	d002      	beq.n	20001b7a <check_rx_message+0x146>
//    MSS_UART_polled_tx( &g_mss_uart0, ERROR_Consumer_High, sizeof(ERROR_Consumer_High) );
    data_fail = 1;
20001b74:	f04f 0301 	mov.w	r3, #1
20001b78:	66fb      	str	r3, [r7, #108]	; 0x6c
  }

  /*
   * Read second byte of rx FIFO = low address/consumer and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001b7a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001b7c:	681b      	ldr	r3, [r3, #0]
20001b7e:	673b      	str	r3, [r7, #112]	; 0x70
  if ( FPGA_rx_read_data != address_low ) {
20001b80:	6f3a      	ldr	r2, [r7, #112]	; 0x70
20001b82:	6dbb      	ldr	r3, [r7, #88]	; 0x58
20001b84:	429a      	cmp	r2, r3
20001b86:	d002      	beq.n	20001b8e <check_rx_message+0x15a>
 //   MSS_UART_polled_tx( &g_mss_uart0, ERROR_Consumer_Low, sizeof(ERROR_Consumer_Low) );
    data_fail = 1;
20001b88:	f04f 0301 	mov.w	r3, #1
20001b8c:	66fb      	str	r3, [r7, #108]	; 0x6c
  }

  /*
   * Read third byte of rx FIFO  = high length and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001b8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001b90:	681b      	ldr	r3, [r3, #0]
20001b92:	673b      	str	r3, [r7, #112]	; 0x70
  if ( FPGA_rx_read_data != length_shift ) {
20001b94:	6f3a      	ldr	r2, [r7, #112]	; 0x70
20001b96:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
20001b98:	429a      	cmp	r2, r3
20001b9a:	d002      	beq.n	20001ba2 <check_rx_message+0x16e>
//    MSS_UART_polled_tx( &g_mss_uart0, ERROR_Length_High, sizeof(ERROR_Length_High) );
    data_fail = 1;
20001b9c:	f04f 0301 	mov.w	r3, #1
20001ba0:	66fb      	str	r3, [r7, #108]	; 0x6c
 }

  /*
   * Read forth byte of rx FIFO  = low length and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001ba2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001ba4:	681b      	ldr	r3, [r3, #0]
20001ba6:	673b      	str	r3, [r7, #112]	; 0x70
  if ( FPGA_rx_read_data != length_mask ) {
20001ba8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
20001baa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
20001bac:	429a      	cmp	r2, r3
20001bae:	d002      	beq.n	20001bb6 <check_rx_message+0x182>
//    MSS_UART_polled_tx( &g_mss_uart0, ERROR_Length_Low, sizeof(ERROR_Length_Low) );
    data_fail = 1;
20001bb0:	f04f 0301 	mov.w	r3, #1
20001bb4:	66fb      	str	r3, [r7, #108]	; 0x6c
  }

  /*
   * Read remaining bytes of rx FIFO and compare
   */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20001bb6:	f04f 0300 	mov.w	r3, #0
20001bba:	667b      	str	r3, [r7, #100]	; 0x64
20001bbc:	e011      	b.n	20001be2 <check_rx_message+0x1ae>
         FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001bbe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001bc0:	681b      	ldr	r3, [r3, #0]
20001bc2:	673b      	str	r3, [r7, #112]	; 0x70
         data_count_masked = data_count & 0x000000FF;
20001bc4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001bc6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001bca:	66bb      	str	r3, [r7, #104]	; 0x68
      if ( FPGA_rx_read_data != data_count_masked ) {
20001bcc:	6f3a      	ldr	r2, [r7, #112]	; 0x70
20001bce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
20001bd0:	429a      	cmp	r2, r3
20001bd2:	d002      	beq.n	20001bda <check_rx_message+0x1a6>
//          MSS_UART_polled_tx( &g_mss_uart0, ERROR_Data, sizeof(ERROR_Data) );
          data_fail = 1;
20001bd4:	f04f 0301 	mov.w	r3, #1
20001bd8:	66fb      	str	r3, [r7, #108]	; 0x6c
  }

  /*
   * Read remaining bytes of rx FIFO and compare
   */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20001bda:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001bdc:	f103 0301 	add.w	r3, r3, #1
20001be0:	667b      	str	r3, [r7, #100]	; 0x64
20001be2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001be4:	f103 0201 	add.w	r2, r3, #1
20001be8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20001bea:	429a      	cmp	r2, r3
20001bec:	d8e7      	bhi.n	20001bbe <check_rx_message+0x18a>
  }

  /*
   * Read CRC bytes (qty 2) from FIFO
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001bee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001bf0:	681b      	ldr	r3, [r3, #0]
20001bf2:	673b      	str	r3, [r7, #112]	; 0x70
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001bf4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001bf6:	681b      	ldr	r3, [r3, #0]
20001bf8:	673b      	str	r3, [r7, #112]	; 0x70
   */
  
  /*
   * Print Message if Receive Packet Pass/Failed.
   */
  if ( data_fail == 1 ) {
20001bfa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
20001bfc:	2b01      	cmp	r3, #1
20001bfe:	d10d      	bne.n	20001c1c <check_rx_message+0x1e8>
      MSS_UART_polled_tx( &g_mss_uart0, ERROR_RxFail, sizeof(ERROR_RxFail) );
20001c00:	f107 0328 	add.w	r3, r7, #40	; 0x28
20001c04:	f244 2094 	movw	r0, #17044	; 0x4294
20001c08:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001c0c:	4619      	mov	r1, r3
20001c0e:	f04f 021b 	mov.w	r2, #27
20001c12:	f000 fe77 	bl	20002904 <MSS_UART_polled_tx>
      return(1);
20001c16:	f04f 0301 	mov.w	r3, #1
20001c1a:	e00f      	b.n	20001c3c <check_rx_message+0x208>
  }
  else {
      if (supress == 0) {
20001c1c:	687b      	ldr	r3, [r7, #4]
20001c1e:	2b00      	cmp	r3, #0
20001c20:	d10a      	bne.n	20001c38 <check_rx_message+0x204>
        MSS_UART_polled_tx( &g_mss_uart0, ERROR_RxPass, sizeof(ERROR_RxPass));
20001c22:	f107 0314 	add.w	r3, r7, #20
20001c26:	f244 2094 	movw	r0, #17044	; 0x4294
20001c2a:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001c2e:	4619      	mov	r1, r3
20001c30:	f04f 0212 	mov.w	r2, #18
20001c34:	f000 fe66 	bl	20002904 <MSS_UART_polled_tx>
      }
      return(0);
20001c38:	f04f 0300 	mov.w	r3, #0
  }

}
20001c3c:	4618      	mov	r0, r3
20001c3e:	f107 0784 	add.w	r7, r7, #132	; 0x84
20001c42:	46bd      	mov	sp, r7
20001c44:	bd90      	pop	{r4, r7, pc}
20001c46:	bf00      	nop

20001c48 <tohexstring>:
*  INPUTS:      str        = passes the sting buffer to this function.
*               num        = provides the integer number.
*
********************************************************************************/
void tohexstring(char str[], int num)
{
20001c48:	b480      	push	{r7}
20001c4a:	b087      	sub	sp, #28
20001c4c:	af00      	add	r7, sp, #0
20001c4e:	6078      	str	r0, [r7, #4]
20001c50:	6039      	str	r1, [r7, #0]
    uint32_t quotient;
    int i = 7, j = 0;
20001c52:	f04f 0307 	mov.w	r3, #7
20001c56:	60fb      	str	r3, [r7, #12]
20001c58:	f04f 0300 	mov.w	r3, #0
20001c5c:	613b      	str	r3, [r7, #16]
    uint8_t temp = 0;
20001c5e:	f04f 0300 	mov.w	r3, #0
20001c62:	75fb      	strb	r3, [r7, #23]

    quotient = num;
20001c64:	683b      	ldr	r3, [r7, #0]
20001c66:	60bb      	str	r3, [r7, #8]

    // clear string
    for (j = 0; j < 8; j++)
20001c68:	f04f 0300 	mov.w	r3, #0
20001c6c:	613b      	str	r3, [r7, #16]
20001c6e:	e009      	b.n	20001c84 <tohexstring+0x3c>
    {
        str[j] = '/0';
20001c70:	693a      	ldr	r2, [r7, #16]
20001c72:	687b      	ldr	r3, [r7, #4]
20001c74:	4413      	add	r3, r2
20001c76:	f04f 0230 	mov.w	r2, #48	; 0x30
20001c7a:	701a      	strb	r2, [r3, #0]
    uint8_t temp = 0;

    quotient = num;

    // clear string
    for (j = 0; j < 8; j++)
20001c7c:	693b      	ldr	r3, [r7, #16]
20001c7e:	f103 0301 	add.w	r3, r3, #1
20001c82:	613b      	str	r3, [r7, #16]
20001c84:	693b      	ldr	r3, [r7, #16]
20001c86:	2b07      	cmp	r3, #7
20001c88:	ddf2      	ble.n	20001c70 <tohexstring+0x28>
    {
        str[j] = '/0';
    }

    while(quotient!=0){
20001c8a:	e01d      	b.n	20001cc8 <tohexstring+0x80>
         temp = quotient % 16;
20001c8c:	68bb      	ldr	r3, [r7, #8]
20001c8e:	b2db      	uxtb	r3, r3
20001c90:	f003 030f 	and.w	r3, r3, #15
20001c94:	75fb      	strb	r3, [r7, #23]

      //To convert integer into character
      if( temp < 10)
20001c96:	7dfb      	ldrb	r3, [r7, #23]
20001c98:	2b09      	cmp	r3, #9
20001c9a:	d804      	bhi.n	20001ca6 <tohexstring+0x5e>
         temp = temp + 48;
20001c9c:	7dfb      	ldrb	r3, [r7, #23]
20001c9e:	f103 0330 	add.w	r3, r3, #48	; 0x30
20001ca2:	75fb      	strb	r3, [r7, #23]
20001ca4:	e003      	b.n	20001cae <tohexstring+0x66>
      else
         temp = temp + 55;
20001ca6:	7dfb      	ldrb	r3, [r7, #23]
20001ca8:	f103 0337 	add.w	r3, r3, #55	; 0x37
20001cac:	75fb      	strb	r3, [r7, #23]

      str[i] = (char)temp;
20001cae:	68fa      	ldr	r2, [r7, #12]
20001cb0:	687b      	ldr	r3, [r7, #4]
20001cb2:	4413      	add	r3, r2
20001cb4:	7dfa      	ldrb	r2, [r7, #23]
20001cb6:	701a      	strb	r2, [r3, #0]
      i--;
20001cb8:	68fb      	ldr	r3, [r7, #12]
20001cba:	f103 33ff 	add.w	r3, r3, #4294967295
20001cbe:	60fb      	str	r3, [r7, #12]
 //     MSS_UART_polled_tx( &g_mss_uart0, str_temp, sizeof(str_temp) );

      quotient = quotient / 16;
20001cc0:	68bb      	ldr	r3, [r7, #8]
20001cc2:	ea4f 1313 	mov.w	r3, r3, lsr #4
20001cc6:	60bb      	str	r3, [r7, #8]
    for (j = 0; j < 8; j++)
    {
        str[j] = '/0';
    }

    while(quotient!=0){
20001cc8:	68bb      	ldr	r3, [r7, #8]
20001cca:	2b00      	cmp	r3, #0
20001ccc:	d1de      	bne.n	20001c8c <tohexstring+0x44>
      i--;
 //     MSS_UART_polled_tx( &g_mss_uart0, str_temp, sizeof(str_temp) );

      quotient = quotient / 16;
  }
}
20001cce:	f107 071c 	add.w	r7, r7, #28
20001cd2:	46bd      	mov	sp, r7
20001cd4:	bc80      	pop	{r7}
20001cd6:	4770      	bx	lr

20001cd8 <packet_loopback>:
  uint32_t length,
  uint32_t iterations,
  uint32_t LoopType,
  uint32_t TxBlaster
)
{
20001cd8:	b580      	push	{r7, lr}
20001cda:	b088      	sub	sp, #32
20001cdc:	af00      	add	r7, sp, #0
20001cde:	60f8      	str	r0, [r7, #12]
20001ce0:	60b9      	str	r1, [r7, #8]
20001ce2:	607a      	str	r2, [r7, #4]
20001ce4:	603b      	str	r3, [r7, #0]
  /* declare variables */
  uint32_t iter;
  uint32_t packet_length;
  uint32_t NumFailures = 0;
20001ce6:	f04f 0300 	mov.w	r3, #0
20001cea:	61bb      	str	r3, [r7, #24]
  uint32_t check_rx_message_result;

  /* declare registers */

  iter = iterations;
20001cec:	687b      	ldr	r3, [r7, #4]
20001cee:	613b      	str	r3, [r7, #16]

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
20001cf0:	f04f 0300 	mov.w	r3, #0
20001cf4:	613b      	str	r3, [r7, #16]
20001cf6:	e01a      	b.n	20001d2e <packet_loopback+0x56>
    packet_length = length + iter;
20001cf8:	68ba      	ldr	r2, [r7, #8]
20001cfa:	693b      	ldr	r3, [r7, #16]
20001cfc:	4413      	add	r3, r2
20001cfe:	617b      	str	r3, [r7, #20]
    fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
20001d00:	68f8      	ldr	r0, [r7, #12]
20001d02:	6979      	ldr	r1, [r7, #20]
20001d04:	683a      	ldr	r2, [r7, #0]
20001d06:	6abb      	ldr	r3, [r7, #40]	; 0x28
20001d08:	f7ff fd36 	bl	20001778 <fill_tx_message>

    if ( check_rx_message ( address, packet_length, 1 ) == 1 )
20001d0c:	68f8      	ldr	r0, [r7, #12]
20001d0e:	6979      	ldr	r1, [r7, #20]
20001d10:	f04f 0201 	mov.w	r2, #1
20001d14:	f7ff fe8e 	bl	20001a34 <check_rx_message>
20001d18:	4603      	mov	r3, r0
20001d1a:	2b01      	cmp	r3, #1
20001d1c:	d103      	bne.n	20001d26 <packet_loopback+0x4e>
   	NumFailures++;
20001d1e:	69bb      	ldr	r3, [r7, #24]
20001d20:	f103 0301 	add.w	r3, r3, #1
20001d24:	61bb      	str	r3, [r7, #24]
  /* declare registers */

  iter = iterations;

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
20001d26:	693b      	ldr	r3, [r7, #16]
20001d28:	f103 0301 	add.w	r3, r3, #1
20001d2c:	613b      	str	r3, [r7, #16]
20001d2e:	693a      	ldr	r2, [r7, #16]
20001d30:	687b      	ldr	r3, [r7, #4]
20001d32:	429a      	cmp	r2, r3
20001d34:	d3e0      	bcc.n	20001cf8 <packet_loopback+0x20>

    if ( check_rx_message ( address, packet_length, 1 ) == 1 )
   	NumFailures++;
  }
  
  if ( NumFailures == 0 )
20001d36:	69bb      	ldr	r3, [r7, #24]
20001d38:	2b00      	cmp	r3, #0
20001d3a:	d109      	bne.n	20001d50 <packet_loopback+0x78>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r ALL PACKETS PASSED... \n\r" ); 
20001d3c:	f244 2094 	movw	r0, #17044	; 0x4294
20001d40:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001d44:	f244 018c 	movw	r1, #16524	; 0x408c
20001d48:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001d4c:	f000 fe4c 	bl	200029e8 <MSS_UART_polled_tx_string>

return;

}
20001d50:	f107 0720 	add.w	r7, r7, #32
20001d54:	46bd      	mov	sp, r7
20001d56:	bd80      	pop	{r7, pc}

20001d58 <b2b_single_tx_message_send>:
(
  uint32_t address,
  uint32_t length_temp,
  uint32_t TxBlaster
)
{
20001d58:	b480      	push	{r7}
20001d5a:	b095      	sub	sp, #84	; 0x54
20001d5c:	af00      	add	r7, sp, #0
20001d5e:	60f8      	str	r0, [r7, #12]
20001d60:	60b9      	str	r1, [r7, #8]
20001d62:	607a      	str	r2, [r7, #4]
  uint32_t data_count;

  uint32_t FPGA_int_read_data;
  uint32_t temp;
  
  p_FPGA_tx_fifo_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x8;
20001d64:	f240 0308 	movw	r3, #8
20001d68:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001d6c:	617b      	str	r3, [r7, #20]
  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
20001d6e:	f240 0310 	movw	r3, #16
20001d72:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001d76:	61bb      	str	r3, [r7, #24]
  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
20001d78:	f240 0314 	movw	r3, #20
20001d7c:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001d80:	61fb      	str	r3, [r7, #28]
  p_FPGA_high_addr_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x30;
20001d82:	f240 0330 	movw	r3, #48	; 0x30
20001d86:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001d8a:	623b      	str	r3, [r7, #32]
  p_FPGA_low_addr_reg        = (uint32_t)COMMSFPGA_TOP_0 + 0x34;
20001d8c:	f240 0334 	movw	r3, #52	; 0x34
20001d90:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001d94:	627b      	str	r3, [r7, #36]	; 0x24


// For test purposes
  uint32_t length;

  length = 0x5DC; 
20001d96:	f240 53dc 	movw	r3, #1500	; 0x5dc
20001d9a:	64fb      	str	r3, [r7, #76]	; 0x4c



  /* Clear Interrupts */
  *p_FPGA_interrupt_reg = 0xFF;
20001d9c:	69fb      	ldr	r3, [r7, #28]
20001d9e:	f04f 02ff 	mov.w	r2, #255	; 0xff
20001da2:	601a      	str	r2, [r3, #0]
    
  /* Correct length for header (4 bytes) and CRC (2 bytes) */
  length_minus6 = length - 6;
20001da4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001da6:	f1a3 0306 	sub.w	r3, r3, #6
20001daa:	62bb      	str	r3, [r7, #40]	; 0x28
  
  /* Put address in proper bits before placing into tx fifo
   * and consumer length registers  */
  address_high2reg = address >> 8;
20001dac:	68fb      	ldr	r3, [r7, #12]
20001dae:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001db2:	637b      	str	r3, [r7, #52]	; 0x34
  address_low2reg  = address & 0x000000FF;
20001db4:	68fb      	ldr	r3, [r7, #12]
20001db6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001dba:	63bb      	str	r3, [r7, #56]	; 0x38
  
  *p_FPGA_high_addr_reg = address_high2reg; //0x00000002;
20001dbc:	6a3b      	ldr	r3, [r7, #32]
20001dbe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
20001dc0:	601a      	str	r2, [r3, #0]
  *p_FPGA_low_addr_reg  = address_low2reg;  //0x000000A9;
20001dc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20001dc4:	6bba      	ldr	r2, [r7, #56]	; 0x38
20001dc6:	601a      	str	r2, [r3, #0]

  /* Create most significant bits of length to write to FIFO */
  length_shift = length >> 8;
20001dc8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001dca:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001dce:	63fb      	str	r3, [r7, #60]	; 0x3c

  /* Put address in proper bits before placing into tx fifo  */

  address_high2txfifo = address >> 2;
20001dd0:	68fb      	ldr	r3, [r7, #12]
20001dd2:	ea4f 0393 	mov.w	r3, r3, lsr #2
20001dd6:	62fb      	str	r3, [r7, #44]	; 0x2c
  address_low2txfifo  = address << 6;
20001dd8:	68fb      	ldr	r3, [r7, #12]
20001dda:	ea4f 1383 	mov.w	r3, r3, lsl #6
20001dde:	633b      	str	r3, [r7, #48]	; 0x30

  /* Load address/consumer into tx fifo */
  *p_FPGA_tx_fifo_reg = address_high2txfifo;     /* Write high bits of address */
20001de0:	697b      	ldr	r3, [r7, #20]
20001de2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
20001de4:	601a      	str	r2, [r3, #0]
  *p_FPGA_tx_fifo_reg = address_low2txfifo;      /* Write low bits of address  */
20001de6:	697b      	ldr	r3, [r7, #20]
20001de8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
20001dea:	601a      	str	r2, [r3, #0]

  *p_FPGA_tx_fifo_reg = length_shift;     /* Write MSB bits of length   */
20001dec:	697b      	ldr	r3, [r7, #20]
20001dee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
20001df0:	601a      	str	r2, [r3, #0]
  *p_FPGA_tx_fifo_reg = length;           /* Write LSB bits of length   */
20001df2:	697b      	ldr	r3, [r7, #20]
20001df4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
20001df6:	601a      	str	r2, [r3, #0]
  
  /* Load incrementing data pattern into tx fifo */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20001df8:	f04f 0300 	mov.w	r3, #0
20001dfc:	643b      	str	r3, [r7, #64]	; 0x40
20001dfe:	e006      	b.n	20001e0e <b2b_single_tx_message_send+0xb6>
      *p_FPGA_tx_fifo_reg = data_count;  
20001e00:	697b      	ldr	r3, [r7, #20]
20001e02:	6c3a      	ldr	r2, [r7, #64]	; 0x40
20001e04:	601a      	str	r2, [r3, #0]

  *p_FPGA_tx_fifo_reg = length_shift;     /* Write MSB bits of length   */
  *p_FPGA_tx_fifo_reg = length;           /* Write LSB bits of length   */
  
  /* Load incrementing data pattern into tx fifo */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20001e06:	6c3b      	ldr	r3, [r7, #64]	; 0x40
20001e08:	f103 0301 	add.w	r3, r3, #1
20001e0c:	643b      	str	r3, [r7, #64]	; 0x40
20001e0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
20001e10:	f103 0201 	add.w	r2, r3, #1
20001e14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
20001e16:	429a      	cmp	r2, r3
20001e18:	d8f2      	bhi.n	20001e00 <b2b_single_tx_message_send+0xa8>
      *p_FPGA_tx_fifo_reg = data_count;  
  }
  
  /* Enable Control Register to Transmit Packet */
  *p_FPGA_control_reg = 0x00000020;
20001e1a:	69bb      	ldr	r3, [r7, #24]
20001e1c:	f04f 0220 	mov.w	r2, #32
20001e20:	601a      	str	r2, [r3, #0]

  /*
   * Poll for TX complete
   */
  FPGA_int_read_data = 0x00;
20001e22:	f04f 0300 	mov.w	r3, #0
20001e26:	647b      	str	r3, [r7, #68]	; 0x44
  while ( FPGA_int_read_data == 0x00 ) {
20001e28:	e006      	b.n	20001e38 <b2b_single_tx_message_send+0xe0>
	  temp = *p_FPGA_interrupt_reg;
20001e2a:	69fb      	ldr	r3, [r7, #28]
20001e2c:	681b      	ldr	r3, [r3, #0]
20001e2e:	64bb      	str	r3, [r7, #72]	; 0x48
    FPGA_int_read_data = temp & 0x80;
20001e30:	6cbb      	ldr	r3, [r7, #72]	; 0x48
20001e32:	f003 0380 	and.w	r3, r3, #128	; 0x80
20001e36:	647b      	str	r3, [r7, #68]	; 0x44

  /*
   * Poll for TX complete
   */
  FPGA_int_read_data = 0x00;
  while ( FPGA_int_read_data == 0x00 ) {
20001e38:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001e3a:	2b00      	cmp	r3, #0
20001e3c:	d0f5      	beq.n	20001e2a <b2b_single_tx_message_send+0xd2>
    FPGA_int_read_data = temp & 0x80;
  }
  /*
  * Clear TX Complete Interrupt
  */
  *p_FPGA_interrupt_reg = 0x80;
20001e3e:	69fb      	ldr	r3, [r7, #28]
20001e40:	f04f 0280 	mov.w	r2, #128	; 0x80
20001e44:	601a      	str	r2, [r3, #0]
  
  if (TxBlaster == 0 ) {
20001e46:	687b      	ldr	r3, [r7, #4]
20001e48:	2b00      	cmp	r3, #0
20001e4a:	d111      	bne.n	20001e70 <b2b_single_tx_message_send+0x118>
    /* Delay Loop */
      for ( data_count = 0; data_count < 0x0003FFFF; data_count++ ) {
20001e4c:	f04f 0300 	mov.w	r3, #0
20001e50:	643b      	str	r3, [r7, #64]	; 0x40
20001e52:	e006      	b.n	20001e62 <b2b_single_tx_message_send+0x10a>
    	temp = *p_FPGA_interrupt_reg; 
20001e54:	69fb      	ldr	r3, [r7, #28]
20001e56:	681b      	ldr	r3, [r3, #0]
20001e58:	64bb      	str	r3, [r7, #72]	; 0x48
  */
  *p_FPGA_interrupt_reg = 0x80;
  
  if (TxBlaster == 0 ) {
    /* Delay Loop */
      for ( data_count = 0; data_count < 0x0003FFFF; data_count++ ) {
20001e5a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
20001e5c:	f103 0301 	add.w	r3, r3, #1
20001e60:	643b      	str	r3, [r7, #64]	; 0x40
20001e62:	6c3a      	ldr	r2, [r7, #64]	; 0x40
20001e64:	f64f 73fe 	movw	r3, #65534	; 0xfffe
20001e68:	f2c0 0303 	movt	r3, #3
20001e6c:	429a      	cmp	r2, r3
20001e6e:	d9f1      	bls.n	20001e54 <b2b_single_tx_message_send+0xfc>
    }
  }
  
return;
             	
}
20001e70:	f107 0754 	add.w	r7, r7, #84	; 0x54
20001e74:	46bd      	mov	sp, r7
20001e76:	bc80      	pop	{r7}
20001e78:	4770      	bx	lr
20001e7a:	bf00      	nop

20001e7c <b2b_single_rx_message_check>:
int b2b_single_rx_message_check
(
  uint32_t address,
  uint32_t length_temp
)
{
20001e7c:	b590      	push	{r4, r7, lr}
20001e7e:	b0a9      	sub	sp, #164	; 0xa4
20001e80:	af00      	add	r7, sp, #0
20001e82:	6078      	str	r0, [r7, #4]
20001e84:	6039      	str	r1, [r7, #0]
  /* Delcare Constants */
  const uint8_t ERROR_RxFail[]        = "\n\r !!!!!! FAILED RX PACKET";
20001e86:	f244 035c 	movw	r3, #16476	; 0x405c
20001e8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001e8e:	f107 0c28 	add.w	ip, r7, #40	; 0x28
20001e92:	461c      	mov	r4, r3
20001e94:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
20001e96:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001e9a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
20001e9e:	e8ac 0003 	stmia.w	ip!, {r0, r1}
20001ea2:	f8ac 2000 	strh.w	r2, [ip]
20001ea6:	f10c 0c02 	add.w	ip, ip, #2
20001eaa:	ea4f 4312 	mov.w	r3, r2, lsr #16
20001eae:	f88c 3000 	strb.w	r3, [ip]
  const uint8_t ERROR_RxPass[]        = "\n\r PASS RX PACKET";
20001eb2:	f244 0378 	movw	r3, #16504	; 0x4078
20001eb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20001eba:	f107 0c14 	add.w	ip, r7, #20
20001ebe:	461c      	mov	r4, r3
20001ec0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
20001ec2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
20001ec6:	6823      	ldr	r3, [r4, #0]
20001ec8:	f8ac 3000 	strh.w	r3, [ip]
  uint32_t x;
  uint32_t temp;
  uint32_t trigger;
  char     UART_in_string [8];

  p_FPGA_rx_fifo_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0xC;
20001ecc:	f240 030c 	movw	r3, #12
20001ed0:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001ed4:	647b      	str	r3, [r7, #68]	; 0x44
  p_FPGA_control_reg         = (uint32_t)COMMSFPGA_TOP_0 + 0x10;
20001ed6:	f240 0310 	movw	r3, #16
20001eda:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001ede:	64bb      	str	r3, [r7, #72]	; 0x48
  p_FPGA_interrupt_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x14;
20001ee0:	f240 0314 	movw	r3, #20
20001ee4:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001ee8:	64fb      	str	r3, [r7, #76]	; 0x4c
  p_FPGA_status_reg          = (uint32_t)COMMSFPGA_TOP_0 + 0x1C;
20001eea:	f240 031c 	movw	r3, #28
20001eee:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001ef2:	65bb      	str	r3, [r7, #88]	; 0x58
  p_FPGA_high_addr_reg       = (uint32_t)COMMSFPGA_TOP_0 + 0x30;
20001ef4:	f240 0330 	movw	r3, #48	; 0x30
20001ef8:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001efc:	653b      	str	r3, [r7, #80]	; 0x50
  p_FPGA_low_addr_reg        = (uint32_t)COMMSFPGA_TOP_0 + 0x34;
20001efe:	f240 0334 	movw	r3, #52	; 0x34
20001f02:	f2c5 0300 	movt	r3, #20480	; 0x5000
20001f06:	657b      	str	r3, [r7, #84]	; 0x54
// For test purposes

// For test purposes
  uint32_t length;

  length = 0x5DC; 
20001f08:	f240 53dc 	movw	r3, #1500	; 0x5dc
20001f0c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c



  /* Clear Interrupts */
  *p_FPGA_interrupt_reg = 0xFF;
20001f10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001f12:	f04f 02ff 	mov.w	r2, #255	; 0xff
20001f16:	601a      	str	r2, [r3, #0]
  
  /* Put address in proper bits before placing into consumer length registers  */
  address_high2reg = address >> 8;
20001f18:	687b      	ldr	r3, [r7, #4]
20001f1a:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001f1e:	66bb      	str	r3, [r7, #104]	; 0x68
  address_low2reg  = address & 0x000000FF;
20001f20:	687b      	ldr	r3, [r7, #4]
20001f22:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001f26:	66fb      	str	r3, [r7, #108]	; 0x6c
  
  *p_FPGA_high_addr_reg = address_high2reg;
20001f28:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001f2a:	6eba      	ldr	r2, [r7, #104]	; 0x68
20001f2c:	601a      	str	r2, [r3, #0]
  *p_FPGA_low_addr_reg  = address_low2reg;
20001f2e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001f30:	6efa      	ldr	r2, [r7, #108]	; 0x6c
20001f32:	601a      	str	r2, [r3, #0]
      
  /*
  Ensure internal Loopback is off
  */
  *p_FPGA_control_reg = 0x00000000;
20001f34:	6cbb      	ldr	r3, [r7, #72]	; 0x48
20001f36:	f04f 0200 	mov.w	r2, #0
20001f3a:	601a      	str	r2, [r3, #0]
  
  /*
   * Correct length for header (4 bytes) and CRC (2 bytes)
   */
  length_minus6 = length - 6;
20001f3c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
20001f40:	f1a3 0306 	sub.w	r3, r3, #6
20001f44:	65fb      	str	r3, [r7, #92]	; 0x5c

  /*
   * Put address in proper bits before reading from rx fifo
   */
  address_high = address >> 2;
20001f46:	687b      	ldr	r3, [r7, #4]
20001f48:	ea4f 0393 	mov.w	r3, r3, lsr #2
20001f4c:	663b      	str	r3, [r7, #96]	; 0x60
  address_low  = ( address << 6 ) & 0x000000FF;
20001f4e:	687b      	ldr	r3, [r7, #4]
20001f50:	ea4f 1383 	mov.w	r3, r3, lsl #6
20001f54:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001f58:	667b      	str	r3, [r7, #100]	; 0x64

  /*
   * Create most significant bits of length
   */
  length_shift = length >> 8;
20001f5a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
20001f5e:	ea4f 2313 	mov.w	r3, r3, lsr #8
20001f62:	673b      	str	r3, [r7, #112]	; 0x70
  length_mask  = length & 0x000000FF;
20001f64:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
20001f68:	f003 03ff 	and.w	r3, r3, #255	; 0xff
20001f6c:	677b      	str	r3, [r7, #116]	; 0x74
  
  /*
   * Poll Status Register for RX PACKET AVAILABLE
   */
  FPGA_stat_reg_data = 0x00;
20001f6e:	f04f 0300 	mov.w	r3, #0
20001f72:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  
  while ( (FPGA_stat_reg_data & 0x10) == 0x00 ) {
20001f76:	e005      	b.n	20001f84 <b2b_single_rx_message_check+0x108>
    FPGA_stat_reg_data = *p_FPGA_status_reg    & 0x10;
20001f78:	6dbb      	ldr	r3, [r7, #88]	; 0x58
20001f7a:	681b      	ldr	r3, [r3, #0]
20001f7c:	f003 0310 	and.w	r3, r3, #16
20001f80:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  /*
   * Poll Status Register for RX PACKET AVAILABLE
   */
  FPGA_stat_reg_data = 0x00;
  
  while ( (FPGA_stat_reg_data & 0x10) == 0x00 ) {
20001f84:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
20001f88:	f003 0310 	and.w	r3, r3, #16
20001f8c:	2b00      	cmp	r3, #0
20001f8e:	d0f3      	beq.n	20001f78 <b2b_single_rx_message_check+0xfc>
  }
  
  /*
  * Clear RX Complete Interrupt
  */
  *p_FPGA_interrupt_reg = 0x40;
20001f90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001f92:	f04f 0240 	mov.w	r2, #64	; 0x40
20001f96:	601a      	str	r2, [r3, #0]
  
  /*
   * Read first byte of rx FIFO  = high address/consumer and compare
   */
  data_fail = 0;
20001f98:	f04f 0300 	mov.w	r3, #0
20001f9c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20001fa0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20001fa2:	681b      	ldr	r3, [r3, #0]
20001fa4:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if ( FPGA_rx_read_data != address_high ) {
20001fa8:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
20001fac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
20001fae:	429a      	cmp	r2, r3
20001fb0:	d067      	beq.n	20002082 <b2b_single_rx_message_check+0x206>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r High Address Fail  " );
20001fb2:	f244 2094 	movw	r0, #17044	; 0x4294
20001fb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001fba:	f244 01a8 	movw	r1, #16552	; 0x40a8
20001fbe:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001fc2:	f000 fd11 	bl	200029e8 <MSS_UART_polled_tx_string>

  // Print Interrupt Status
    MSS_UART_polled_tx_string( &g_mss_uart0,     "  FPGA Interrupt Register:   0x" );
20001fc6:	f244 2094 	movw	r0, #17044	; 0x4294
20001fca:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001fce:	f244 01c0 	movw	r1, #16576	; 0x40c0
20001fd2:	f2c2 0100 	movt	r1, #8192	; 0x2000
20001fd6:	f000 fd07 	bl	200029e8 <MSS_UART_polled_tx_string>
    temp = *p_FPGA_interrupt_reg;
20001fda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20001fdc:	681b      	ldr	r3, [r3, #0]
20001fde:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tohexstring(UART_in_string, temp);
20001fe2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
20001fe6:	f107 020c 	add.w	r2, r7, #12
20001fea:	4610      	mov	r0, r2
20001fec:	4619      	mov	r1, r3
20001fee:	f7ff fe2b 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20001ff2:	f107 030c 	add.w	r3, r7, #12
20001ff6:	f244 2094 	movw	r0, #17044	; 0x4294
20001ffa:	f2c2 0000 	movt	r0, #8192	; 0x2000
20001ffe:	4619      	mov	r1, r3
20002000:	f04f 0208 	mov.w	r2, #8
20002004:	f000 fc7e 	bl	20002904 <MSS_UART_polled_tx>
    
  // Print Data Read and Expected
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Expected:   0x" );
20002008:	f244 2094 	movw	r0, #17044	; 0x4294
2000200c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002010:	f244 01e0 	movw	r1, #16608	; 0x40e0
20002014:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002018:	f000 fce6 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, address_high);
2000201c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
2000201e:	f107 020c 	add.w	r2, r7, #12
20002022:	4610      	mov	r0, r2
20002024:	4619      	mov	r1, r3
20002026:	f7ff fe0f 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000202a:	f107 030c 	add.w	r3, r7, #12
2000202e:	f244 2094 	movw	r0, #17044	; 0x4294
20002032:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002036:	4619      	mov	r1, r3
20002038:	f04f 0208 	mov.w	r2, #8
2000203c:	f000 fc62 	bl	20002904 <MSS_UART_polled_tx>
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Actual:   0x" );
20002040:	f244 2094 	movw	r0, #17044	; 0x4294
20002044:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002048:	f244 01f4 	movw	r1, #16628	; 0x40f4
2000204c:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002050:	f000 fcca 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, FPGA_rx_read_data);
20002054:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
20002058:	f107 020c 	add.w	r2, r7, #12
2000205c:	4610      	mov	r0, r2
2000205e:	4619      	mov	r1, r3
20002060:	f7ff fdf2 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20002064:	f107 030c 	add.w	r3, r7, #12
20002068:	f244 2094 	movw	r0, #17044	; 0x4294
2000206c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002070:	4619      	mov	r1, r3
20002072:	f04f 0208 	mov.w	r2, #8
20002076:	f000 fc45 	bl	20002904 <MSS_UART_polled_tx>
  
    data_fail = 1;
2000207a:	f04f 0301 	mov.w	r3, #1
2000207e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  }

  /*
   * Read second byte of rx FIFO = low address/consumer and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20002082:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002084:	681b      	ldr	r3, [r3, #0]
20002086:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if ( FPGA_rx_read_data != address_low ) {
2000208a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
2000208e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20002090:	429a      	cmp	r2, r3
20002092:	d067      	beq.n	20002164 <b2b_single_rx_message_check+0x2e8>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r Low Address Fail   " );
20002094:	f244 2094 	movw	r0, #17044	; 0x4294
20002098:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000209c:	f244 1108 	movw	r1, #16648	; 0x4108
200020a0:	f2c2 0100 	movt	r1, #8192	; 0x2000
200020a4:	f000 fca0 	bl	200029e8 <MSS_UART_polled_tx_string>

  // Print Interrupt Status
    MSS_UART_polled_tx_string( &g_mss_uart0,     "  FPGA Interrupt Register:   0x" );
200020a8:	f244 2094 	movw	r0, #17044	; 0x4294
200020ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
200020b0:	f244 01c0 	movw	r1, #16576	; 0x40c0
200020b4:	f2c2 0100 	movt	r1, #8192	; 0x2000
200020b8:	f000 fc96 	bl	200029e8 <MSS_UART_polled_tx_string>
    temp = *p_FPGA_interrupt_reg;
200020bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
200020be:	681b      	ldr	r3, [r3, #0]
200020c0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tohexstring(UART_in_string, temp);
200020c4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
200020c8:	f107 020c 	add.w	r2, r7, #12
200020cc:	4610      	mov	r0, r2
200020ce:	4619      	mov	r1, r3
200020d0:	f7ff fdba 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200020d4:	f107 030c 	add.w	r3, r7, #12
200020d8:	f244 2094 	movw	r0, #17044	; 0x4294
200020dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200020e0:	4619      	mov	r1, r3
200020e2:	f04f 0208 	mov.w	r2, #8
200020e6:	f000 fc0d 	bl	20002904 <MSS_UART_polled_tx>
    
  // Print Data Read and Expected
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Expected:   0x" );
200020ea:	f244 2094 	movw	r0, #17044	; 0x4294
200020ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
200020f2:	f244 01e0 	movw	r1, #16608	; 0x40e0
200020f6:	f2c2 0100 	movt	r1, #8192	; 0x2000
200020fa:	f000 fc75 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, address_low);
200020fe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
20002100:	f107 020c 	add.w	r2, r7, #12
20002104:	4610      	mov	r0, r2
20002106:	4619      	mov	r1, r3
20002108:	f7ff fd9e 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000210c:	f107 030c 	add.w	r3, r7, #12
20002110:	f244 2094 	movw	r0, #17044	; 0x4294
20002114:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002118:	4619      	mov	r1, r3
2000211a:	f04f 0208 	mov.w	r2, #8
2000211e:	f000 fbf1 	bl	20002904 <MSS_UART_polled_tx>
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Actual:   0x" );
20002122:	f244 2094 	movw	r0, #17044	; 0x4294
20002126:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000212a:	f244 01f4 	movw	r1, #16628	; 0x40f4
2000212e:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002132:	f000 fc59 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, FPGA_rx_read_data);
20002136:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
2000213a:	f107 020c 	add.w	r2, r7, #12
2000213e:	4610      	mov	r0, r2
20002140:	4619      	mov	r1, r3
20002142:	f7ff fd81 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20002146:	f107 030c 	add.w	r3, r7, #12
2000214a:	f244 2094 	movw	r0, #17044	; 0x4294
2000214e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002152:	4619      	mov	r1, r3
20002154:	f04f 0208 	mov.w	r2, #8
20002158:	f000 fbd4 	bl	20002904 <MSS_UART_polled_tx>
  
    data_fail = 1;
2000215c:	f04f 0301 	mov.w	r3, #1
20002160:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  }

  /*
   * Read third byte of rx FIFO  = high length and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20002164:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002166:	681b      	ldr	r3, [r3, #0]
20002168:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if ( FPGA_rx_read_data != length_shift ) {
2000216c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
20002170:	6f3b      	ldr	r3, [r7, #112]	; 0x70
20002172:	429a      	cmp	r2, r3
20002174:	d067      	beq.n	20002246 <b2b_single_rx_message_check+0x3ca>
	  MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r High Length Fail   " );
20002176:	f244 2094 	movw	r0, #17044	; 0x4294
2000217a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000217e:	f244 1120 	movw	r1, #16672	; 0x4120
20002182:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002186:	f000 fc2f 	bl	200029e8 <MSS_UART_polled_tx_string>

  // Print Interrupt Status
    MSS_UART_polled_tx_string( &g_mss_uart0,     "  FPGA Interrupt Register:   0x" );
2000218a:	f244 2094 	movw	r0, #17044	; 0x4294
2000218e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002192:	f244 01c0 	movw	r1, #16576	; 0x40c0
20002196:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000219a:	f000 fc25 	bl	200029e8 <MSS_UART_polled_tx_string>
    temp = *p_FPGA_interrupt_reg;
2000219e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
200021a0:	681b      	ldr	r3, [r3, #0]
200021a2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tohexstring(UART_in_string, temp);
200021a6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
200021aa:	f107 020c 	add.w	r2, r7, #12
200021ae:	4610      	mov	r0, r2
200021b0:	4619      	mov	r1, r3
200021b2:	f7ff fd49 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200021b6:	f107 030c 	add.w	r3, r7, #12
200021ba:	f244 2094 	movw	r0, #17044	; 0x4294
200021be:	f2c2 0000 	movt	r0, #8192	; 0x2000
200021c2:	4619      	mov	r1, r3
200021c4:	f04f 0208 	mov.w	r2, #8
200021c8:	f000 fb9c 	bl	20002904 <MSS_UART_polled_tx>
    
  // Print Data Read and Expected
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Expected:   0x" );
200021cc:	f244 2094 	movw	r0, #17044	; 0x4294
200021d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200021d4:	f244 01e0 	movw	r1, #16608	; 0x40e0
200021d8:	f2c2 0100 	movt	r1, #8192	; 0x2000
200021dc:	f000 fc04 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, length_shift);
200021e0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
200021e2:	f107 020c 	add.w	r2, r7, #12
200021e6:	4610      	mov	r0, r2
200021e8:	4619      	mov	r1, r3
200021ea:	f7ff fd2d 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200021ee:	f107 030c 	add.w	r3, r7, #12
200021f2:	f244 2094 	movw	r0, #17044	; 0x4294
200021f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
200021fa:	4619      	mov	r1, r3
200021fc:	f04f 0208 	mov.w	r2, #8
20002200:	f000 fb80 	bl	20002904 <MSS_UART_polled_tx>
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Actual:   0x" );
20002204:	f244 2094 	movw	r0, #17044	; 0x4294
20002208:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000220c:	f244 01f4 	movw	r1, #16628	; 0x40f4
20002210:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002214:	f000 fbe8 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, FPGA_rx_read_data);
20002218:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
2000221c:	f107 020c 	add.w	r2, r7, #12
20002220:	4610      	mov	r0, r2
20002222:	4619      	mov	r1, r3
20002224:	f7ff fd10 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20002228:	f107 030c 	add.w	r3, r7, #12
2000222c:	f244 2094 	movw	r0, #17044	; 0x4294
20002230:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002234:	4619      	mov	r1, r3
20002236:	f04f 0208 	mov.w	r2, #8
2000223a:	f000 fb63 	bl	20002904 <MSS_UART_polled_tx>
  
    data_fail = 1;
2000223e:	f04f 0301 	mov.w	r3, #1
20002242:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 }

  /*
   * Read forth byte of rx FIFO  = low length and compare
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20002246:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002248:	681b      	ldr	r3, [r3, #0]
2000224a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if ( FPGA_rx_read_data != length_mask ) {
2000224e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
20002252:	6f7b      	ldr	r3, [r7, #116]	; 0x74
20002254:	429a      	cmp	r2, r3
20002256:	d067      	beq.n	20002328 <b2b_single_rx_message_check+0x4ac>
	  MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r Low Length Fail    " );
20002258:	f244 2094 	movw	r0, #17044	; 0x4294
2000225c:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002260:	f244 1138 	movw	r1, #16696	; 0x4138
20002264:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002268:	f000 fbbe 	bl	200029e8 <MSS_UART_polled_tx_string>

  // Print Interrupt Status
    MSS_UART_polled_tx_string( &g_mss_uart0,     "  FPGA Interrupt Register:   0x" );
2000226c:	f244 2094 	movw	r0, #17044	; 0x4294
20002270:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002274:	f244 01c0 	movw	r1, #16576	; 0x40c0
20002278:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000227c:	f000 fbb4 	bl	200029e8 <MSS_UART_polled_tx_string>
    temp = *p_FPGA_interrupt_reg;
20002280:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20002282:	681b      	ldr	r3, [r3, #0]
20002284:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tohexstring(UART_in_string, temp);
20002288:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
2000228c:	f107 020c 	add.w	r2, r7, #12
20002290:	4610      	mov	r0, r2
20002292:	4619      	mov	r1, r3
20002294:	f7ff fcd8 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
20002298:	f107 030c 	add.w	r3, r7, #12
2000229c:	f244 2094 	movw	r0, #17044	; 0x4294
200022a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200022a4:	4619      	mov	r1, r3
200022a6:	f04f 0208 	mov.w	r2, #8
200022aa:	f000 fb2b 	bl	20002904 <MSS_UART_polled_tx>
    
  // Print Data Read and Expected
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Expected:   0x" );
200022ae:	f244 2094 	movw	r0, #17044	; 0x4294
200022b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
200022b6:	f244 01e0 	movw	r1, #16608	; 0x40e0
200022ba:	f2c2 0100 	movt	r1, #8192	; 0x2000
200022be:	f000 fb93 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, length_mask);
200022c2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
200022c4:	f107 020c 	add.w	r2, r7, #12
200022c8:	4610      	mov	r0, r2
200022ca:	4619      	mov	r1, r3
200022cc:	f7ff fcbc 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200022d0:	f107 030c 	add.w	r3, r7, #12
200022d4:	f244 2094 	movw	r0, #17044	; 0x4294
200022d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
200022dc:	4619      	mov	r1, r3
200022de:	f04f 0208 	mov.w	r2, #8
200022e2:	f000 fb0f 	bl	20002904 <MSS_UART_polled_tx>
    MSS_UART_polled_tx_string( &g_mss_uart0,     "    Actual:   0x" );
200022e6:	f244 2094 	movw	r0, #17044	; 0x4294
200022ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
200022ee:	f244 01f4 	movw	r1, #16628	; 0x40f4
200022f2:	f2c2 0100 	movt	r1, #8192	; 0x2000
200022f6:	f000 fb77 	bl	200029e8 <MSS_UART_polled_tx_string>
    tohexstring(UART_in_string, FPGA_rx_read_data);
200022fa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
200022fe:	f107 020c 	add.w	r2, r7, #12
20002302:	4610      	mov	r0, r2
20002304:	4619      	mov	r1, r3
20002306:	f7ff fc9f 	bl	20001c48 <tohexstring>
    MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000230a:	f107 030c 	add.w	r3, r7, #12
2000230e:	f244 2094 	movw	r0, #17044	; 0x4294
20002312:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002316:	4619      	mov	r1, r3
20002318:	f04f 0208 	mov.w	r2, #8
2000231c:	f000 faf2 	bl	20002904 <MSS_UART_polled_tx>
  
    data_fail = 1;
20002320:	f04f 0301 	mov.w	r3, #1
20002324:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  }

  /*
   * Read remaining bytes of rx FIFO and compare
   */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
20002328:	f04f 0300 	mov.w	r3, #0
2000232c:	67bb      	str	r3, [r7, #120]	; 0x78
2000232e:	e078      	b.n	20002422 <b2b_single_rx_message_check+0x5a6>
         FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20002330:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002332:	681b      	ldr	r3, [r3, #0]
20002334:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
         data_count_masked = data_count & 0x000000FF;
20002338:	6fbb      	ldr	r3, [r7, #120]	; 0x78
2000233a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
2000233e:	67fb      	str	r3, [r7, #124]	; 0x7c
      if ( FPGA_rx_read_data != data_count_masked ) {
20002340:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
20002344:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
20002346:	429a      	cmp	r2, r3
20002348:	d067      	beq.n	2000241a <b2b_single_rx_message_check+0x59e>
          MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r Data Fail          " );
2000234a:	f244 2094 	movw	r0, #17044	; 0x4294
2000234e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002352:	f244 1150 	movw	r1, #16720	; 0x4150
20002356:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000235a:	f000 fb45 	bl	200029e8 <MSS_UART_polled_tx_string>

        // Print Interrupt Status
          MSS_UART_polled_tx_string( &g_mss_uart0,     "  FPGA Interrupt Register:   0x" );
2000235e:	f244 2094 	movw	r0, #17044	; 0x4294
20002362:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002366:	f244 01c0 	movw	r1, #16576	; 0x40c0
2000236a:	f2c2 0100 	movt	r1, #8192	; 0x2000
2000236e:	f000 fb3b 	bl	200029e8 <MSS_UART_polled_tx_string>
          temp = *p_FPGA_interrupt_reg;
20002372:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
20002374:	681b      	ldr	r3, [r3, #0]
20002376:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
          tohexstring(UART_in_string, temp);
2000237a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
2000237e:	f107 020c 	add.w	r2, r7, #12
20002382:	4610      	mov	r0, r2
20002384:	4619      	mov	r1, r3
20002386:	f7ff fc5f 	bl	20001c48 <tohexstring>
          MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
2000238a:	f107 030c 	add.w	r3, r7, #12
2000238e:	f244 2094 	movw	r0, #17044	; 0x4294
20002392:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002396:	4619      	mov	r1, r3
20002398:	f04f 0208 	mov.w	r2, #8
2000239c:	f000 fab2 	bl	20002904 <MSS_UART_polled_tx>
          
        // Print Data Read and Expected
          MSS_UART_polled_tx_string( &g_mss_uart0,     "    Expected:   0x" );
200023a0:	f244 2094 	movw	r0, #17044	; 0x4294
200023a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
200023a8:	f244 01e0 	movw	r1, #16608	; 0x40e0
200023ac:	f2c2 0100 	movt	r1, #8192	; 0x2000
200023b0:	f000 fb1a 	bl	200029e8 <MSS_UART_polled_tx_string>
          tohexstring(UART_in_string, data_count_masked);
200023b4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
200023b6:	f107 020c 	add.w	r2, r7, #12
200023ba:	4610      	mov	r0, r2
200023bc:	4619      	mov	r1, r3
200023be:	f7ff fc43 	bl	20001c48 <tohexstring>
          MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200023c2:	f107 030c 	add.w	r3, r7, #12
200023c6:	f244 2094 	movw	r0, #17044	; 0x4294
200023ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
200023ce:	4619      	mov	r1, r3
200023d0:	f04f 0208 	mov.w	r2, #8
200023d4:	f000 fa96 	bl	20002904 <MSS_UART_polled_tx>
          MSS_UART_polled_tx_string( &g_mss_uart0,     "    Actual:   0x" );
200023d8:	f244 2094 	movw	r0, #17044	; 0x4294
200023dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
200023e0:	f244 01f4 	movw	r1, #16628	; 0x40f4
200023e4:	f2c2 0100 	movt	r1, #8192	; 0x2000
200023e8:	f000 fafe 	bl	200029e8 <MSS_UART_polled_tx_string>
          tohexstring(UART_in_string, FPGA_rx_read_data);
200023ec:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
200023f0:	f107 020c 	add.w	r2, r7, #12
200023f4:	4610      	mov	r0, r2
200023f6:	4619      	mov	r1, r3
200023f8:	f7ff fc26 	bl	20001c48 <tohexstring>
          MSS_UART_polled_tx( &g_mss_uart0, UART_in_string, sizeof(UART_in_string) );
200023fc:	f107 030c 	add.w	r3, r7, #12
20002400:	f244 2094 	movw	r0, #17044	; 0x4294
20002404:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002408:	4619      	mov	r1, r3
2000240a:	f04f 0208 	mov.w	r2, #8
2000240e:	f000 fa79 	bl	20002904 <MSS_UART_polled_tx>
  
          data_fail = 1;
20002412:	f04f 0301 	mov.w	r3, #1
20002416:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  }

  /*
   * Read remaining bytes of rx FIFO and compare
   */
  for ( data_count = 0; data_count < length_minus6 + 1; data_count++ ) {
2000241a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
2000241c:	f103 0301 	add.w	r3, r3, #1
20002420:	67bb      	str	r3, [r7, #120]	; 0x78
20002422:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
20002424:	f103 0201 	add.w	r2, r3, #1
20002428:	6fbb      	ldr	r3, [r7, #120]	; 0x78
2000242a:	429a      	cmp	r2, r3
2000242c:	d880      	bhi.n	20002330 <b2b_single_rx_message_check+0x4b4>
  }

  /*
   * Read CRC bytes (qty 2) from FIFO
   */
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
2000242e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002430:	681b      	ldr	r3, [r3, #0]
20002432:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  FPGA_rx_read_data = *p_FPGA_rx_fifo_reg;
20002436:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20002438:	681b      	ldr	r3, [r3, #0]
2000243a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

  /*
   * Print Message if Receive Packet Pass/Failed.
   */
  if ( data_fail == 1 ) {
2000243e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
20002442:	2b01      	cmp	r3, #1
20002444:	d10e      	bne.n	20002464 <b2b_single_rx_message_check+0x5e8>
      MSS_UART_polled_tx( &g_mss_uart0, ERROR_RxFail, sizeof(ERROR_RxFail) );
20002446:	f107 0328 	add.w	r3, r7, #40	; 0x28
2000244a:	f244 2094 	movw	r0, #17044	; 0x4294
2000244e:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002452:	4619      	mov	r1, r3
20002454:	f04f 021b 	mov.w	r2, #27
20002458:	f000 fa54 	bl	20002904 <MSS_UART_polled_tx>
      return(1);
2000245c:	f04f 0301 	mov.w	r3, #1
  }
//  else {
//      MSS_UART_polled_tx( &g_mss_uart0, ERROR_RxPass, sizeof(ERROR_RxPass) );
//      return(0);
//  }
}
20002460:	4618      	mov	r0, r3
20002462:	e7ff      	b.n	20002464 <b2b_single_rx_message_check+0x5e8>
20002464:	f107 07a4 	add.w	r7, r7, #164	; 0xa4
20002468:	46bd      	mov	sp, r7
2000246a:	bd90      	pop	{r4, r7, pc}

2000246c <b2b_multiple_tx_message_send>:
  uint32_t address,
  uint32_t length,
  uint32_t iterations,
  uint32_t TxBlaster
)
{
2000246c:	b580      	push	{r7, lr}
2000246e:	f5ad 6d85 	sub.w	sp, sp, #1064	; 0x428
20002472:	af00      	add	r7, sp, #0
20002474:	f107 0c18 	add.w	ip, r7, #24
20002478:	f1ac 0c0c 	sub.w	ip, ip, #12
2000247c:	f8cc 0000 	str.w	r0, [ip]
20002480:	f107 0008 	add.w	r0, r7, #8
20002484:	6001      	str	r1, [r0, #0]
20002486:	f107 0108 	add.w	r1, r7, #8
2000248a:	f1a1 0104 	sub.w	r1, r1, #4
2000248e:	600a      	str	r2, [r1, #0]
20002490:	463a      	mov	r2, r7
20002492:	6013      	str	r3, [r2, #0]
  /* declare variables */
  uint32_t iter;
  uint32_t packet_length;
  uint32_t NumFailures = 0;
20002494:	f04f 0300 	mov.w	r3, #0
20002498:	f8c7 341c 	str.w	r3, [r7, #1052]	; 0x41c
  // 022216
  uint8_t  uart0_rx_buff[1024];
  
  /* declare registers */

  iter = iterations;
2000249c:	f107 0308 	add.w	r3, r7, #8
200024a0:	f1a3 0304 	sub.w	r3, r3, #4
200024a4:	681b      	ldr	r3, [r3, #0]
200024a6:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414


  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
200024aa:	f04f 0300 	mov.w	r3, #0
200024ae:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
200024b2:	e018      	b.n	200024e6 <b2b_multiple_tx_message_send+0x7a>
    packet_length = length + iter;
200024b4:	f107 0308 	add.w	r3, r7, #8
200024b8:	681a      	ldr	r2, [r3, #0]
200024ba:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
200024be:	4413      	add	r3, r2
200024c0:	f8c7 3418 	str.w	r3, [r7, #1048]	; 0x418
    b2b_single_tx_message_send ( address, packet_length, TxBlaster );
200024c4:	f107 0318 	add.w	r3, r7, #24
200024c8:	f1a3 030c 	sub.w	r3, r3, #12
200024cc:	463a      	mov	r2, r7
200024ce:	6818      	ldr	r0, [r3, #0]
200024d0:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
200024d4:	6812      	ldr	r2, [r2, #0]
200024d6:	f7ff fc3f 	bl	20001d58 <b2b_single_tx_message_send>

  iter = iterations;


  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
200024da:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
200024de:	f103 0301 	add.w	r3, r3, #1
200024e2:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
200024e6:	f107 0308 	add.w	r3, r7, #8
200024ea:	f1a3 0304 	sub.w	r3, r3, #4
200024ee:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
200024f2:	681b      	ldr	r3, [r3, #0]
200024f4:	429a      	cmp	r2, r3
200024f6:	d3dd      	bcc.n	200024b4 <b2b_multiple_tx_message_send+0x48>
    b2b_single_tx_message_send ( address, packet_length, TxBlaster );
  }

return;

}
200024f8:	f107 0728 	add.w	r7, r7, #40	; 0x28
200024fc:	f507 6780 	add.w	r7, r7, #1024	; 0x400
20002500:	46bd      	mov	sp, r7
20002502:	bd80      	pop	{r7, pc}

20002504 <b2b_multiple_rx_message_check>:
(
  uint32_t address,
  uint32_t length,
  uint32_t iterations
)
{
20002504:	b580      	push	{r7, lr}
20002506:	b088      	sub	sp, #32
20002508:	af00      	add	r7, sp, #0
2000250a:	60f8      	str	r0, [r7, #12]
2000250c:	60b9      	str	r1, [r7, #8]
2000250e:	607a      	str	r2, [r7, #4]
  /* declare variables */
  uint32_t iter;
  uint32_t packet_length;
  uint32_t NumFailures = 0;
20002510:	f04f 0300 	mov.w	r3, #0
20002514:	61bb      	str	r3, [r7, #24]
  uint32_t check_rx_message_result;

  /* declare registers */

  iter = iterations;
20002516:	687b      	ldr	r3, [r7, #4]
20002518:	613b      	str	r3, [r7, #16]

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
2000251a:	f04f 0300 	mov.w	r3, #0
2000251e:	613b      	str	r3, [r7, #16]
20002520:	e012      	b.n	20002548 <b2b_multiple_rx_message_check+0x44>
	packet_length = length + iter;
20002522:	68ba      	ldr	r2, [r7, #8]
20002524:	693b      	ldr	r3, [r7, #16]
20002526:	4413      	add	r3, r2
20002528:	617b      	str	r3, [r7, #20]
    if ( b2b_single_rx_message_check ( address, packet_length ) == 1 )
2000252a:	68f8      	ldr	r0, [r7, #12]
2000252c:	6979      	ldr	r1, [r7, #20]
2000252e:	f7ff fca5 	bl	20001e7c <b2b_single_rx_message_check>
20002532:	4603      	mov	r3, r0
20002534:	2b01      	cmp	r3, #1
20002536:	d103      	bne.n	20002540 <b2b_multiple_rx_message_check+0x3c>
   	NumFailures++;
20002538:	69bb      	ldr	r3, [r7, #24]
2000253a:	f103 0301 	add.w	r3, r3, #1
2000253e:	61bb      	str	r3, [r7, #24]
  /* declare registers */

  iter = iterations;

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
20002540:	693b      	ldr	r3, [r7, #16]
20002542:	f103 0301 	add.w	r3, r3, #1
20002546:	613b      	str	r3, [r7, #16]
20002548:	693a      	ldr	r2, [r7, #16]
2000254a:	687b      	ldr	r3, [r7, #4]
2000254c:	429a      	cmp	r2, r3
2000254e:	d3e8      	bcc.n	20002522 <b2b_multiple_rx_message_check+0x1e>
	packet_length = length + iter;
    if ( b2b_single_rx_message_check ( address, packet_length ) == 1 )
   	NumFailures++;
  }

  if ( NumFailures == 0 )
20002550:	69bb      	ldr	r3, [r7, #24]
20002552:	2b00      	cmp	r3, #0
20002554:	d109      	bne.n	2000256a <b2b_multiple_rx_message_check+0x66>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r ALL PACKETS PASSED... \n\r" );
20002556:	f244 2094 	movw	r0, #17044	; 0x4294
2000255a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000255e:	f244 018c 	movw	r1, #16524	; 0x408c
20002562:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002566:	f000 fa3f 	bl	200029e8 <MSS_UART_polled_tx_string>

return;

}
2000256a:	f107 0720 	add.w	r7, r7, #32
2000256e:	46bd      	mov	sp, r7
20002570:	bd80      	pop	{r7, pc}
20002572:	bf00      	nop

20002574 <b2b_multiple_tx_message_blast>:
  uint32_t address,
  uint32_t length,
  uint32_t iterations,
  uint32_t TxBlaster
)
{
20002574:	b580      	push	{r7, lr}
20002576:	f5ad 6d85 	sub.w	sp, sp, #1064	; 0x428
2000257a:	af00      	add	r7, sp, #0
2000257c:	f107 0c18 	add.w	ip, r7, #24
20002580:	f1ac 0c0c 	sub.w	ip, ip, #12
20002584:	f8cc 0000 	str.w	r0, [ip]
20002588:	f107 0008 	add.w	r0, r7, #8
2000258c:	6001      	str	r1, [r0, #0]
2000258e:	f107 0108 	add.w	r1, r7, #8
20002592:	f1a1 0104 	sub.w	r1, r1, #4
20002596:	600a      	str	r2, [r1, #0]
20002598:	463a      	mov	r2, r7
2000259a:	6013      	str	r3, [r2, #0]
  /* declare variables */
  uint32_t iter;
  uint32_t packet_length;
  uint32_t NumFailures = 0;
2000259c:	f04f 0300 	mov.w	r3, #0
200025a0:	f8c7 341c 	str.w	r3, [r7, #1052]	; 0x41c
  // 022216
  uint8_t  uart0_rx_buff[1024];
  
  /* declare registers */

  iter = iterations;
200025a4:	f107 0308 	add.w	r3, r7, #8
200025a8:	f1a3 0304 	sub.w	r3, r3, #4
200025ac:	681b      	ldr	r3, [r3, #0]
200025ae:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414


  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
200025b2:	f04f 0300 	mov.w	r3, #0
200025b6:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
200025ba:	e014      	b.n	200025e6 <b2b_multiple_tx_message_blast+0x72>
    packet_length = 1020;
200025bc:	f44f 737f 	mov.w	r3, #1020	; 0x3fc
200025c0:	f8c7 3418 	str.w	r3, [r7, #1048]	; 0x418
    b2b_single_tx_message_send ( address, packet_length, TxBlaster );
200025c4:	f107 0318 	add.w	r3, r7, #24
200025c8:	f1a3 030c 	sub.w	r3, r3, #12
200025cc:	463a      	mov	r2, r7
200025ce:	6818      	ldr	r0, [r3, #0]
200025d0:	f8d7 1418 	ldr.w	r1, [r7, #1048]	; 0x418
200025d4:	6812      	ldr	r2, [r2, #0]
200025d6:	f7ff fbbf 	bl	20001d58 <b2b_single_tx_message_send>

  iter = iterations;


  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
200025da:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
200025de:	f103 0301 	add.w	r3, r3, #1
200025e2:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
200025e6:	f107 0308 	add.w	r3, r7, #8
200025ea:	f1a3 0304 	sub.w	r3, r3, #4
200025ee:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
200025f2:	681b      	ldr	r3, [r3, #0]
200025f4:	429a      	cmp	r2, r3
200025f6:	d3e1      	bcc.n	200025bc <b2b_multiple_tx_message_blast+0x48>
    b2b_single_tx_message_send ( address, packet_length, TxBlaster );
  }

return;

}
200025f8:	f107 0728 	add.w	r7, r7, #40	; 0x28
200025fc:	f507 6780 	add.w	r7, r7, #1024	; 0x400
20002600:	46bd      	mov	sp, r7
20002602:	bd80      	pop	{r7, pc}

20002604 <blaster_packet_loopback>:
  uint32_t length,
  uint32_t iterations,
  uint32_t LoopType,
  uint32_t TxBlaster
)
{
20002604:	b580      	push	{r7, lr}
20002606:	b08a      	sub	sp, #40	; 0x28
20002608:	af00      	add	r7, sp, #0
2000260a:	60f8      	str	r0, [r7, #12]
2000260c:	60b9      	str	r1, [r7, #8]
2000260e:	607a      	str	r2, [r7, #4]
20002610:	603b      	str	r3, [r7, #0]
  /* declare variables */
  uint32_t iter;
  uint32_t packet_length;
  uint32_t NumFailures = 0;
20002612:	f04f 0300 	mov.w	r3, #0
20002616:	61bb      	str	r3, [r7, #24]
  uint32_t check_rx_message_result;
  uint32_t packet_iter;
  uint32_t packet_iterations;

  /* declare registers */
  packet_iterations = 0x0000000F;
20002618:	f04f 030f 	mov.w	r3, #15
2000261c:	627b      	str	r3, [r7, #36]	; 0x24
  iter              = iterations;
2000261e:	687b      	ldr	r3, [r7, #4]
20002620:	613b      	str	r3, [r7, #16]

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
20002622:	f04f 0300 	mov.w	r3, #0
20002626:	613b      	str	r3, [r7, #16]
20002628:	e039      	b.n	2000269e <blaster_packet_loopback+0x9a>
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
2000262a:	f04f 0300 	mov.w	r3, #0
2000262e:	623b      	str	r3, [r7, #32]
20002630:	e00d      	b.n	2000264e <blaster_packet_loopback+0x4a>
      packet_length = length + packet_iter;
20002632:	68ba      	ldr	r2, [r7, #8]
20002634:	6a3b      	ldr	r3, [r7, #32]
20002636:	4413      	add	r3, r2
20002638:	617b      	str	r3, [r7, #20]
      fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
2000263a:	68f8      	ldr	r0, [r7, #12]
2000263c:	6979      	ldr	r1, [r7, #20]
2000263e:	683a      	ldr	r2, [r7, #0]
20002640:	6b3b      	ldr	r3, [r7, #48]	; 0x30
20002642:	f7ff f899 	bl	20001778 <fill_tx_message>
  packet_iterations = 0x0000000F;
  iter              = iterations;

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
20002646:	6a3b      	ldr	r3, [r7, #32]
20002648:	f103 0301 	add.w	r3, r3, #1
2000264c:	623b      	str	r3, [r7, #32]
2000264e:	6a3a      	ldr	r2, [r7, #32]
20002650:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20002652:	429a      	cmp	r2, r3
20002654:	d3ed      	bcc.n	20002632 <blaster_packet_loopback+0x2e>
      packet_length = length + packet_iter;
      fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
    }
    
    packet_iterations = 0x0000000F;
20002656:	f04f 030f 	mov.w	r3, #15
2000265a:	627b      	str	r3, [r7, #36]	; 0x24
    
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
2000265c:	f04f 0300 	mov.w	r3, #0
20002660:	623b      	str	r3, [r7, #32]
20002662:	e014      	b.n	2000268e <blaster_packet_loopback+0x8a>
      packet_length = length + packet_iter;
20002664:	68ba      	ldr	r2, [r7, #8]
20002666:	6a3b      	ldr	r3, [r7, #32]
20002668:	4413      	add	r3, r2
2000266a:	617b      	str	r3, [r7, #20]
      if ( check_rx_message ( address, packet_length, 1 ) == 1 )
2000266c:	68f8      	ldr	r0, [r7, #12]
2000266e:	6979      	ldr	r1, [r7, #20]
20002670:	f04f 0201 	mov.w	r2, #1
20002674:	f7ff f9de 	bl	20001a34 <check_rx_message>
20002678:	4603      	mov	r3, r0
2000267a:	2b01      	cmp	r3, #1
2000267c:	d103      	bne.n	20002686 <blaster_packet_loopback+0x82>
   	  NumFailures++;
2000267e:	69bb      	ldr	r3, [r7, #24]
20002680:	f103 0301 	add.w	r3, r3, #1
20002684:	61bb      	str	r3, [r7, #24]
      fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
    }
    
    packet_iterations = 0x0000000F;
    
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
20002686:	6a3b      	ldr	r3, [r7, #32]
20002688:	f103 0301 	add.w	r3, r3, #1
2000268c:	623b      	str	r3, [r7, #32]
2000268e:	6a3a      	ldr	r2, [r7, #32]
20002690:	6a7b      	ldr	r3, [r7, #36]	; 0x24
20002692:	429a      	cmp	r2, r3
20002694:	d3e6      	bcc.n	20002664 <blaster_packet_loopback+0x60>
  /* declare registers */
  packet_iterations = 0x0000000F;
  iter              = iterations;

  /* loopback packet with varing sizes */
  for ( iter = 0; iter < iterations; iter++ ) {
20002696:	693b      	ldr	r3, [r7, #16]
20002698:	f103 0301 	add.w	r3, r3, #1
2000269c:	613b      	str	r3, [r7, #16]
2000269e:	693a      	ldr	r2, [r7, #16]
200026a0:	687b      	ldr	r3, [r7, #4]
200026a2:	429a      	cmp	r2, r3
200026a4:	d3c1      	bcc.n	2000262a <blaster_packet_loopback+0x26>
      if ( check_rx_message ( address, packet_length, 1 ) == 1 )
   	  NumFailures++;
   	}
  }
  
  if ( NumFailures == 0 )
200026a6:	69bb      	ldr	r3, [r7, #24]
200026a8:	2b00      	cmp	r3, #0
200026aa:	d109      	bne.n	200026c0 <blaster_packet_loopback+0xbc>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r ALL PACKETS PASSED... \n\r" ); 
200026ac:	f244 2094 	movw	r0, #17044	; 0x4294
200026b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
200026b4:	f244 018c 	movw	r1, #16524	; 0x408c
200026b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
200026bc:	f000 f994 	bl	200029e8 <MSS_UART_polled_tx_string>

return;

}
200026c0:	f107 0728 	add.w	r7, r7, #40	; 0x28
200026c4:	46bd      	mov	sp, r7
200026c6:	bd80      	pop	{r7, pc}

200026c8 <TX_blaster_packet>:
  uint32_t length,
  uint32_t iterations,
  uint32_t LoopType,
  uint32_t TxBlaster
)
{
200026c8:	b580      	push	{r7, lr}
200026ca:	b088      	sub	sp, #32
200026cc:	af00      	add	r7, sp, #0
200026ce:	60f8      	str	r0, [r7, #12]
200026d0:	60b9      	str	r1, [r7, #8]
200026d2:	607a      	str	r2, [r7, #4]
200026d4:	603b      	str	r3, [r7, #0]
  uint32_t packet_length;
  uint32_t packet_iter;
  uint32_t packet_iterations;

  /* declare registers */
  packet_iterations = iterations;
200026d6:	687b      	ldr	r3, [r7, #4]
200026d8:	61fb      	str	r3, [r7, #28]

  /* loopback packet with varing sizes */
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
200026da:	f04f 0300 	mov.w	r3, #0
200026de:	61bb      	str	r3, [r7, #24]
200026e0:	e00d      	b.n	200026fe <TX_blaster_packet+0x36>
      packet_length = length + packet_iter;
200026e2:	68ba      	ldr	r2, [r7, #8]
200026e4:	69bb      	ldr	r3, [r7, #24]
200026e6:	4413      	add	r3, r2
200026e8:	617b      	str	r3, [r7, #20]
      fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
200026ea:	68f8      	ldr	r0, [r7, #12]
200026ec:	6979      	ldr	r1, [r7, #20]
200026ee:	683a      	ldr	r2, [r7, #0]
200026f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
200026f2:	f7ff f841 	bl	20001778 <fill_tx_message>

  /* declare registers */
  packet_iterations = iterations;

  /* loopback packet with varing sizes */
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
200026f6:	69bb      	ldr	r3, [r7, #24]
200026f8:	f103 0301 	add.w	r3, r3, #1
200026fc:	61bb      	str	r3, [r7, #24]
200026fe:	69ba      	ldr	r2, [r7, #24]
20002700:	69fb      	ldr	r3, [r7, #28]
20002702:	429a      	cmp	r2, r3
20002704:	d3ed      	bcc.n	200026e2 <TX_blaster_packet+0x1a>
      fill_tx_message  ( address, packet_length, LoopType, TxBlaster );
    }
  
return;

}
20002706:	f107 0720 	add.w	r7, r7, #32
2000270a:	46bd      	mov	sp, r7
2000270c:	bd80      	pop	{r7, pc}
2000270e:	bf00      	nop

20002710 <RX_blaster_packet>:
(
  uint32_t address,
  uint32_t length,
  uint32_t iterations
)
{
20002710:	b580      	push	{r7, lr}
20002712:	b088      	sub	sp, #32
20002714:	af00      	add	r7, sp, #0
20002716:	60f8      	str	r0, [r7, #12]
20002718:	60b9      	str	r1, [r7, #8]
2000271a:	607a      	str	r2, [r7, #4]
  /* declare variables */
  uint32_t packet_length;
  uint32_t NumFailures = 0;
2000271c:	f04f 0300 	mov.w	r3, #0
20002720:	617b      	str	r3, [r7, #20]
  uint32_t packet_iter;
  uint32_t packet_iterations;

  /* declare registers */
  packet_iterations = iterations;
20002722:	687b      	ldr	r3, [r7, #4]
20002724:	61fb      	str	r3, [r7, #28]
    
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
20002726:	f04f 0300 	mov.w	r3, #0
2000272a:	61bb      	str	r3, [r7, #24]
2000272c:	e014      	b.n	20002758 <RX_blaster_packet+0x48>
      packet_length = length + packet_iter;
2000272e:	68ba      	ldr	r2, [r7, #8]
20002730:	69bb      	ldr	r3, [r7, #24]
20002732:	4413      	add	r3, r2
20002734:	613b      	str	r3, [r7, #16]
      if ( check_rx_message ( address, packet_length, 0 ) == 1 )
20002736:	68f8      	ldr	r0, [r7, #12]
20002738:	6939      	ldr	r1, [r7, #16]
2000273a:	f04f 0200 	mov.w	r2, #0
2000273e:	f7ff f979 	bl	20001a34 <check_rx_message>
20002742:	4603      	mov	r3, r0
20002744:	2b01      	cmp	r3, #1
20002746:	d103      	bne.n	20002750 <RX_blaster_packet+0x40>
   	  NumFailures++;
20002748:	697b      	ldr	r3, [r7, #20]
2000274a:	f103 0301 	add.w	r3, r3, #1
2000274e:	617b      	str	r3, [r7, #20]
  uint32_t packet_iterations;

  /* declare registers */
  packet_iterations = iterations;
    
    for ( packet_iter = 0; packet_iter < packet_iterations; packet_iter++ ) {
20002750:	69bb      	ldr	r3, [r7, #24]
20002752:	f103 0301 	add.w	r3, r3, #1
20002756:	61bb      	str	r3, [r7, #24]
20002758:	69ba      	ldr	r2, [r7, #24]
2000275a:	69fb      	ldr	r3, [r7, #28]
2000275c:	429a      	cmp	r2, r3
2000275e:	d3e6      	bcc.n	2000272e <RX_blaster_packet+0x1e>
      packet_length = length + packet_iter;
      if ( check_rx_message ( address, packet_length, 0 ) == 1 )
   	  NumFailures++;
   	}
  
  if ( NumFailures == 0 )
20002760:	697b      	ldr	r3, [r7, #20]
20002762:	2b00      	cmp	r3, #0
20002764:	d109      	bne.n	2000277a <RX_blaster_packet+0x6a>
    MSS_UART_polled_tx_string( &g_mss_uart0, "\n\r ALL PACKETS PASSED... \n\r" ); 
20002766:	f244 2094 	movw	r0, #17044	; 0x4294
2000276a:	f2c2 0000 	movt	r0, #8192	; 0x2000
2000276e:	f244 018c 	movw	r1, #16524	; 0x408c
20002772:	f2c2 0100 	movt	r1, #8192	; 0x2000
20002776:	f000 f937 	bl	200029e8 <MSS_UART_polled_tx_string>

return;

}
2000277a:	f107 0720 	add.w	r7, r7, #32
2000277e:	46bd      	mov	sp, r7
20002780:	bd80      	pop	{r7, pc}
20002782:	bf00      	nop

20002784 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20002784:	b480      	push	{r7}
20002786:	b083      	sub	sp, #12
20002788:	af00      	add	r7, sp, #0
2000278a:	4603      	mov	r3, r0
2000278c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
2000278e:	f24e 1300 	movw	r3, #57600	; 0xe100
20002792:	f2ce 0300 	movt	r3, #57344	; 0xe000
20002796:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000279a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000279e:	79f9      	ldrb	r1, [r7, #7]
200027a0:	f001 011f 	and.w	r1, r1, #31
200027a4:	f04f 0001 	mov.w	r0, #1
200027a8:	fa00 f101 	lsl.w	r1, r0, r1
200027ac:	f102 0260 	add.w	r2, r2, #96	; 0x60
200027b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
200027b4:	f107 070c 	add.w	r7, r7, #12
200027b8:	46bd      	mov	sp, r7
200027ba:	bc80      	pop	{r7}
200027bc:	4770      	bx	lr
200027be:	bf00      	nop

200027c0 <set_bit_reg8>:
static __INLINE void set_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x1;
}
static __INLINE void set_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
200027c0:	b480      	push	{r7}
200027c2:	b083      	sub	sp, #12
200027c4:	af00      	add	r7, sp, #0
200027c6:	6078      	str	r0, [r7, #4]
200027c8:	460b      	mov	r3, r1
200027ca:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x1;
200027cc:	687b      	ldr	r3, [r7, #4]
200027ce:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
200027d2:	687b      	ldr	r3, [r7, #4]
200027d4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
200027d8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
200027dc:	ea4f 1343 	mov.w	r3, r3, lsl #5
200027e0:	441a      	add	r2, r3
200027e2:	78fb      	ldrb	r3, [r7, #3]
200027e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
200027e8:	4413      	add	r3, r2
200027ea:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
200027ee:	f04f 0201 	mov.w	r2, #1
200027f2:	601a      	str	r2, [r3, #0]
}
200027f4:	f107 070c 	add.w	r7, r7, #12
200027f8:	46bd      	mov	sp, r7
200027fa:	bc80      	pop	{r7}
200027fc:	4770      	bx	lr
200027fe:	bf00      	nop

20002800 <clear_bit_reg8>:
static __INLINE void clear_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    HW_REG_BIT(reg,bit) = 0x0;
}
static __INLINE void clear_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20002800:	b480      	push	{r7}
20002802:	b083      	sub	sp, #12
20002804:	af00      	add	r7, sp, #0
20002806:	6078      	str	r0, [r7, #4]
20002808:	460b      	mov	r3, r1
2000280a:	70fb      	strb	r3, [r7, #3]
    HW_REG_BIT(reg,bit) = 0x0;
2000280c:	687b      	ldr	r3, [r7, #4]
2000280e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20002812:	687b      	ldr	r3, [r7, #4]
20002814:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20002818:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000281c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20002820:	441a      	add	r2, r3
20002822:	78fb      	ldrb	r3, [r7, #3]
20002824:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002828:	4413      	add	r3, r2
2000282a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000282e:	f04f 0200 	mov.w	r2, #0
20002832:	601a      	str	r2, [r3, #0]
}
20002834:	f107 070c 	add.w	r7, r7, #12
20002838:	46bd      	mov	sp, r7
2000283a:	bc80      	pop	{r7}
2000283c:	4770      	bx	lr
2000283e:	bf00      	nop

20002840 <read_bit_reg8>:
static __INLINE uint8_t read_bit_reg16(volatile uint16_t * reg, uint8_t bit)
{
    return (HW_REG_BIT(reg,bit));
}
static __INLINE uint8_t read_bit_reg8(volatile uint8_t * reg, uint8_t bit)
{
20002840:	b480      	push	{r7}
20002842:	b083      	sub	sp, #12
20002844:	af00      	add	r7, sp, #0
20002846:	6078      	str	r0, [r7, #4]
20002848:	460b      	mov	r3, r1
2000284a:	70fb      	strb	r3, [r7, #3]
    return (HW_REG_BIT(reg,bit));
2000284c:	687b      	ldr	r3, [r7, #4]
2000284e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
20002852:	687b      	ldr	r3, [r7, #4]
20002854:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20002858:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
2000285c:	ea4f 1343 	mov.w	r3, r3, lsl #5
20002860:	441a      	add	r2, r3
20002862:	78fb      	ldrb	r3, [r7, #3]
20002864:	ea4f 0383 	mov.w	r3, r3, lsl #2
20002868:	4413      	add	r3, r2
2000286a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
2000286e:	681b      	ldr	r3, [r3, #0]
20002870:	b2db      	uxtb	r3, r3
}
20002872:	4618      	mov	r0, r3
20002874:	f107 070c 	add.w	r7, r7, #12
20002878:	46bd      	mov	sp, r7
2000287a:	bc80      	pop	{r7}
2000287c:	4770      	bx	lr
2000287e:	bf00      	nop

20002880 <MSS_UART_init>:
(
    mss_uart_instance_t* this_uart, 
    uint32_t baud_rate,
    uint8_t line_config
)
{
20002880:	b580      	push	{r7, lr}
20002882:	b084      	sub	sp, #16
20002884:	af00      	add	r7, sp, #0
20002886:	60f8      	str	r0, [r7, #12]
20002888:	60b9      	str	r1, [r7, #8]
2000288a:	4613      	mov	r3, r2
2000288c:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
2000288e:	68fa      	ldr	r2, [r7, #12]
20002890:	f244 2394 	movw	r3, #17044	; 0x4294
20002894:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002898:	429a      	cmp	r2, r3
2000289a:	d007      	beq.n	200028ac <MSS_UART_init+0x2c>
2000289c:	68fa      	ldr	r2, [r7, #12]
2000289e:	f244 2354 	movw	r3, #16980	; 0x4254
200028a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
200028a6:	429a      	cmp	r2, r3
200028a8:	d000      	beq.n	200028ac <MSS_UART_init+0x2c>
200028aa:	be00      	bkpt	0x0000

    /* Perform generic initialization */
    global_init(this_uart, baud_rate, line_config);
200028ac:	79fb      	ldrb	r3, [r7, #7]
200028ae:	68f8      	ldr	r0, [r7, #12]
200028b0:	68b9      	ldr	r1, [r7, #8]
200028b2:	461a      	mov	r2, r3
200028b4:	f000 fa5c 	bl	20002d70 <global_init>

    /* Disable LIN mode */
    clear_bit_reg8(&this_uart->hw_reg->MM0, ELIN);
200028b8:	68fb      	ldr	r3, [r7, #12]
200028ba:	681b      	ldr	r3, [r3, #0]
200028bc:	f103 0330 	add.w	r3, r3, #48	; 0x30
200028c0:	4618      	mov	r0, r3
200028c2:	f04f 0103 	mov.w	r1, #3
200028c6:	f7ff ff9b 	bl	20002800 <clear_bit_reg8>

    /* Disable IrDA mode */
    clear_bit_reg8(&this_uart->hw_reg->MM1, EIRD);
200028ca:	68fb      	ldr	r3, [r7, #12]
200028cc:	681b      	ldr	r3, [r3, #0]
200028ce:	f103 0334 	add.w	r3, r3, #52	; 0x34
200028d2:	4618      	mov	r0, r3
200028d4:	f04f 0102 	mov.w	r1, #2
200028d8:	f7ff ff92 	bl	20002800 <clear_bit_reg8>

    /* Disable SmartCard Mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2, EERR);
200028dc:	68fb      	ldr	r3, [r7, #12]
200028de:	681b      	ldr	r3, [r3, #0]
200028e0:	f103 0338 	add.w	r3, r3, #56	; 0x38
200028e4:	4618      	mov	r0, r3
200028e6:	f04f 0100 	mov.w	r1, #0
200028ea:	f7ff ff89 	bl	20002800 <clear_bit_reg8>

    /* set default tx handler for automated TX using interrupt in USART mode */
    this_uart->tx_handler = default_tx_handler;
200028ee:	68fa      	ldr	r2, [r7, #12]
200028f0:	f243 2309 	movw	r3, #12809	; 0x3209
200028f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200028f8:	6253      	str	r3, [r2, #36]	; 0x24
}
200028fa:	f107 0710 	add.w	r7, r7, #16
200028fe:	46bd      	mov	sp, r7
20002900:	bd80      	pop	{r7, pc}
20002902:	bf00      	nop

20002904 <MSS_UART_polled_tx>:
(
    mss_uart_instance_t * this_uart,
    const uint8_t * pbuff,
    uint32_t tx_size
)
{
20002904:	b480      	push	{r7}
20002906:	b089      	sub	sp, #36	; 0x24
20002908:	af00      	add	r7, sp, #0
2000290a:	60f8      	str	r0, [r7, #12]
2000290c:	60b9      	str	r1, [r7, #8]
2000290e:	607a      	str	r2, [r7, #4]
    uint32_t char_idx = 0u;
20002910:	f04f 0300 	mov.w	r3, #0
20002914:	613b      	str	r3, [r7, #16]
    uint32_t size_sent;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20002916:	68fa      	ldr	r2, [r7, #12]
20002918:	f244 2394 	movw	r3, #17044	; 0x4294
2000291c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002920:	429a      	cmp	r2, r3
20002922:	d007      	beq.n	20002934 <MSS_UART_polled_tx+0x30>
20002924:	68fa      	ldr	r2, [r7, #12]
20002926:	f244 2354 	movw	r3, #16980	; 0x4254
2000292a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000292e:	429a      	cmp	r2, r3
20002930:	d000      	beq.n	20002934 <MSS_UART_polled_tx+0x30>
20002932:	be00      	bkpt	0x0000
    ASSERT(pbuff != ( (uint8_t *)0));
20002934:	68bb      	ldr	r3, [r7, #8]
20002936:	2b00      	cmp	r3, #0
20002938:	d100      	bne.n	2000293c <MSS_UART_polled_tx+0x38>
2000293a:	be00      	bkpt	0x0000
    ASSERT(tx_size > 0u);
2000293c:	687b      	ldr	r3, [r7, #4]
2000293e:	2b00      	cmp	r3, #0
20002940:	d100      	bne.n	20002944 <MSS_UART_polled_tx+0x40>
20002942:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20002944:	68fa      	ldr	r2, [r7, #12]
20002946:	f244 2394 	movw	r3, #17044	; 0x4294
2000294a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000294e:	429a      	cmp	r2, r3
20002950:	d006      	beq.n	20002960 <MSS_UART_polled_tx+0x5c>
20002952:	68fa      	ldr	r2, [r7, #12]
20002954:	f244 2354 	movw	r3, #16980	; 0x4254
20002958:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000295c:	429a      	cmp	r2, r3
2000295e:	d13d      	bne.n	200029dc <MSS_UART_polled_tx+0xd8>
20002960:	68bb      	ldr	r3, [r7, #8]
20002962:	2b00      	cmp	r3, #0
20002964:	d03a      	beq.n	200029dc <MSS_UART_polled_tx+0xd8>
20002966:	687b      	ldr	r3, [r7, #4]
20002968:	2b00      	cmp	r3, #0
2000296a:	d037      	beq.n	200029dc <MSS_UART_polled_tx+0xd8>
         /* Remain in this loop until the entire input buffer
          * has been transferred to the UART.
          */
        do {
            /* Read the Line Status Register and update the sticky record */
            status = this_uart->hw_reg->LSR;
2000296c:	68fb      	ldr	r3, [r7, #12]
2000296e:	681b      	ldr	r3, [r3, #0]
20002970:	7d1b      	ldrb	r3, [r3, #20]
20002972:	76fb      	strb	r3, [r7, #27]
            this_uart->status |= status;
20002974:	68fb      	ldr	r3, [r7, #12]
20002976:	7b5a      	ldrb	r2, [r3, #13]
20002978:	7efb      	ldrb	r3, [r7, #27]
2000297a:	ea42 0303 	orr.w	r3, r2, r3
2000297e:	b2da      	uxtb	r2, r3
20002980:	68fb      	ldr	r3, [r7, #12]
20002982:	735a      	strb	r2, [r3, #13]

            /* Check if TX FIFO is empty. */
            if(status & MSS_UART_THRE)
20002984:	7efb      	ldrb	r3, [r7, #27]
20002986:	f003 0320 	and.w	r3, r3, #32
2000298a:	2b00      	cmp	r3, #0
2000298c:	d023      	beq.n	200029d6 <MSS_UART_polled_tx+0xd2>
            {
                uint32_t fill_size = TX_FIFO_SIZE;
2000298e:	f04f 0310 	mov.w	r3, #16
20002992:	61fb      	str	r3, [r7, #28]

                /* Calculate the number of bytes to transmit. */
                if(tx_size < TX_FIFO_SIZE)
20002994:	687b      	ldr	r3, [r7, #4]
20002996:	2b0f      	cmp	r3, #15
20002998:	d801      	bhi.n	2000299e <MSS_UART_polled_tx+0x9a>
                {
                    fill_size = tx_size;
2000299a:	687b      	ldr	r3, [r7, #4]
2000299c:	61fb      	str	r3, [r7, #28]
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
2000299e:	f04f 0300 	mov.w	r3, #0
200029a2:	617b      	str	r3, [r7, #20]
200029a4:	e00e      	b.n	200029c4 <MSS_UART_polled_tx+0xc0>
                {
                    /* Send next character in the buffer. */
                    this_uart->hw_reg->THR = pbuff[char_idx];
200029a6:	68fb      	ldr	r3, [r7, #12]
200029a8:	681b      	ldr	r3, [r3, #0]
200029aa:	68b9      	ldr	r1, [r7, #8]
200029ac:	693a      	ldr	r2, [r7, #16]
200029ae:	440a      	add	r2, r1
200029b0:	7812      	ldrb	r2, [r2, #0]
200029b2:	701a      	strb	r2, [r3, #0]
                    char_idx++;
200029b4:	693b      	ldr	r3, [r7, #16]
200029b6:	f103 0301 	add.w	r3, r3, #1
200029ba:	613b      	str	r3, [r7, #16]
                {
                    fill_size = tx_size;
                }

                /* Fill the TX FIFO with the calculated the number of bytes. */
                for(size_sent = 0u; size_sent < fill_size; ++size_sent)
200029bc:	697b      	ldr	r3, [r7, #20]
200029be:	f103 0301 	add.w	r3, r3, #1
200029c2:	617b      	str	r3, [r7, #20]
200029c4:	697a      	ldr	r2, [r7, #20]
200029c6:	69fb      	ldr	r3, [r7, #28]
200029c8:	429a      	cmp	r2, r3
200029ca:	d3ec      	bcc.n	200029a6 <MSS_UART_polled_tx+0xa2>
                    this_uart->hw_reg->THR = pbuff[char_idx];
                    char_idx++;
                }

                /* Calculate the number of untransmitted bytes remaining. */
                tx_size -= size_sent;
200029cc:	687a      	ldr	r2, [r7, #4]
200029ce:	697b      	ldr	r3, [r7, #20]
200029d0:	ebc3 0302 	rsb	r3, r3, r2
200029d4:	607b      	str	r3, [r7, #4]
            }
        } while(tx_size);
200029d6:	687b      	ldr	r3, [r7, #4]
200029d8:	2b00      	cmp	r3, #0
200029da:	d1c7      	bne.n	2000296c <MSS_UART_polled_tx+0x68>
    }
}
200029dc:	f107 0724 	add.w	r7, r7, #36	; 0x24
200029e0:	46bd      	mov	sp, r7
200029e2:	bc80      	pop	{r7}
200029e4:	4770      	bx	lr
200029e6:	bf00      	nop

200029e8 <MSS_UART_polled_tx_string>:
MSS_UART_polled_tx_string
(
    mss_uart_instance_t * this_uart,
    const uint8_t * p_sz_string
)
{
200029e8:	b480      	push	{r7}
200029ea:	b087      	sub	sp, #28
200029ec:	af00      	add	r7, sp, #0
200029ee:	6078      	str	r0, [r7, #4]
200029f0:	6039      	str	r1, [r7, #0]
    uint32_t char_idx = 0u;
200029f2:	f04f 0300 	mov.w	r3, #0
200029f6:	60fb      	str	r3, [r7, #12]
    uint32_t fill_size;
    uint8_t data_byte;
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
200029f8:	687a      	ldr	r2, [r7, #4]
200029fa:	f244 2394 	movw	r3, #17044	; 0x4294
200029fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a02:	429a      	cmp	r2, r3
20002a04:	d007      	beq.n	20002a16 <MSS_UART_polled_tx_string+0x2e>
20002a06:	687a      	ldr	r2, [r7, #4]
20002a08:	f244 2354 	movw	r3, #16980	; 0x4254
20002a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a10:	429a      	cmp	r2, r3
20002a12:	d000      	beq.n	20002a16 <MSS_UART_polled_tx_string+0x2e>
20002a14:	be00      	bkpt	0x0000
    ASSERT(p_sz_string != ((uint8_t *)0));
20002a16:	683b      	ldr	r3, [r7, #0]
20002a18:	2b00      	cmp	r3, #0
20002a1a:	d100      	bne.n	20002a1e <MSS_UART_polled_tx_string+0x36>
20002a1c:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20002a1e:	687a      	ldr	r2, [r7, #4]
20002a20:	f244 2394 	movw	r3, #17044	; 0x4294
20002a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a28:	429a      	cmp	r2, r3
20002a2a:	d006      	beq.n	20002a3a <MSS_UART_polled_tx_string+0x52>
20002a2c:	687a      	ldr	r2, [r7, #4]
20002a2e:	f244 2354 	movw	r3, #16980	; 0x4254
20002a32:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002a36:	429a      	cmp	r2, r3
20002a38:	d137      	bne.n	20002aaa <MSS_UART_polled_tx_string+0xc2>
20002a3a:	683b      	ldr	r3, [r7, #0]
20002a3c:	2b00      	cmp	r3, #0
20002a3e:	d034      	beq.n	20002aaa <MSS_UART_polled_tx_string+0xc2>
       (p_sz_string != ((uint8_t *)0)))
    {
        /* Get the first data byte from the input buffer */
        data_byte = p_sz_string[char_idx];
20002a40:	683a      	ldr	r2, [r7, #0]
20002a42:	68fb      	ldr	r3, [r7, #12]
20002a44:	4413      	add	r3, r2
20002a46:	781b      	ldrb	r3, [r3, #0]
20002a48:	75bb      	strb	r3, [r7, #22]

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while(0u != data_byte)
20002a4a:	e02b      	b.n	20002aa4 <MSS_UART_polled_tx_string+0xbc>
        {
            /* Wait until TX FIFO is empty. */
            do {
                status = this_uart->hw_reg->LSR;
20002a4c:	687b      	ldr	r3, [r7, #4]
20002a4e:	681b      	ldr	r3, [r3, #0]
20002a50:	7d1b      	ldrb	r3, [r3, #20]
20002a52:	75fb      	strb	r3, [r7, #23]
                this_uart->status |= status;
20002a54:	687b      	ldr	r3, [r7, #4]
20002a56:	7b5a      	ldrb	r2, [r3, #13]
20002a58:	7dfb      	ldrb	r3, [r7, #23]
20002a5a:	ea42 0303 	orr.w	r3, r2, r3
20002a5e:	b2da      	uxtb	r2, r3
20002a60:	687b      	ldr	r3, [r7, #4]
20002a62:	735a      	strb	r2, [r3, #13]
            } while (0u == (status & MSS_UART_THRE));
20002a64:	7dfb      	ldrb	r3, [r7, #23]
20002a66:	f003 0320 	and.w	r3, r3, #32
20002a6a:	2b00      	cmp	r3, #0
20002a6c:	d0ee      	beq.n	20002a4c <MSS_UART_polled_tx_string+0x64>

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0u;
20002a6e:	f04f 0300 	mov.w	r3, #0
20002a72:	613b      	str	r3, [r7, #16]
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
20002a74:	e010      	b.n	20002a98 <MSS_UART_polled_tx_string+0xb0>
            {
                /* Send the data byte */
                this_uart->hw_reg->THR = data_byte;
20002a76:	687b      	ldr	r3, [r7, #4]
20002a78:	681b      	ldr	r3, [r3, #0]
20002a7a:	7dba      	ldrb	r2, [r7, #22]
20002a7c:	701a      	strb	r2, [r3, #0]
                ++fill_size;
20002a7e:	693b      	ldr	r3, [r7, #16]
20002a80:	f103 0301 	add.w	r3, r3, #1
20002a84:	613b      	str	r3, [r7, #16]
                char_idx++;
20002a86:	68fb      	ldr	r3, [r7, #12]
20002a88:	f103 0301 	add.w	r3, r3, #1
20002a8c:	60fb      	str	r3, [r7, #12]
                /* Get the next data byte from the input buffer */
                data_byte = p_sz_string[char_idx];
20002a8e:	683a      	ldr	r2, [r7, #0]
20002a90:	68fb      	ldr	r3, [r7, #12]
20002a92:	4413      	add	r3, r2
20002a94:	781b      	ldrb	r3, [r3, #0]
20002a96:	75bb      	strb	r3, [r7, #22]

            /* Send bytes from the input buffer until the TX FIFO is full
             * or we reach the NULL terminator byte.
             */
            fill_size = 0u;
            while((0u != data_byte) && (fill_size < TX_FIFO_SIZE))
20002a98:	7dbb      	ldrb	r3, [r7, #22]
20002a9a:	2b00      	cmp	r3, #0
20002a9c:	d002      	beq.n	20002aa4 <MSS_UART_polled_tx_string+0xbc>
20002a9e:	693b      	ldr	r3, [r7, #16]
20002aa0:	2b0f      	cmp	r3, #15
20002aa2:	d9e8      	bls.n	20002a76 <MSS_UART_polled_tx_string+0x8e>

        /* First check for the NULL terminator byte.
         * Then remain in this loop until the entire string in the input buffer
         * has been transferred to the UART.
         */
        while(0u != data_byte)
20002aa4:	7dbb      	ldrb	r3, [r7, #22]
20002aa6:	2b00      	cmp	r3, #0
20002aa8:	d1d0      	bne.n	20002a4c <MSS_UART_polled_tx_string+0x64>
                /* Get the next data byte from the input buffer */
                data_byte = p_sz_string[char_idx];
            }
        }
    }
}
20002aaa:	f107 071c 	add.w	r7, r7, #28
20002aae:	46bd      	mov	sp, r7
20002ab0:	bc80      	pop	{r7}
20002ab2:	4770      	bx	lr

20002ab4 <MSS_UART_get_rx>:
(
    mss_uart_instance_t * this_uart,
    uint8_t * rx_buff,
    size_t buff_size
)
{
20002ab4:	b480      	push	{r7}
20002ab6:	b087      	sub	sp, #28
20002ab8:	af00      	add	r7, sp, #0
20002aba:	60f8      	str	r0, [r7, #12]
20002abc:	60b9      	str	r1, [r7, #8]
20002abe:	607a      	str	r2, [r7, #4]
    size_t rx_size = 0u;
20002ac0:	f04f 0300 	mov.w	r3, #0
20002ac4:	613b      	str	r3, [r7, #16]
    uint8_t status = 0u;
20002ac6:	f04f 0300 	mov.w	r3, #0
20002aca:	75fb      	strb	r3, [r7, #23]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20002acc:	68fa      	ldr	r2, [r7, #12]
20002ace:	f244 2394 	movw	r3, #17044	; 0x4294
20002ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ad6:	429a      	cmp	r2, r3
20002ad8:	d007      	beq.n	20002aea <MSS_UART_get_rx+0x36>
20002ada:	68fa      	ldr	r2, [r7, #12]
20002adc:	f244 2354 	movw	r3, #16980	; 0x4254
20002ae0:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ae4:	429a      	cmp	r2, r3
20002ae6:	d000      	beq.n	20002aea <MSS_UART_get_rx+0x36>
20002ae8:	be00      	bkpt	0x0000
    ASSERT(rx_buff != ((uint8_t *)0));
20002aea:	68bb      	ldr	r3, [r7, #8]
20002aec:	2b00      	cmp	r3, #0
20002aee:	d100      	bne.n	20002af2 <MSS_UART_get_rx+0x3e>
20002af0:	be00      	bkpt	0x0000
    ASSERT(buff_size > 0u);
20002af2:	687b      	ldr	r3, [r7, #4]
20002af4:	2b00      	cmp	r3, #0
20002af6:	d100      	bne.n	20002afa <MSS_UART_get_rx+0x46>
20002af8:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20002afa:	68fa      	ldr	r2, [r7, #12]
20002afc:	f244 2394 	movw	r3, #17044	; 0x4294
20002b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b04:	429a      	cmp	r2, r3
20002b06:	d006      	beq.n	20002b16 <MSS_UART_get_rx+0x62>
20002b08:	68fa      	ldr	r2, [r7, #12]
20002b0a:	f244 2354 	movw	r3, #16980	; 0x4254
20002b0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002b12:	429a      	cmp	r2, r3
20002b14:	d134      	bne.n	20002b80 <MSS_UART_get_rx+0xcc>
20002b16:	68bb      	ldr	r3, [r7, #8]
20002b18:	2b00      	cmp	r3, #0
20002b1a:	d031      	beq.n	20002b80 <MSS_UART_get_rx+0xcc>
20002b1c:	687b      	ldr	r3, [r7, #4]
20002b1e:	2b00      	cmp	r3, #0
20002b20:	d02e      	beq.n	20002b80 <MSS_UART_get_rx+0xcc>
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
20002b22:	68fb      	ldr	r3, [r7, #12]
20002b24:	681b      	ldr	r3, [r3, #0]
20002b26:	7d1b      	ldrb	r3, [r3, #20]
20002b28:	75fb      	strb	r3, [r7, #23]
        this_uart->status |= status;
20002b2a:	68fb      	ldr	r3, [r7, #12]
20002b2c:	7b5a      	ldrb	r2, [r3, #13]
20002b2e:	7dfb      	ldrb	r3, [r7, #23]
20002b30:	ea42 0303 	orr.w	r3, r2, r3
20002b34:	b2da      	uxtb	r2, r3
20002b36:	68fb      	ldr	r3, [r7, #12]
20002b38:	735a      	strb	r2, [r3, #13]

        while(((status & MSS_UART_DATA_READY) != 0u) &&
20002b3a:	e017      	b.n	20002b6c <MSS_UART_get_rx+0xb8>
              (rx_size < buff_size))
        {
            rx_buff[rx_size] = this_uart->hw_reg->RBR;
20002b3c:	68ba      	ldr	r2, [r7, #8]
20002b3e:	693b      	ldr	r3, [r7, #16]
20002b40:	4413      	add	r3, r2
20002b42:	68fa      	ldr	r2, [r7, #12]
20002b44:	6812      	ldr	r2, [r2, #0]
20002b46:	7812      	ldrb	r2, [r2, #0]
20002b48:	b2d2      	uxtb	r2, r2
20002b4a:	701a      	strb	r2, [r3, #0]
            ++rx_size;
20002b4c:	693b      	ldr	r3, [r7, #16]
20002b4e:	f103 0301 	add.w	r3, r3, #1
20002b52:	613b      	str	r3, [r7, #16]
            status = this_uart->hw_reg->LSR;
20002b54:	68fb      	ldr	r3, [r7, #12]
20002b56:	681b      	ldr	r3, [r3, #0]
20002b58:	7d1b      	ldrb	r3, [r3, #20]
20002b5a:	75fb      	strb	r3, [r7, #23]
            this_uart->status |= status;
20002b5c:	68fb      	ldr	r3, [r7, #12]
20002b5e:	7b5a      	ldrb	r2, [r3, #13]
20002b60:	7dfb      	ldrb	r3, [r7, #23]
20002b62:	ea42 0303 	orr.w	r3, r2, r3
20002b66:	b2da      	uxtb	r2, r3
20002b68:	68fb      	ldr	r3, [r7, #12]
20002b6a:	735a      	strb	r2, [r3, #13]
       (rx_buff != ((uint8_t *)0)) && (buff_size > 0u))
    {
        status = this_uart->hw_reg->LSR;
        this_uart->status |= status;

        while(((status & MSS_UART_DATA_READY) != 0u) &&
20002b6c:	7dfb      	ldrb	r3, [r7, #23]
20002b6e:	f003 0301 	and.w	r3, r3, #1
20002b72:	b2db      	uxtb	r3, r3
20002b74:	2b00      	cmp	r3, #0
20002b76:	d003      	beq.n	20002b80 <MSS_UART_get_rx+0xcc>
20002b78:	693a      	ldr	r2, [r7, #16]
20002b7a:	687b      	ldr	r3, [r7, #4]
20002b7c:	429a      	cmp	r2, r3
20002b7e:	d3dd      	bcc.n	20002b3c <MSS_UART_get_rx+0x88>
            ++rx_size;
            status = this_uart->hw_reg->LSR;
            this_uart->status |= status;
        }
    }
    return rx_size;
20002b80:	693b      	ldr	r3, [r7, #16]
}
20002b82:	4618      	mov	r0, r3
20002b84:	f107 071c 	add.w	r7, r7, #28
20002b88:	46bd      	mov	sp, r7
20002b8a:	bc80      	pop	{r7}
20002b8c:	4770      	bx	lr
20002b8e:	bf00      	nop

20002b90 <UART0_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART0_IRQHandler(void)
#else
void UART0_IRQHandler(void)
#endif
{
20002b90:	4668      	mov	r0, sp
20002b92:	f020 0107 	bic.w	r1, r0, #7
20002b96:	468d      	mov	sp, r1
20002b98:	b589      	push	{r0, r3, r7, lr}
20002b9a:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart0);
20002b9c:	f244 2094 	movw	r0, #17044	; 0x4294
20002ba0:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002ba4:	f000 fa1a 	bl	20002fdc <MSS_UART_isr>
}
20002ba8:	46bd      	mov	sp, r7
20002baa:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20002bae:	4685      	mov	sp, r0
20002bb0:	4770      	bx	lr
20002bb2:	bf00      	nop

20002bb4 <UART1_IRQHandler>:
#if defined(__GNUC__)
__attribute__((__interrupt__)) void UART1_IRQHandler(void)
#else
void UART1_IRQHandler(void)
#endif
{
20002bb4:	4668      	mov	r0, sp
20002bb6:	f020 0107 	bic.w	r1, r0, #7
20002bba:	468d      	mov	sp, r1
20002bbc:	b589      	push	{r0, r3, r7, lr}
20002bbe:	af00      	add	r7, sp, #0
    MSS_UART_isr(&g_mss_uart1);
20002bc0:	f244 2054 	movw	r0, #16980	; 0x4254
20002bc4:	f2c2 0000 	movt	r0, #8192	; 0x2000
20002bc8:	f000 fa08 	bl	20002fdc <MSS_UART_isr>
}
20002bcc:	46bd      	mov	sp, r7
20002bce:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
20002bd2:	4685      	mov	sp, r0
20002bd4:	4770      	bx	lr
20002bd6:	bf00      	nop

20002bd8 <config_baud_divisors>:
config_baud_divisors
(
    mss_uart_instance_t * this_uart,
    uint32_t baudrate    
)
{
20002bd8:	b580      	push	{r7, lr}
20002bda:	b088      	sub	sp, #32
20002bdc:	af00      	add	r7, sp, #0
20002bde:	6078      	str	r0, [r7, #4]
20002be0:	6039      	str	r1, [r7, #0]
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20002be2:	687a      	ldr	r2, [r7, #4]
20002be4:	f244 2394 	movw	r3, #17044	; 0x4294
20002be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002bec:	429a      	cmp	r2, r3
20002bee:	d007      	beq.n	20002c00 <config_baud_divisors+0x28>
20002bf0:	687a      	ldr	r2, [r7, #4]
20002bf2:	f244 2354 	movw	r3, #16980	; 0x4254
20002bf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002bfa:	429a      	cmp	r2, r3
20002bfc:	d000      	beq.n	20002c00 <config_baud_divisors+0x28>
20002bfe:	be00      	bkpt	0x0000
    
    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20002c00:	687a      	ldr	r2, [r7, #4]
20002c02:	f244 2394 	movw	r3, #17044	; 0x4294
20002c06:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c0a:	429a      	cmp	r2, r3
20002c0c:	d007      	beq.n	20002c1e <config_baud_divisors+0x46>
20002c0e:	687a      	ldr	r2, [r7, #4]
20002c10:	f244 2354 	movw	r3, #16980	; 0x4254
20002c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c18:	429a      	cmp	r2, r3
20002c1a:	f040 80a4 	bne.w	20002d66 <config_baud_divisors+0x18e>
        uint32_t baud_value_by_64;
        uint32_t baud_value_by_128;
        uint32_t fractional_baud_value;
        uint32_t pclk_freq;

        this_uart->baudrate = baudrate;
20002c1e:	687b      	ldr	r3, [r7, #4]
20002c20:	683a      	ldr	r2, [r7, #0]
20002c22:	609a      	str	r2, [r3, #8]

        /* Force the value of the CMSIS global variables holding the various system
          * clock frequencies to be updated. */
        SystemCoreClockUpdate();
20002c24:	f000 fc3a 	bl	2000349c <SystemCoreClockUpdate>
        if(this_uart == &g_mss_uart0)
20002c28:	687a      	ldr	r2, [r7, #4]
20002c2a:	f244 2394 	movw	r3, #17044	; 0x4294
20002c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c32:	429a      	cmp	r2, r3
20002c34:	d106      	bne.n	20002c44 <config_baud_divisors+0x6c>
        {
            pclk_freq = g_FrequencyPCLK0;
20002c36:	f244 2338 	movw	r3, #16952	; 0x4238
20002c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c3e:	681b      	ldr	r3, [r3, #0]
20002c40:	61fb      	str	r3, [r7, #28]
20002c42:	e005      	b.n	20002c50 <config_baud_divisors+0x78>
        }
        else
        {
            pclk_freq = g_FrequencyPCLK1;
20002c44:	f244 233c 	movw	r3, #16956	; 0x423c
20002c48:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002c4c:	681b      	ldr	r3, [r3, #0]
20002c4e:	61fb      	str	r3, [r7, #28]
        /*
         * Compute baud value based on requested baud rate and PCLK frequency.
         * The baud value is computed using the following equation:
         *      baud_value = PCLK_Frequency / (baud_rate * 16)
         */
        baud_value_by_128 = (8u * pclk_freq) / baudrate;
20002c50:	69fb      	ldr	r3, [r7, #28]
20002c52:	ea4f 02c3 	mov.w	r2, r3, lsl #3
20002c56:	683b      	ldr	r3, [r7, #0]
20002c58:	fbb2 f3f3 	udiv	r3, r2, r3
20002c5c:	617b      	str	r3, [r7, #20]
        baud_value_by_64 = baud_value_by_128 / 2u;
20002c5e:	697b      	ldr	r3, [r7, #20]
20002c60:	ea4f 0353 	mov.w	r3, r3, lsr #1
20002c64:	613b      	str	r3, [r7, #16]
        baud_value = baud_value_by_64 / 64u;
20002c66:	693b      	ldr	r3, [r7, #16]
20002c68:	ea4f 1393 	mov.w	r3, r3, lsr #6
20002c6c:	60fb      	str	r3, [r7, #12]
        fractional_baud_value = baud_value_by_64 - (baud_value * 64u);
20002c6e:	68fb      	ldr	r3, [r7, #12]
20002c70:	ea4f 1383 	mov.w	r3, r3, lsl #6
20002c74:	693a      	ldr	r2, [r7, #16]
20002c76:	ebc3 0302 	rsb	r3, r3, r2
20002c7a:	61bb      	str	r3, [r7, #24]
        fractional_baud_value += (baud_value_by_128 - (baud_value * 128u)) - (fractional_baud_value * 2u);
20002c7c:	68fb      	ldr	r3, [r7, #12]
20002c7e:	ea4f 13c3 	mov.w	r3, r3, lsl #7
20002c82:	697a      	ldr	r2, [r7, #20]
20002c84:	ebc3 0202 	rsb	r2, r3, r2
20002c88:	69bb      	ldr	r3, [r7, #24]
20002c8a:	ea4f 0343 	mov.w	r3, r3, lsl #1
20002c8e:	ebc3 0302 	rsb	r3, r3, r2
20002c92:	69ba      	ldr	r2, [r7, #24]
20002c94:	4413      	add	r3, r2
20002c96:	61bb      	str	r3, [r7, #24]
        
        /* Assert if integer baud value fits in 16-bit. */
        ASSERT(baud_value <= UINT16_MAX);
20002c98:	68fa      	ldr	r2, [r7, #12]
20002c9a:	f64f 73ff 	movw	r3, #65535	; 0xffff
20002c9e:	429a      	cmp	r2, r3
20002ca0:	d900      	bls.n	20002ca4 <config_baud_divisors+0xcc>
20002ca2:	be00      	bkpt	0x0000
    
        if(baud_value <= (uint32_t)UINT16_MAX)
20002ca4:	68fa      	ldr	r2, [r7, #12]
20002ca6:	f64f 73ff 	movw	r3, #65535	; 0xffff
20002caa:	429a      	cmp	r2, r3
20002cac:	d85b      	bhi.n	20002d66 <config_baud_divisors+0x18e>
        {
            if(baud_value > 1u)
20002cae:	68fb      	ldr	r3, [r7, #12]
20002cb0:	2b01      	cmp	r3, #1
20002cb2:	d931      	bls.n	20002d18 <config_baud_divisors+0x140>
            {
                /* 
                 * Use Frational baud rate divisors
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20002cb4:	687b      	ldr	r3, [r7, #4]
20002cb6:	681b      	ldr	r3, [r3, #0]
20002cb8:	f103 030c 	add.w	r3, r3, #12
20002cbc:	4618      	mov	r0, r3
20002cbe:	f04f 0107 	mov.w	r1, #7
20002cc2:	f7ff fd7d 	bl	200027c0 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8);
20002cc6:	687b      	ldr	r3, [r7, #4]
20002cc8:	681b      	ldr	r3, [r3, #0]
20002cca:	68fa      	ldr	r2, [r7, #12]
20002ccc:	ea4f 2212 	mov.w	r2, r2, lsr #8
20002cd0:	b2d2      	uxtb	r2, r2
20002cd2:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
20002cd4:	687b      	ldr	r3, [r7, #4]
20002cd6:	681b      	ldr	r3, [r3, #0]
20002cd8:	68fa      	ldr	r2, [r7, #12]
20002cda:	b2d2      	uxtb	r2, r2
20002cdc:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20002cde:	687b      	ldr	r3, [r7, #4]
20002ce0:	681b      	ldr	r3, [r3, #0]
20002ce2:	f103 030c 	add.w	r3, r3, #12
20002ce6:	4618      	mov	r0, r3
20002ce8:	f04f 0107 	mov.w	r1, #7
20002cec:	f7ff fd88 	bl	20002800 <clear_bit_reg8>
        
                /* Enable Fractional baud rate */
                set_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
20002cf0:	687b      	ldr	r3, [r7, #4]
20002cf2:	681b      	ldr	r3, [r3, #0]
20002cf4:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002cf8:	4618      	mov	r0, r3
20002cfa:	f04f 0107 	mov.w	r1, #7
20002cfe:	f7ff fd5f 	bl	200027c0 <set_bit_reg8>
        
                /* Load the fractional baud rate register */
                ASSERT(fractional_baud_value <= (uint32_t)UINT8_MAX);
20002d02:	69bb      	ldr	r3, [r7, #24]
20002d04:	2bff      	cmp	r3, #255	; 0xff
20002d06:	d900      	bls.n	20002d0a <config_baud_divisors+0x132>
20002d08:	be00      	bkpt	0x0000
                this_uart->hw_reg->DFR = (uint8_t)fractional_baud_value;
20002d0a:	687b      	ldr	r3, [r7, #4]
20002d0c:	681b      	ldr	r3, [r3, #0]
20002d0e:	69ba      	ldr	r2, [r7, #24]
20002d10:	b2d2      	uxtb	r2, r2
20002d12:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
20002d16:	e026      	b.n	20002d66 <config_baud_divisors+0x18e>
            {
                /*
                 * Do NOT use Frational baud rate divisors.
                 */
                /* set divisor latch */
                set_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20002d18:	687b      	ldr	r3, [r7, #4]
20002d1a:	681b      	ldr	r3, [r3, #0]
20002d1c:	f103 030c 	add.w	r3, r3, #12
20002d20:	4618      	mov	r0, r3
20002d22:	f04f 0107 	mov.w	r1, #7
20002d26:	f7ff fd4b 	bl	200027c0 <set_bit_reg8>
            
                /* msb of baud value */
                this_uart->hw_reg->DMR = (uint8_t)(baud_value >> 8u);
20002d2a:	687b      	ldr	r3, [r7, #4]
20002d2c:	681b      	ldr	r3, [r3, #0]
20002d2e:	68fa      	ldr	r2, [r7, #12]
20002d30:	ea4f 2212 	mov.w	r2, r2, lsr #8
20002d34:	b2d2      	uxtb	r2, r2
20002d36:	711a      	strb	r2, [r3, #4]
                /* lsb of baud value */
                this_uart->hw_reg->DLR = (uint8_t)baud_value;
20002d38:	687b      	ldr	r3, [r7, #4]
20002d3a:	681b      	ldr	r3, [r3, #0]
20002d3c:	68fa      	ldr	r2, [r7, #12]
20002d3e:	b2d2      	uxtb	r2, r2
20002d40:	701a      	strb	r2, [r3, #0]
            
                /* reset divisor latch */
                clear_bit_reg8(&this_uart->hw_reg->LCR,DLAB);
20002d42:	687b      	ldr	r3, [r7, #4]
20002d44:	681b      	ldr	r3, [r3, #0]
20002d46:	f103 030c 	add.w	r3, r3, #12
20002d4a:	4618      	mov	r0, r3
20002d4c:	f04f 0107 	mov.w	r1, #7
20002d50:	f7ff fd56 	bl	20002800 <clear_bit_reg8>
                
                /* Disable Fractional baud rate */
                clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR);
20002d54:	687b      	ldr	r3, [r7, #4]
20002d56:	681b      	ldr	r3, [r3, #0]
20002d58:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002d5c:	4618      	mov	r0, r3
20002d5e:	f04f 0107 	mov.w	r1, #7
20002d62:	f7ff fd4d 	bl	20002800 <clear_bit_reg8>
            }
        }
    }
}
20002d66:	f107 0720 	add.w	r7, r7, #32
20002d6a:	46bd      	mov	sp, r7
20002d6c:	bd80      	pop	{r7, pc}
20002d6e:	bf00      	nop

20002d70 <global_init>:
(
    mss_uart_instance_t * this_uart,
    uint32_t baud_rate,
    uint8_t line_config
)
{
20002d70:	b580      	push	{r7, lr}
20002d72:	b084      	sub	sp, #16
20002d74:	af00      	add	r7, sp, #0
20002d76:	60f8      	str	r0, [r7, #12]
20002d78:	60b9      	str	r1, [r7, #8]
20002d7a:	4613      	mov	r3, r2
20002d7c:	71fb      	strb	r3, [r7, #7]
    /* The driver expects g_mss_uart0 and g_mss_uart1 to be the only
     * mss_uart_instance_t instances used to identify UART0 and UART1. */
    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20002d7e:	68fa      	ldr	r2, [r7, #12]
20002d80:	f244 2394 	movw	r3, #17044	; 0x4294
20002d84:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d88:	429a      	cmp	r2, r3
20002d8a:	d007      	beq.n	20002d9c <global_init+0x2c>
20002d8c:	68fa      	ldr	r2, [r7, #12]
20002d8e:	f244 2354 	movw	r3, #16980	; 0x4254
20002d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002d96:	429a      	cmp	r2, r3
20002d98:	d000      	beq.n	20002d9c <global_init+0x2c>
20002d9a:	be00      	bkpt	0x0000

    if(this_uart == &g_mss_uart0)
20002d9c:	68fa      	ldr	r2, [r7, #12]
20002d9e:	f244 2394 	movw	r3, #17044	; 0x4294
20002da2:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002da6:	429a      	cmp	r2, r3
20002da8:	d124      	bne.n	20002df4 <global_init+0x84>
    {
        this_uart->hw_reg = UART0;
20002daa:	68fb      	ldr	r3, [r7, #12]
20002dac:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
20002db0:	601a      	str	r2, [r3, #0]
        this_uart->irqn = UART0_IRQn;
20002db2:	68fb      	ldr	r3, [r7, #12]
20002db4:	f04f 020a 	mov.w	r2, #10
20002db8:	711a      	strb	r2, [r3, #4]
        /* reset UART0 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART0_SOFTRESET_MASK;
20002dba:	f248 0300 	movw	r3, #32768	; 0x8000
20002dbe:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002dc2:	f248 0200 	movw	r2, #32768	; 0x8000
20002dc6:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002dca:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002dcc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
20002dd0:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART0 interrupt */
        NVIC_ClearPendingIRQ(UART0_IRQn);
20002dd2:	f04f 000a 	mov.w	r0, #10
20002dd6:	f7ff fcd5 	bl	20002784 <NVIC_ClearPendingIRQ>
        /* Take UART0 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART0_SOFTRESET_MASK;
20002dda:	f248 0300 	movw	r3, #32768	; 0x8000
20002dde:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002de2:	f248 0200 	movw	r2, #32768	; 0x8000
20002de6:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002dea:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002dec:	f022 0280 	bic.w	r2, r2, #128	; 0x80
20002df0:	649a      	str	r2, [r3, #72]	; 0x48
20002df2:	e025      	b.n	20002e40 <global_init+0xd0>
    }
    else
    {
        this_uart->hw_reg = UART1;
20002df4:	68fa      	ldr	r2, [r7, #12]
20002df6:	f240 0300 	movw	r3, #0
20002dfa:	f2c4 0301 	movt	r3, #16385	; 0x4001
20002dfe:	6013      	str	r3, [r2, #0]
        this_uart->irqn = UART1_IRQn;
20002e00:	68fb      	ldr	r3, [r7, #12]
20002e02:	f04f 020b 	mov.w	r2, #11
20002e06:	711a      	strb	r2, [r3, #4]
        /* Reset UART1 */
        SYSREG->SOFT_RST_CR |= SYSREG_MMUART1_SOFTRESET_MASK;
20002e08:	f248 0300 	movw	r3, #32768	; 0x8000
20002e0c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002e10:	f248 0200 	movw	r2, #32768	; 0x8000
20002e14:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002e18:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002e1a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20002e1e:	649a      	str	r2, [r3, #72]	; 0x48
        /* Clear any previously pended UART1 interrupt */
        NVIC_ClearPendingIRQ(UART1_IRQn);
20002e20:	f04f 000b 	mov.w	r0, #11
20002e24:	f7ff fcae 	bl	20002784 <NVIC_ClearPendingIRQ>
        /* Take UART1 out of reset. */
        SYSREG->SOFT_RST_CR &= ~SYSREG_MMUART1_SOFTRESET_MASK;
20002e28:	f248 0300 	movw	r3, #32768	; 0x8000
20002e2c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20002e30:	f248 0200 	movw	r2, #32768	; 0x8000
20002e34:	f2c4 0203 	movt	r2, #16387	; 0x4003
20002e38:	6c92      	ldr	r2, [r2, #72]	; 0x48
20002e3a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20002e3e:	649a      	str	r2, [r3, #72]	; 0x48
    }

    /* disable interrupts */
    this_uart->hw_reg->IER = 0u;
20002e40:	68fb      	ldr	r3, [r7, #12]
20002e42:	681b      	ldr	r3, [r3, #0]
20002e44:	f04f 0200 	mov.w	r2, #0
20002e48:	711a      	strb	r2, [r3, #4]

    /* FIFO configuration */
    this_uart->hw_reg->FCR = (uint8_t)MSS_UART_FIFO_SINGLE_BYTE;
20002e4a:	68fb      	ldr	r3, [r7, #12]
20002e4c:	681b      	ldr	r3, [r3, #0]
20002e4e:	f04f 0200 	mov.w	r2, #0
20002e52:	721a      	strb	r2, [r3, #8]
    /* clear receiver FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_RX_FIFO);
20002e54:	68fb      	ldr	r3, [r7, #12]
20002e56:	681b      	ldr	r3, [r3, #0]
20002e58:	f103 0308 	add.w	r3, r3, #8
20002e5c:	4618      	mov	r0, r3
20002e5e:	f04f 0101 	mov.w	r1, #1
20002e62:	f7ff fcad 	bl	200027c0 <set_bit_reg8>
    /* clear transmitter FIFO */
    set_bit_reg8(&this_uart->hw_reg->FCR,CLEAR_TX_FIFO);
20002e66:	68fb      	ldr	r3, [r7, #12]
20002e68:	681b      	ldr	r3, [r3, #0]
20002e6a:	f103 0308 	add.w	r3, r3, #8
20002e6e:	4618      	mov	r0, r3
20002e70:	f04f 0102 	mov.w	r1, #2
20002e74:	f7ff fca4 	bl	200027c0 <set_bit_reg8>

    /* set default READY mode : Mode 0*/
    /* enable RXRDYN and TXRDYN pins. The earlier FCR write to set the TX FIFO
     * trigger level inadvertently disabled the FCR_RXRDY_TXRDYN_EN bit. */
    set_bit_reg8(&this_uart->hw_reg->FCR,RXRDY_TXRDYN_EN);
20002e78:	68fb      	ldr	r3, [r7, #12]
20002e7a:	681b      	ldr	r3, [r3, #0]
20002e7c:	f103 0308 	add.w	r3, r3, #8
20002e80:	4618      	mov	r0, r3
20002e82:	f04f 0100 	mov.w	r1, #0
20002e86:	f7ff fc9b 	bl	200027c0 <set_bit_reg8>

    /* disable loopback : local * remote */
    clear_bit_reg8(&this_uart->hw_reg->MCR,LOOP);
20002e8a:	68fb      	ldr	r3, [r7, #12]
20002e8c:	681b      	ldr	r3, [r3, #0]
20002e8e:	f103 0310 	add.w	r3, r3, #16
20002e92:	4618      	mov	r0, r3
20002e94:	f04f 0104 	mov.w	r1, #4
20002e98:	f7ff fcb2 	bl	20002800 <clear_bit_reg8>
    clear_bit_reg8(&this_uart->hw_reg->MCR,RLOOP);
20002e9c:	68fb      	ldr	r3, [r7, #12]
20002e9e:	681b      	ldr	r3, [r3, #0]
20002ea0:	f103 0310 	add.w	r3, r3, #16
20002ea4:	4618      	mov	r0, r3
20002ea6:	f04f 0105 	mov.w	r1, #5
20002eaa:	f7ff fca9 	bl	20002800 <clear_bit_reg8>

    /* set default TX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_TX);
20002eae:	68fb      	ldr	r3, [r7, #12]
20002eb0:	681b      	ldr	r3, [r3, #0]
20002eb2:	f103 0334 	add.w	r3, r3, #52	; 0x34
20002eb6:	4618      	mov	r0, r3
20002eb8:	f04f 0101 	mov.w	r1, #1
20002ebc:	f7ff fca0 	bl	20002800 <clear_bit_reg8>
    /* set default RX endian */
    clear_bit_reg8(&this_uart->hw_reg->MM1,E_MSB_RX);
20002ec0:	68fb      	ldr	r3, [r7, #12]
20002ec2:	681b      	ldr	r3, [r3, #0]
20002ec4:	f103 0334 	add.w	r3, r3, #52	; 0x34
20002ec8:	4618      	mov	r0, r3
20002eca:	f04f 0100 	mov.w	r1, #0
20002ece:	f7ff fc97 	bl	20002800 <clear_bit_reg8>

    /* default AFM : disabled */
    clear_bit_reg8(&this_uart->hw_reg->MM2,EAFM);
20002ed2:	68fb      	ldr	r3, [r7, #12]
20002ed4:	681b      	ldr	r3, [r3, #0]
20002ed6:	f103 0338 	add.w	r3, r3, #56	; 0x38
20002eda:	4618      	mov	r0, r3
20002edc:	f04f 0101 	mov.w	r1, #1
20002ee0:	f7ff fc8e 	bl	20002800 <clear_bit_reg8>

    /* disable TX time gaurd */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ETTG); 
20002ee4:	68fb      	ldr	r3, [r7, #12]
20002ee6:	681b      	ldr	r3, [r3, #0]
20002ee8:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002eec:	4618      	mov	r0, r3
20002eee:	f04f 0105 	mov.w	r1, #5
20002ef2:	f7ff fc85 	bl	20002800 <clear_bit_reg8>

    /* set default RX timeout */
    clear_bit_reg8(&this_uart->hw_reg->MM0,ERTO); 
20002ef6:	68fb      	ldr	r3, [r7, #12]
20002ef8:	681b      	ldr	r3, [r3, #0]
20002efa:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002efe:	4618      	mov	r0, r3
20002f00:	f04f 0106 	mov.w	r1, #6
20002f04:	f7ff fc7c 	bl	20002800 <clear_bit_reg8>

    /* disable fractional baud-rate */
    clear_bit_reg8(&this_uart->hw_reg->MM0,EFBR); 
20002f08:	68fb      	ldr	r3, [r7, #12]
20002f0a:	681b      	ldr	r3, [r3, #0]
20002f0c:	f103 0330 	add.w	r3, r3, #48	; 0x30
20002f10:	4618      	mov	r0, r3
20002f12:	f04f 0107 	mov.w	r1, #7
20002f16:	f7ff fc73 	bl	20002800 <clear_bit_reg8>

    /* disable single wire mode */
    clear_bit_reg8(&this_uart->hw_reg->MM2,ESWM);
20002f1a:	68fb      	ldr	r3, [r7, #12]
20002f1c:	681b      	ldr	r3, [r3, #0]
20002f1e:	f103 0338 	add.w	r3, r3, #56	; 0x38
20002f22:	4618      	mov	r0, r3
20002f24:	f04f 0103 	mov.w	r1, #3
20002f28:	f7ff fc6a 	bl	20002800 <clear_bit_reg8>

    /* set filter to minimum value */
    this_uart->hw_reg->GFR = 0u;
20002f2c:	68fb      	ldr	r3, [r7, #12]
20002f2e:	681b      	ldr	r3, [r3, #0]
20002f30:	f04f 0200 	mov.w	r2, #0
20002f34:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    /* set default TX time gaurd */
    this_uart->hw_reg->TTG = 0u;
20002f38:	68fb      	ldr	r3, [r7, #12]
20002f3a:	681b      	ldr	r3, [r3, #0]
20002f3c:	f04f 0200 	mov.w	r2, #0
20002f40:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* set default RX timeout */
    this_uart->hw_reg->RTO = 0u;
20002f44:	68fb      	ldr	r3, [r7, #12]
20002f46:	681b      	ldr	r3, [r3, #0]
20002f48:	f04f 0200 	mov.w	r2, #0
20002f4c:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    
    /* 
     * Configure baud rate divisors. This uses the frational baud rate divisor
     * where possible to provide the most accurate baud rat possible.
     */
    config_baud_divisors(this_uart, baud_rate);
20002f50:	68f8      	ldr	r0, [r7, #12]
20002f52:	68b9      	ldr	r1, [r7, #8]
20002f54:	f7ff fe40 	bl	20002bd8 <config_baud_divisors>

    /* set the line control register (bit length, stop bits, parity) */
    this_uart->hw_reg->LCR = line_config;
20002f58:	68fb      	ldr	r3, [r7, #12]
20002f5a:	681b      	ldr	r3, [r3, #0]
20002f5c:	79fa      	ldrb	r2, [r7, #7]
20002f5e:	731a      	strb	r2, [r3, #12]

    /* Instance setup */
    this_uart->baudrate = baud_rate;
20002f60:	68fb      	ldr	r3, [r7, #12]
20002f62:	68ba      	ldr	r2, [r7, #8]
20002f64:	609a      	str	r2, [r3, #8]
    this_uart->lineconfig = line_config;
20002f66:	68fb      	ldr	r3, [r7, #12]
20002f68:	79fa      	ldrb	r2, [r7, #7]
20002f6a:	731a      	strb	r2, [r3, #12]
    this_uart->tx_buff_size = TX_COMPLETE;
20002f6c:	68fb      	ldr	r3, [r7, #12]
20002f6e:	f04f 0200 	mov.w	r2, #0
20002f72:	615a      	str	r2, [r3, #20]
    this_uart->tx_buffer = (const uint8_t *)0;
20002f74:	68fb      	ldr	r3, [r7, #12]
20002f76:	f04f 0200 	mov.w	r2, #0
20002f7a:	611a      	str	r2, [r3, #16]
    this_uart->tx_idx = 0u;
20002f7c:	68fb      	ldr	r3, [r7, #12]
20002f7e:	f04f 0200 	mov.w	r2, #0
20002f82:	619a      	str	r2, [r3, #24]

    /* Default handlers for MSS UART interrupts */
    this_uart->rx_handler       = NULL_HANDLER;
20002f84:	68fb      	ldr	r3, [r7, #12]
20002f86:	f04f 0200 	mov.w	r2, #0
20002f8a:	621a      	str	r2, [r3, #32]
    this_uart->tx_handler       = NULL_HANDLER;
20002f8c:	68fb      	ldr	r3, [r7, #12]
20002f8e:	f04f 0200 	mov.w	r2, #0
20002f92:	625a      	str	r2, [r3, #36]	; 0x24
    this_uart->linests_handler  = NULL_HANDLER;
20002f94:	68fb      	ldr	r3, [r7, #12]
20002f96:	f04f 0200 	mov.w	r2, #0
20002f9a:	61da      	str	r2, [r3, #28]
    this_uart->modemsts_handler = NULL_HANDLER;
20002f9c:	68fb      	ldr	r3, [r7, #12]
20002f9e:	f04f 0200 	mov.w	r2, #0
20002fa2:	629a      	str	r2, [r3, #40]	; 0x28
    this_uart->rto_handler      = NULL_HANDLER;    
20002fa4:	68fb      	ldr	r3, [r7, #12]
20002fa6:	f04f 0200 	mov.w	r2, #0
20002faa:	62da      	str	r2, [r3, #44]	; 0x2c
    this_uart->nack_handler     = NULL_HANDLER;   
20002fac:	68fb      	ldr	r3, [r7, #12]
20002fae:	f04f 0200 	mov.w	r2, #0
20002fb2:	631a      	str	r2, [r3, #48]	; 0x30
    this_uart->pid_pei_handler  = NULL_HANDLER;
20002fb4:	68fb      	ldr	r3, [r7, #12]
20002fb6:	f04f 0200 	mov.w	r2, #0
20002fba:	635a      	str	r2, [r3, #52]	; 0x34
    this_uart->break_handler    = NULL_HANDLER;    
20002fbc:	68fb      	ldr	r3, [r7, #12]
20002fbe:	f04f 0200 	mov.w	r2, #0
20002fc2:	639a      	str	r2, [r3, #56]	; 0x38
    this_uart->sync_handler     = NULL_HANDLER;   
20002fc4:	68fb      	ldr	r3, [r7, #12]
20002fc6:	f04f 0200 	mov.w	r2, #0
20002fca:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the sticky status */
    this_uart->status = 0u;
20002fcc:	68fb      	ldr	r3, [r7, #12]
20002fce:	f04f 0200 	mov.w	r2, #0
20002fd2:	735a      	strb	r2, [r3, #13]
}
20002fd4:	f107 0710 	add.w	r7, r7, #16
20002fd8:	46bd      	mov	sp, r7
20002fda:	bd80      	pop	{r7, pc}

20002fdc <MSS_UART_isr>:
static void
MSS_UART_isr
(
    mss_uart_instance_t * this_uart
)
{
20002fdc:	b580      	push	{r7, lr}
20002fde:	b084      	sub	sp, #16
20002fe0:	af00      	add	r7, sp, #0
20002fe2:	6078      	str	r0, [r7, #4]
    uint8_t iirf;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20002fe4:	687a      	ldr	r2, [r7, #4]
20002fe6:	f244 2394 	movw	r3, #17044	; 0x4294
20002fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002fee:	429a      	cmp	r2, r3
20002ff0:	d007      	beq.n	20003002 <MSS_UART_isr+0x26>
20002ff2:	687a      	ldr	r2, [r7, #4]
20002ff4:	f244 2354 	movw	r3, #16980	; 0x4254
20002ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
20002ffc:	429a      	cmp	r2, r3
20002ffe:	d000      	beq.n	20003002 <MSS_UART_isr+0x26>
20003000:	be00      	bkpt	0x0000

    if((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1))
20003002:	687a      	ldr	r2, [r7, #4]
20003004:	f244 2394 	movw	r3, #17044	; 0x4294
20003008:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000300c:	429a      	cmp	r2, r3
2000300e:	d007      	beq.n	20003020 <MSS_UART_isr+0x44>
20003010:	687a      	ldr	r2, [r7, #4]
20003012:	f244 2354 	movw	r3, #16980	; 0x4254
20003016:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000301a:	429a      	cmp	r2, r3
2000301c:	f040 80ef 	bne.w	200031fe <MSS_UART_isr+0x222>
    {
        iirf = this_uart->hw_reg->IIR & IIRF_MASK;
20003020:	687b      	ldr	r3, [r7, #4]
20003022:	681b      	ldr	r3, [r3, #0]
20003024:	7a1b      	ldrb	r3, [r3, #8]
20003026:	b2db      	uxtb	r3, r3
20003028:	f003 030f 	and.w	r3, r3, #15
2000302c:	73fb      	strb	r3, [r7, #15]

        switch (iirf)
2000302e:	7bfb      	ldrb	r3, [r7, #15]
20003030:	2b0c      	cmp	r3, #12
20003032:	f200 80d7 	bhi.w	200031e4 <MSS_UART_isr+0x208>
20003036:	a201      	add	r2, pc, #4	; (adr r2, 2000303c <MSS_UART_isr+0x60>)
20003038:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000303c:	20003071 	.word	0x20003071
20003040:	200031e5 	.word	0x200031e5
20003044:	2000308f 	.word	0x2000308f
20003048:	200030e9 	.word	0x200030e9
2000304c:	200030ad 	.word	0x200030ad
20003050:	200031e5 	.word	0x200031e5
20003054:	200030cb 	.word	0x200030cb
20003058:	200031e5 	.word	0x200031e5
2000305c:	200031e5 	.word	0x200031e5
20003060:	200031e5 	.word	0x200031e5
20003064:	200031e5 	.word	0x200031e5
20003068:	200031e5 	.word	0x200031e5
2000306c:	200030ad 	.word	0x200030ad
        {
            case IIRF_MODEM_STATUS:  /* Modem status interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->modemsts_handler);
20003070:	687b      	ldr	r3, [r7, #4]
20003072:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003074:	2b00      	cmp	r3, #0
20003076:	d100      	bne.n	2000307a <MSS_UART_isr+0x9e>
20003078:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->modemsts_handler)
2000307a:	687b      	ldr	r3, [r7, #4]
2000307c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000307e:	2b00      	cmp	r3, #0
20003080:	f000 80b2 	beq.w	200031e8 <MSS_UART_isr+0x20c>
                {
                   (*(this_uart->modemsts_handler))(this_uart);
20003084:	687b      	ldr	r3, [r7, #4]
20003086:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003088:	6878      	ldr	r0, [r7, #4]
2000308a:	4798      	blx	r3
                }
            }
            break;
2000308c:	e0b7      	b.n	200031fe <MSS_UART_isr+0x222>

            case IIRF_THRE: /* Transmitter Holding Register Empty */
            {
                ASSERT(NULL_HANDLER != this_uart->tx_handler);
2000308e:	687b      	ldr	r3, [r7, #4]
20003090:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003092:	2b00      	cmp	r3, #0
20003094:	d100      	bne.n	20003098 <MSS_UART_isr+0xbc>
20003096:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->tx_handler)
20003098:	687b      	ldr	r3, [r7, #4]
2000309a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000309c:	2b00      	cmp	r3, #0
2000309e:	f000 80a5 	beq.w	200031ec <MSS_UART_isr+0x210>
                {
                    (*(this_uart->tx_handler))(this_uart);
200030a2:	687b      	ldr	r3, [r7, #4]
200030a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200030a6:	6878      	ldr	r0, [r7, #4]
200030a8:	4798      	blx	r3
                }
            }
            break;
200030aa:	e0a8      	b.n	200031fe <MSS_UART_isr+0x222>

            case IIRF_RX_DATA:      /* Received Data Available */
            case IIRF_DATA_TIMEOUT: /* Received Data Timed-out */
            {
                ASSERT(NULL_HANDLER != this_uart->rx_handler);
200030ac:	687b      	ldr	r3, [r7, #4]
200030ae:	6a1b      	ldr	r3, [r3, #32]
200030b0:	2b00      	cmp	r3, #0
200030b2:	d100      	bne.n	200030b6 <MSS_UART_isr+0xda>
200030b4:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->rx_handler)
200030b6:	687b      	ldr	r3, [r7, #4]
200030b8:	6a1b      	ldr	r3, [r3, #32]
200030ba:	2b00      	cmp	r3, #0
200030bc:	f000 8098 	beq.w	200031f0 <MSS_UART_isr+0x214>
                {
                    (*(this_uart->rx_handler))(this_uart);
200030c0:	687b      	ldr	r3, [r7, #4]
200030c2:	6a1b      	ldr	r3, [r3, #32]
200030c4:	6878      	ldr	r0, [r7, #4]
200030c6:	4798      	blx	r3
                }
            }
            break;
200030c8:	e099      	b.n	200031fe <MSS_UART_isr+0x222>

            case IIRF_RX_LINE_STATUS:  /* Line Status Interrupt */
            {
                ASSERT(NULL_HANDLER != this_uart->linests_handler);
200030ca:	687b      	ldr	r3, [r7, #4]
200030cc:	69db      	ldr	r3, [r3, #28]
200030ce:	2b00      	cmp	r3, #0
200030d0:	d100      	bne.n	200030d4 <MSS_UART_isr+0xf8>
200030d2:	be00      	bkpt	0x0000
                if(NULL_HANDLER != this_uart->linests_handler)
200030d4:	687b      	ldr	r3, [r7, #4]
200030d6:	69db      	ldr	r3, [r3, #28]
200030d8:	2b00      	cmp	r3, #0
200030da:	f000 808b 	beq.w	200031f4 <MSS_UART_isr+0x218>
                {
                   (*(this_uart->linests_handler))(this_uart);
200030de:	687b      	ldr	r3, [r7, #4]
200030e0:	69db      	ldr	r3, [r3, #28]
200030e2:	6878      	ldr	r0, [r7, #4]
200030e4:	4798      	blx	r3
                }
            }
            break;
200030e6:	e08a      	b.n	200031fe <MSS_UART_isr+0x222>
            case IIRF_MMI:
            {
                /* Identify multimode interrupts and handle */

                /* Receiver time-out interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ERTOI))
200030e8:	687b      	ldr	r3, [r7, #4]
200030ea:	681b      	ldr	r3, [r3, #0]
200030ec:	f103 0328 	add.w	r3, r3, #40	; 0x28
200030f0:	4618      	mov	r0, r3
200030f2:	f04f 0100 	mov.w	r1, #0
200030f6:	f7ff fba3 	bl	20002840 <read_bit_reg8>
200030fa:	4603      	mov	r3, r0
200030fc:	2b00      	cmp	r3, #0
200030fe:	d00c      	beq.n	2000311a <MSS_UART_isr+0x13e>
                {
                    ASSERT(NULL_HANDLER != this_uart->rto_handler);
20003100:	687b      	ldr	r3, [r7, #4]
20003102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003104:	2b00      	cmp	r3, #0
20003106:	d100      	bne.n	2000310a <MSS_UART_isr+0x12e>
20003108:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->rto_handler)
2000310a:	687b      	ldr	r3, [r7, #4]
2000310c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000310e:	2b00      	cmp	r3, #0
20003110:	d003      	beq.n	2000311a <MSS_UART_isr+0x13e>
                    {
                        (*(this_uart->rto_handler))(this_uart);
20003112:	687b      	ldr	r3, [r7, #4]
20003114:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003116:	6878      	ldr	r0, [r7, #4]
20003118:	4798      	blx	r3
                    }
                }
                /* NACK interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ENACKI))
2000311a:	687b      	ldr	r3, [r7, #4]
2000311c:	681b      	ldr	r3, [r3, #0]
2000311e:	f103 0328 	add.w	r3, r3, #40	; 0x28
20003122:	4618      	mov	r0, r3
20003124:	f04f 0101 	mov.w	r1, #1
20003128:	f7ff fb8a 	bl	20002840 <read_bit_reg8>
2000312c:	4603      	mov	r3, r0
2000312e:	2b00      	cmp	r3, #0
20003130:	d00c      	beq.n	2000314c <MSS_UART_isr+0x170>
                {
                    ASSERT(NULL_HANDLER != this_uart->nack_handler);
20003132:	687b      	ldr	r3, [r7, #4]
20003134:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003136:	2b00      	cmp	r3, #0
20003138:	d100      	bne.n	2000313c <MSS_UART_isr+0x160>
2000313a:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->nack_handler)
2000313c:	687b      	ldr	r3, [r7, #4]
2000313e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003140:	2b00      	cmp	r3, #0
20003142:	d003      	beq.n	2000314c <MSS_UART_isr+0x170>
                    {
                        (*(this_uart->nack_handler))(this_uart);
20003144:	687b      	ldr	r3, [r7, #4]
20003146:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003148:	6878      	ldr	r0, [r7, #4]
2000314a:	4798      	blx	r3
                    }
                }

                /* PID parity error interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,EPID_PEI))
2000314c:	687b      	ldr	r3, [r7, #4]
2000314e:	681b      	ldr	r3, [r3, #0]
20003150:	f103 0328 	add.w	r3, r3, #40	; 0x28
20003154:	4618      	mov	r0, r3
20003156:	f04f 0102 	mov.w	r1, #2
2000315a:	f7ff fb71 	bl	20002840 <read_bit_reg8>
2000315e:	4603      	mov	r3, r0
20003160:	2b00      	cmp	r3, #0
20003162:	d00c      	beq.n	2000317e <MSS_UART_isr+0x1a2>
                {
                    ASSERT(NULL_HANDLER != this_uart->pid_pei_handler);
20003164:	687b      	ldr	r3, [r7, #4]
20003166:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20003168:	2b00      	cmp	r3, #0
2000316a:	d100      	bne.n	2000316e <MSS_UART_isr+0x192>
2000316c:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->pid_pei_handler)
2000316e:	687b      	ldr	r3, [r7, #4]
20003170:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20003172:	2b00      	cmp	r3, #0
20003174:	d003      	beq.n	2000317e <MSS_UART_isr+0x1a2>
                    {
                        (*(this_uart->pid_pei_handler))(this_uart);
20003176:	687b      	ldr	r3, [r7, #4]
20003178:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000317a:	6878      	ldr	r0, [r7, #4]
2000317c:	4798      	blx	r3
                    }
                }

                /* LIN break detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINBI))
2000317e:	687b      	ldr	r3, [r7, #4]
20003180:	681b      	ldr	r3, [r3, #0]
20003182:	f103 0328 	add.w	r3, r3, #40	; 0x28
20003186:	4618      	mov	r0, r3
20003188:	f04f 0103 	mov.w	r1, #3
2000318c:	f7ff fb58 	bl	20002840 <read_bit_reg8>
20003190:	4603      	mov	r3, r0
20003192:	2b00      	cmp	r3, #0
20003194:	d00c      	beq.n	200031b0 <MSS_UART_isr+0x1d4>
                {
                    ASSERT(NULL_HANDLER != this_uart->break_handler);
20003196:	687b      	ldr	r3, [r7, #4]
20003198:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000319a:	2b00      	cmp	r3, #0
2000319c:	d100      	bne.n	200031a0 <MSS_UART_isr+0x1c4>
2000319e:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->break_handler)
200031a0:	687b      	ldr	r3, [r7, #4]
200031a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200031a4:	2b00      	cmp	r3, #0
200031a6:	d003      	beq.n	200031b0 <MSS_UART_isr+0x1d4>
                    {
                        (*(this_uart->break_handler))(this_uart);
200031a8:	687b      	ldr	r3, [r7, #4]
200031aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200031ac:	6878      	ldr	r0, [r7, #4]
200031ae:	4798      	blx	r3
                    }
                }

                /* LIN Sync detection interrupt */
                if(read_bit_reg8(&this_uart->hw_reg->IIM,ELINSI))
200031b0:	687b      	ldr	r3, [r7, #4]
200031b2:	681b      	ldr	r3, [r3, #0]
200031b4:	f103 0328 	add.w	r3, r3, #40	; 0x28
200031b8:	4618      	mov	r0, r3
200031ba:	f04f 0104 	mov.w	r1, #4
200031be:	f7ff fb3f 	bl	20002840 <read_bit_reg8>
200031c2:	4603      	mov	r3, r0
200031c4:	2b00      	cmp	r3, #0
200031c6:	d017      	beq.n	200031f8 <MSS_UART_isr+0x21c>
                {
                    ASSERT(NULL_HANDLER != this_uart->sync_handler);
200031c8:	687b      	ldr	r3, [r7, #4]
200031ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200031cc:	2b00      	cmp	r3, #0
200031ce:	d100      	bne.n	200031d2 <MSS_UART_isr+0x1f6>
200031d0:	be00      	bkpt	0x0000
                    if(NULL_HANDLER != this_uart->sync_handler)
200031d2:	687b      	ldr	r3, [r7, #4]
200031d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200031d6:	2b00      	cmp	r3, #0
200031d8:	d010      	beq.n	200031fc <MSS_UART_isr+0x220>
                    {
                        (*(this_uart->sync_handler))(this_uart);
200031da:	687b      	ldr	r3, [r7, #4]
200031dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200031de:	6878      	ldr	r0, [r7, #4]
200031e0:	4798      	blx	r3
                    }
                }
                break;
200031e2:	e00c      	b.n	200031fe <MSS_UART_isr+0x222>
            }

            default:
            {
                ASSERT(INVALID_INTERRUPT);
200031e4:	be00      	bkpt	0x0000
200031e6:	e00a      	b.n	200031fe <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->modemsts_handler)
                {
                   (*(this_uart->modemsts_handler))(this_uart);
                }
            }
            break;
200031e8:	bf00      	nop
200031ea:	e008      	b.n	200031fe <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->tx_handler)
                {
                    (*(this_uart->tx_handler))(this_uart);
                }
            }
            break;
200031ec:	bf00      	nop
200031ee:	e006      	b.n	200031fe <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->rx_handler)
                {
                    (*(this_uart->rx_handler))(this_uart);
                }
            }
            break;
200031f0:	bf00      	nop
200031f2:	e004      	b.n	200031fe <MSS_UART_isr+0x222>
                if(NULL_HANDLER != this_uart->linests_handler)
                {
                   (*(this_uart->linests_handler))(this_uart);
                }
            }
            break;
200031f4:	bf00      	nop
200031f6:	e002      	b.n	200031fe <MSS_UART_isr+0x222>
                    if(NULL_HANDLER != this_uart->sync_handler)
                    {
                        (*(this_uart->sync_handler))(this_uart);
                    }
                }
                break;
200031f8:	bf00      	nop
200031fa:	e000      	b.n	200031fe <MSS_UART_isr+0x222>
200031fc:	bf00      	nop
                ASSERT(INVALID_INTERRUPT);
            }
            break;
        }
    }
}
200031fe:	f107 0710 	add.w	r7, r7, #16
20003202:	46bd      	mov	sp, r7
20003204:	bd80      	pop	{r7, pc}
20003206:	bf00      	nop

20003208 <default_tx_handler>:
static void
default_tx_handler
(
    mss_uart_instance_t * this_uart
)
{
20003208:	b580      	push	{r7, lr}
2000320a:	b086      	sub	sp, #24
2000320c:	af00      	add	r7, sp, #0
2000320e:	6078      	str	r0, [r7, #4]
    uint8_t status;

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
20003210:	687a      	ldr	r2, [r7, #4]
20003212:	f244 2394 	movw	r3, #17044	; 0x4294
20003216:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000321a:	429a      	cmp	r2, r3
2000321c:	d007      	beq.n	2000322e <default_tx_handler+0x26>
2000321e:	687a      	ldr	r2, [r7, #4]
20003220:	f244 2354 	movw	r3, #16980	; 0x4254
20003224:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003228:	429a      	cmp	r2, r3
2000322a:	d000      	beq.n	2000322e <default_tx_handler+0x26>
2000322c:	be00      	bkpt	0x0000
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
2000322e:	687b      	ldr	r3, [r7, #4]
20003230:	691b      	ldr	r3, [r3, #16]
20003232:	2b00      	cmp	r3, #0
20003234:	d100      	bne.n	20003238 <default_tx_handler+0x30>
20003236:	be00      	bkpt	0x0000
    ASSERT(0u < this_uart->tx_buff_size);
20003238:	687b      	ldr	r3, [r7, #4]
2000323a:	695b      	ldr	r3, [r3, #20]
2000323c:	2b00      	cmp	r3, #0
2000323e:	d100      	bne.n	20003242 <default_tx_handler+0x3a>
20003240:	be00      	bkpt	0x0000

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20003242:	687a      	ldr	r2, [r7, #4]
20003244:	f244 2394 	movw	r3, #17044	; 0x4294
20003248:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000324c:	429a      	cmp	r2, r3
2000324e:	d006      	beq.n	2000325e <default_tx_handler+0x56>
20003250:	687a      	ldr	r2, [r7, #4]
20003252:	f244 2354 	movw	r3, #16980	; 0x4254
20003256:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000325a:	429a      	cmp	r2, r3
2000325c:	d155      	bne.n	2000330a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
2000325e:	687b      	ldr	r3, [r7, #4]
20003260:	691b      	ldr	r3, [r3, #16]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
20003262:	2b00      	cmp	r3, #0
20003264:	d051      	beq.n	2000330a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
20003266:	687b      	ldr	r3, [r7, #4]
20003268:	695b      	ldr	r3, [r3, #20]

    ASSERT((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1));
    ASSERT(( (uint8_t *)0 ) != this_uart->tx_buffer);
    ASSERT(0u < this_uart->tx_buff_size);

    if(((this_uart == &g_mss_uart0) || (this_uart == &g_mss_uart1)) &&
2000326a:	2b00      	cmp	r3, #0
2000326c:	d04d      	beq.n	2000330a <default_tx_handler+0x102>
       (((uint8_t *)0 ) != this_uart->tx_buffer) &&
       (0u < this_uart->tx_buff_size))
    {
        /* Read the Line Status Register and update the sticky record. */
        status = this_uart->hw_reg->LSR;
2000326e:	687b      	ldr	r3, [r7, #4]
20003270:	681b      	ldr	r3, [r3, #0]
20003272:	7d1b      	ldrb	r3, [r3, #20]
20003274:	72fb      	strb	r3, [r7, #11]
        this_uart->status |= status;
20003276:	687b      	ldr	r3, [r7, #4]
20003278:	7b5a      	ldrb	r2, [r3, #13]
2000327a:	7afb      	ldrb	r3, [r7, #11]
2000327c:	ea42 0303 	orr.w	r3, r2, r3
20003280:	b2da      	uxtb	r2, r3
20003282:	687b      	ldr	r3, [r7, #4]
20003284:	735a      	strb	r2, [r3, #13]

        /*
         * This function should only be called as a result of a THRE interrupt.
         * Verify that this is true before proceeding to transmit data.
         */
        if(status & MSS_UART_THRE)
20003286:	7afb      	ldrb	r3, [r7, #11]
20003288:	f003 0320 	and.w	r3, r3, #32
2000328c:	2b00      	cmp	r3, #0
2000328e:	d029      	beq.n	200032e4 <default_tx_handler+0xdc>
        {
            uint32_t i;
            uint32_t fill_size = TX_FIFO_SIZE;
20003290:	f04f 0310 	mov.w	r3, #16
20003294:	613b      	str	r3, [r7, #16]
            uint32_t tx_remain = this_uart->tx_buff_size - this_uart->tx_idx;
20003296:	687b      	ldr	r3, [r7, #4]
20003298:	695a      	ldr	r2, [r3, #20]
2000329a:	687b      	ldr	r3, [r7, #4]
2000329c:	699b      	ldr	r3, [r3, #24]
2000329e:	ebc3 0302 	rsb	r3, r3, r2
200032a2:	617b      	str	r3, [r7, #20]

            /* Calculate the number of bytes to transmit. */
            if(tx_remain < TX_FIFO_SIZE)
200032a4:	697b      	ldr	r3, [r7, #20]
200032a6:	2b0f      	cmp	r3, #15
200032a8:	d801      	bhi.n	200032ae <default_tx_handler+0xa6>
            {
                fill_size = tx_remain;
200032aa:	697b      	ldr	r3, [r7, #20]
200032ac:	613b      	str	r3, [r7, #16]
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
200032ae:	f04f 0300 	mov.w	r3, #0
200032b2:	60fb      	str	r3, [r7, #12]
200032b4:	e012      	b.n	200032dc <default_tx_handler+0xd4>
            {
                /* Send next character in the buffer. */
                this_uart->hw_reg->THR = this_uart->tx_buffer[this_uart->tx_idx];
200032b6:	687b      	ldr	r3, [r7, #4]
200032b8:	681b      	ldr	r3, [r3, #0]
200032ba:	687a      	ldr	r2, [r7, #4]
200032bc:	6911      	ldr	r1, [r2, #16]
200032be:	687a      	ldr	r2, [r7, #4]
200032c0:	6992      	ldr	r2, [r2, #24]
200032c2:	440a      	add	r2, r1
200032c4:	7812      	ldrb	r2, [r2, #0]
200032c6:	701a      	strb	r2, [r3, #0]
                ++this_uart->tx_idx;
200032c8:	687b      	ldr	r3, [r7, #4]
200032ca:	699b      	ldr	r3, [r3, #24]
200032cc:	f103 0201 	add.w	r2, r3, #1
200032d0:	687b      	ldr	r3, [r7, #4]
200032d2:	619a      	str	r2, [r3, #24]
            {
                fill_size = tx_remain;
            }

            /* Fill the TX FIFO with the calculated the number of bytes. */
            for(i = 0u; i < fill_size; ++i)
200032d4:	68fb      	ldr	r3, [r7, #12]
200032d6:	f103 0301 	add.w	r3, r3, #1
200032da:	60fb      	str	r3, [r7, #12]
200032dc:	68fa      	ldr	r2, [r7, #12]
200032de:	693b      	ldr	r3, [r7, #16]
200032e0:	429a      	cmp	r2, r3
200032e2:	d3e8      	bcc.n	200032b6 <default_tx_handler+0xae>
                ++this_uart->tx_idx;
            }
        }

        /* Flag Tx as complete if all data has been pushed into the Tx FIFO. */
        if(this_uart->tx_idx == this_uart->tx_buff_size)
200032e4:	687b      	ldr	r3, [r7, #4]
200032e6:	699a      	ldr	r2, [r3, #24]
200032e8:	687b      	ldr	r3, [r7, #4]
200032ea:	695b      	ldr	r3, [r3, #20]
200032ec:	429a      	cmp	r2, r3
200032ee:	d10c      	bne.n	2000330a <default_tx_handler+0x102>
        {
            this_uart->tx_buff_size = TX_COMPLETE;
200032f0:	687b      	ldr	r3, [r7, #4]
200032f2:	f04f 0200 	mov.w	r2, #0
200032f6:	615a      	str	r2, [r3, #20]
            /* disables TX interrupt */
            clear_bit_reg8(&this_uart->hw_reg->IER,ETBEI);
200032f8:	687b      	ldr	r3, [r7, #4]
200032fa:	681b      	ldr	r3, [r3, #0]
200032fc:	f103 0304 	add.w	r3, r3, #4
20003300:	4618      	mov	r0, r3
20003302:	f04f 0101 	mov.w	r1, #1
20003306:	f7ff fa7b 	bl	20002800 <clear_bit_reg8>
        }
    }
}
2000330a:	f107 0718 	add.w	r7, r7, #24
2000330e:	46bd      	mov	sp, r7
20003310:	bd80      	pop	{r7, pc}
20003312:	bf00      	nop

20003314 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
20003314:	b480      	push	{r7}
20003316:	b083      	sub	sp, #12
20003318:	af00      	add	r7, sp, #0
2000331a:	4603      	mov	r3, r0
2000331c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
2000331e:	f24e 1300 	movw	r3, #57600	; 0xe100
20003322:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003326:	f997 2007 	ldrsb.w	r2, [r7, #7]
2000332a:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000332e:	79f9      	ldrb	r1, [r7, #7]
20003330:	f001 011f 	and.w	r1, r1, #31
20003334:	f04f 0001 	mov.w	r0, #1
20003338:	fa00 f101 	lsl.w	r1, r0, r1
2000333c:	f102 0220 	add.w	r2, r2, #32
20003340:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003344:	f107 070c 	add.w	r7, r7, #12
20003348:	46bd      	mov	sp, r7
2000334a:	bc80      	pop	{r7}
2000334c:	4770      	bx	lr
2000334e:	bf00      	nop

20003350 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20003350:	b480      	push	{r7}
20003352:	b083      	sub	sp, #12
20003354:	af00      	add	r7, sp, #0
20003356:	4603      	mov	r3, r0
20003358:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
2000335a:	f24e 1300 	movw	r3, #57600	; 0xe100
2000335e:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003362:	f997 2007 	ldrsb.w	r2, [r7, #7]
20003366:	ea4f 1252 	mov.w	r2, r2, lsr #5
2000336a:	79f9      	ldrb	r1, [r7, #7]
2000336c:	f001 011f 	and.w	r1, r1, #31
20003370:	f04f 0001 	mov.w	r0, #1
20003374:	fa00 f101 	lsl.w	r1, r0, r1
20003378:	f102 0260 	add.w	r2, r2, #96	; 0x60
2000337c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
20003380:	f107 070c 	add.w	r7, r7, #12
20003384:	46bd      	mov	sp, r7
20003386:	bc80      	pop	{r7}
20003388:	4770      	bx	lr
2000338a:	bf00      	nop

2000338c <MSS_GPIO_init>:
/*-------------------------------------------------------------------------*//**
 * MSS_GPIO_init
 * See "mss_gpio.h" for details of how to use this function.
 */
void MSS_GPIO_init( void )
{
2000338c:	b580      	push	{r7, lr}
2000338e:	b082      	sub	sp, #8
20003390:	af00      	add	r7, sp, #0
    uint32_t inc;
    
    /* reset MSS GPIO hardware */
    SYSREG->SOFT_RST_CR |= SYSREG_GPIO_SOFTRESET_MASK;
20003392:	f248 0300 	movw	r3, #32768	; 0x8000
20003396:	f2c4 0303 	movt	r3, #16387	; 0x4003
2000339a:	f248 0200 	movw	r2, #32768	; 0x8000
2000339e:	f2c4 0203 	movt	r2, #16387	; 0x4003
200033a2:	6c92      	ldr	r2, [r2, #72]	; 0x48
200033a4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
200033a8:	649a      	str	r2, [r3, #72]	; 0x48
    SYSREG->SOFT_RST_CR |= (SYSREG_GPIO_7_0_SOFTRESET_MASK |
200033aa:	f248 0300 	movw	r3, #32768	; 0x8000
200033ae:	f2c4 0303 	movt	r3, #16387	; 0x4003
200033b2:	f248 0200 	movw	r2, #32768	; 0x8000
200033b6:	f2c4 0203 	movt	r2, #16387	; 0x4003
200033ba:	6c92      	ldr	r2, [r2, #72]	; 0x48
200033bc:	f042 72f0 	orr.w	r2, r2, #31457280	; 0x1e00000
200033c0:	649a      	str	r2, [r3, #72]	; 0x48
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
200033c2:	f04f 0300 	mov.w	r3, #0
200033c6:	607b      	str	r3, [r7, #4]
200033c8:	e017      	b.n	200033fa <MSS_GPIO_init+0x6e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
200033ca:	687a      	ldr	r2, [r7, #4]
200033cc:	f244 13e8 	movw	r3, #16872	; 0x41e8
200033d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
200033d4:	5c9b      	ldrb	r3, [r3, r2]
200033d6:	b25b      	sxtb	r3, r3
200033d8:	4618      	mov	r0, r3
200033da:	f7ff ff9b 	bl	20003314 <NVIC_DisableIRQ>
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
200033de:	687a      	ldr	r2, [r7, #4]
200033e0:	f244 13e8 	movw	r3, #16872	; 0x41e8
200033e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
200033e8:	5c9b      	ldrb	r3, [r3, r2]
200033ea:	b25b      	sxtb	r3, r3
200033ec:	4618      	mov	r0, r3
200033ee:	f7ff ffaf 	bl	20003350 <NVIC_ClearPendingIRQ>
                            SYSREG_GPIO_15_8_SOFTRESET_MASK |
                            SYSREG_GPIO_23_16_SOFTRESET_MASK |
                            SYSREG_GPIO_31_24_SOFTRESET_MASK);
                            
    /* Clear any previously pended MSS GPIO interrupt */
    for(inc = 0U; inc < NB_OF_GPIO; ++inc)
200033f2:	687b      	ldr	r3, [r7, #4]
200033f4:	f103 0301 	add.w	r3, r3, #1
200033f8:	607b      	str	r3, [r7, #4]
200033fa:	687b      	ldr	r3, [r7, #4]
200033fc:	2b1f      	cmp	r3, #31
200033fe:	d9e4      	bls.n	200033ca <MSS_GPIO_init+0x3e>
    {
        NVIC_DisableIRQ(g_gpio_irqn_lut[inc]);
        NVIC_ClearPendingIRQ(g_gpio_irqn_lut[inc]);
    }
    /* Take MSS GPIO hardware out of reset. */
    SYSREG->SOFT_RST_CR &= ~(SYSREG_GPIO_7_0_SOFTRESET_MASK |
20003400:	f248 0300 	movw	r3, #32768	; 0x8000
20003404:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003408:	f248 0200 	movw	r2, #32768	; 0x8000
2000340c:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003410:	6c92      	ldr	r2, [r2, #72]	; 0x48
20003412:	f022 72f0 	bic.w	r2, r2, #31457280	; 0x1e00000
20003416:	649a      	str	r2, [r3, #72]	; 0x48
                             SYSREG_GPIO_15_8_SOFTRESET_MASK |
                             SYSREG_GPIO_23_16_SOFTRESET_MASK |
                             SYSREG_GPIO_31_24_SOFTRESET_MASK);
    SYSREG->SOFT_RST_CR &= ~SYSREG_GPIO_SOFTRESET_MASK;
20003418:	f248 0300 	movw	r3, #32768	; 0x8000
2000341c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003420:	f248 0200 	movw	r2, #32768	; 0x8000
20003424:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003428:	6c92      	ldr	r2, [r2, #72]	; 0x48
2000342a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
2000342e:	649a      	str	r2, [r3, #72]	; 0x48
}
20003430:	f107 0708 	add.w	r7, r7, #8
20003434:	46bd      	mov	sp, r7
20003436:	bd80      	pop	{r7, pc}

20003438 <MSS_GPIO_config>:
void MSS_GPIO_config
(
    mss_gpio_id_t port_id,
    uint32_t config
)
{
20003438:	b480      	push	{r7}
2000343a:	b085      	sub	sp, #20
2000343c:	af00      	add	r7, sp, #0
2000343e:	4603      	mov	r3, r0
20003440:	6039      	str	r1, [r7, #0]
20003442:	71fb      	strb	r3, [r7, #7]
    uint32_t gpio_idx = (uint32_t)port_id;
20003444:	79fb      	ldrb	r3, [r7, #7]
20003446:	60fb      	str	r3, [r7, #12]
    
    ASSERT(gpio_idx < NB_OF_GPIO);
20003448:	68fb      	ldr	r3, [r7, #12]
2000344a:	2b1f      	cmp	r3, #31
2000344c:	d900      	bls.n	20003450 <MSS_GPIO_config+0x18>
2000344e:	be00      	bkpt	0x0000

    if(gpio_idx < NB_OF_GPIO)
20003450:	68fb      	ldr	r3, [r7, #12]
20003452:	2b1f      	cmp	r3, #31
20003454:	d808      	bhi.n	20003468 <MSS_GPIO_config+0x30>
    {
        *(g_config_reg_lut[gpio_idx]) = config;
20003456:	68fa      	ldr	r2, [r7, #12]
20003458:	f244 1368 	movw	r3, #16744	; 0x4168
2000345c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003460:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20003464:	683a      	ldr	r2, [r7, #0]
20003466:	601a      	str	r2, [r3, #0]
    }
}
20003468:	f107 0714 	add.w	r7, r7, #20
2000346c:	46bd      	mov	sp, r7
2000346e:	bc80      	pop	{r7}
20003470:	4770      	bx	lr
20003472:	bf00      	nop

20003474 <SystemInit>:

/***************************************************************************//**
 * See system_m2sxxx.h for details.
 */
void SystemInit(void)
{
20003474:	b580      	push	{r7, lr}
20003476:	af00      	add	r7, sp, #0
     */
#if (MSS_SYS_FACC_INIT_BY_CORTEX == 1)
    complete_clock_config();
#endif

    silicon_workarounds();
20003478:	f000 f936 	bl	200036e8 <silicon_workarounds>
    /*--------------------------------------------------------------------------
     * Set STKALIGN to ensure exception stacking starts on 8 bytes address
     * boundary. This ensures compliance with the "Procedure Call Standards for
     * the ARM Architecture" (AAPCS).
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
2000347c:	f64e 5300 	movw	r3, #60672	; 0xed00
20003480:	f2ce 0300 	movt	r3, #57344	; 0xe000
20003484:	f64e 5200 	movw	r2, #60672	; 0xed00
20003488:	f2ce 0200 	movt	r2, #57344	; 0xe000
2000348c:	6952      	ldr	r2, [r2, #20]
2000348e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
20003492:	615a      	str	r2, [r3, #20]
#endif

    /*--------------------------------------------------------------------------
     * Call user defined configuration function.
     */
    mscc_post_hw_cfg_init();
20003494:	f7fc ffce 	bl	20000434 <mscc_post_hw_cfg_init>
    do
    {
        init_done = CORE_SF2_CFG->INIT_DONE & INIT_DONE_MASK;
    } while (0u == init_done);
#endif
}
20003498:	bd80      	pop	{r7, pc}
2000349a:	bf00      	nop

2000349c <SystemCoreClockUpdate>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
2000349c:	b580      	push	{r7, lr}
2000349e:	b088      	sub	sp, #32
200034a0:	af00      	add	r7, sp, #0
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
200034a2:	f248 0300 	movw	r3, #32768	; 0x8000
200034a6:	f2c4 0303 	movt	r3, #16387	; 0x4003
200034aa:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200034ae:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
200034b2:	60fb      	str	r3, [r7, #12]

    if(0u == controller_pll_init)
200034b4:	68fb      	ldr	r3, [r7, #12]
200034b6:	2b00      	cmp	r3, #0
200034b8:	f040 808b 	bne.w	200035d2 <SystemCoreClockUpdate+0x136>
    {
        /* Normal operations. */
        uint32_t global_mux_sel;

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
200034bc:	f248 0300 	movw	r3, #32768	; 0x8000
200034c0:	f2c4 0303 	movt	r3, #16387	; 0x4003
200034c4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200034c8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
200034cc:	617b      	str	r3, [r7, #20]
        if(0u == global_mux_sel)
200034ce:	697b      	ldr	r3, [r7, #20]
200034d0:	2b00      	cmp	r3, #0
200034d2:	d13f      	bne.n	20003554 <SystemCoreClockUpdate+0xb8>
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
200034d4:	f244 2334 	movw	r3, #16948	; 0x4234
200034d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
200034dc:	f64b 7280 	movw	r2, #49024	; 0xbf80
200034e0:	f6c0 0276 	movt	r2, #2166	; 0x876
200034e4:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
200034e6:	f244 2338 	movw	r3, #16952	; 0x4238
200034ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
200034ee:	f645 72c0 	movw	r2, #24512	; 0x5fc0
200034f2:	f2c0 423b 	movt	r2, #1083	; 0x43b
200034f6:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
200034f8:	f244 233c 	movw	r3, #16956	; 0x423c
200034fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003500:	f645 72c0 	movw	r2, #24512	; 0x5fc0
20003504:	f2c0 423b 	movt	r2, #1083	; 0x43b
20003508:	601a      	str	r2, [r3, #0]
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
2000350a:	f244 2340 	movw	r3, #16960	; 0x4240
2000350e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003512:	f64a 72e0 	movw	r2, #45024	; 0xafe0
20003516:	f2c0 221d 	movt	r2, #541	; 0x21d
2000351a:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
2000351c:	f244 2344 	movw	r3, #16964	; 0x4244
20003520:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003524:	f645 72c0 	movw	r2, #24512	; 0x5fc0
20003528:	f2c0 423b 	movt	r2, #1083	; 0x43b
2000352c:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
2000352e:	f244 2348 	movw	r3, #16968	; 0x4248
20003532:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003536:	f64b 7280 	movw	r2, #49024	; 0xbf80
2000353a:	f6c0 0276 	movt	r2, #2166	; 0x876
2000353e:	601a      	str	r2, [r3, #0]
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
20003540:	f244 234c 	movw	r3, #16972	; 0x424c
20003544:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003548:	f64b 7280 	movw	r2, #49024	; 0xbf80
2000354c:	f6c0 0276 	movt	r2, #2166	; 0x876
20003550:	601a      	str	r2, [r3, #0]
                break;

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
20003552:	e045      	b.n	200035e0 <SystemCoreClockUpdate+0x144>
                                                   RCOSC_25_50MHZ_CLK_SRC,
                                                   CLK_XTAL_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   RCOSC_1_MHZ_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC,
                                                   CCC2ASCI_CLK_SRC };
20003554:	f244 2308 	movw	r3, #16904	; 0x4208
20003558:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000355c:	f107 0204 	add.w	r2, r7, #4
20003560:	e893 0003 	ldmia.w	r3, {r0, r1}
20003564:	e882 0003 	stmia.w	r2, {r0, r1}

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
20003568:	f248 0300 	movw	r3, #32768	; 0x8000
2000356c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003570:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20003574:	ea4f 1393 	mov.w	r3, r3, lsr #6
20003578:	f003 0307 	and.w	r3, r3, #7
2000357c:	61bb      	str	r3, [r7, #24]
            clock_source = standby_clock_lut[standby_sel];
2000357e:	69bb      	ldr	r3, [r7, #24]
20003580:	f107 0220 	add.w	r2, r7, #32
20003584:	4413      	add	r3, r2
20003586:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
2000358a:	77fb      	strb	r3, [r7, #31]
            switch(clock_source)
2000358c:	7ffb      	ldrb	r3, [r7, #31]
2000358e:	2b01      	cmp	r3, #1
20003590:	d00b      	beq.n	200035aa <SystemCoreClockUpdate+0x10e>
20003592:	2b02      	cmp	r3, #2
20003594:	d00e      	beq.n	200035b4 <SystemCoreClockUpdate+0x118>
20003596:	2b00      	cmp	r3, #0
20003598:	d114      	bne.n	200035c4 <SystemCoreClockUpdate+0x128>
            {
                case RCOSC_25_50MHZ_CLK_SRC:
                    clk_src = get_rcosc_25_50mhz_frequency();
2000359a:	f000 f825 	bl	200035e8 <get_rcosc_25_50mhz_frequency>
2000359e:	4603      	mov	r3, r0
200035a0:	613b      	str	r3, [r7, #16]
                    set_clock_frequency_globals(clk_src);
200035a2:	6938      	ldr	r0, [r7, #16]
200035a4:	f000 f842 	bl	2000362c <set_clock_frequency_globals>
                break;
200035a8:	e01a      	b.n	200035e0 <SystemCoreClockUpdate+0x144>

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
200035aa:	f44f 4000 	mov.w	r0, #32768	; 0x8000
200035ae:	f000 f83d 	bl	2000362c <set_clock_frequency_globals>
                break;
200035b2:	e015      	b.n	200035e0 <SystemCoreClockUpdate+0x144>

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
200035b4:	f244 2040 	movw	r0, #16960	; 0x4240
200035b8:	f2c0 000f 	movt	r0, #15
200035bc:	f000 f836 	bl	2000362c <set_clock_frequency_globals>
                break;
200035c0:	bf00      	nop
200035c2:	e00d      	b.n	200035e0 <SystemCoreClockUpdate+0x144>

                case CCC2ASCI_CLK_SRC:
                    /* Fall through. */
                default:
                    set_clock_frequency_globals(FREQ_1MHZ);
200035c4:	f244 2040 	movw	r0, #16960	; 0x4240
200035c8:	f2c0 000f 	movt	r0, #15
200035cc:	f000 f82e 	bl	2000362c <set_clock_frequency_globals>
200035d0:	e006      	b.n	200035e0 <SystemCoreClockUpdate+0x144>
        }
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
200035d2:	f000 f809 	bl	200035e8 <get_rcosc_25_50mhz_frequency>
200035d6:	4603      	mov	r3, r0
200035d8:	613b      	str	r3, [r7, #16]
        set_clock_frequency_globals(clk_src);
200035da:	6938      	ldr	r0, [r7, #16]
200035dc:	f000 f826 	bl	2000362c <set_clock_frequency_globals>
    }
}
200035e0:	f107 0720 	add.w	r7, r7, #32
200035e4:	46bd      	mov	sp, r7
200035e6:	bd80      	pop	{r7, pc}

200035e8 <get_rcosc_25_50mhz_frequency>:

/***************************************************************************//**
 * Find out frequency generated by the 25_50mhz RC osciallator.
 */
static uint32_t get_rcosc_25_50mhz_frequency(void)
{
200035e8:	b480      	push	{r7}
200035ea:	b083      	sub	sp, #12
200035ec:	af00      	add	r7, sp, #0
    uint32_t rcosc_div2;
    uint32_t rcosc_frequency;

    rcosc_div2 = SYSREG->MSSDDR_PLL_STATUS & RCOSC_DIV2_MASK;
200035ee:	f248 0300 	movw	r3, #32768	; 0x8000
200035f2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200035f6:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
200035fa:	f003 0304 	and.w	r3, r3, #4
200035fe:	603b      	str	r3, [r7, #0]
    if(0u == rcosc_div2)
20003600:	683b      	ldr	r3, [r7, #0]
20003602:	2b00      	cmp	r3, #0
20003604:	d105      	bne.n	20003612 <get_rcosc_25_50mhz_frequency+0x2a>
    {
        /* 25_50mhz oscillator is configured for 25 MHz operations. */
        rcosc_frequency = FREQ_25MHZ;
20003606:	f647 0340 	movw	r3, #30784	; 0x7840
2000360a:	f2c0 137d 	movt	r3, #381	; 0x17d
2000360e:	607b      	str	r3, [r7, #4]
20003610:	e004      	b.n	2000361c <get_rcosc_25_50mhz_frequency+0x34>
    }
    else
    {
        /* 25_50mhz oscillator is configured for 50 MHz operations. */
        rcosc_frequency = FREQ_50MHZ;
20003612:	f24f 0380 	movw	r3, #61568	; 0xf080
20003616:	f2c0 23fa 	movt	r3, #762	; 0x2fa
2000361a:	607b      	str	r3, [r7, #4]
    }

    return rcosc_frequency;
2000361c:	687b      	ldr	r3, [r7, #4]
}
2000361e:	4618      	mov	r0, r3
20003620:	f107 070c 	add.w	r7, r7, #12
20003624:	46bd      	mov	sp, r7
20003626:	bc80      	pop	{r7}
20003628:	4770      	bx	lr
2000362a:	bf00      	nop

2000362c <set_clock_frequency_globals>:
        - g_FrequencyFIC0
        - g_FrequencyFIC1
        - g_FrequencyFIC64
 */
static void set_clock_frequency_globals(uint32_t standby_clk)
{
2000362c:	b480      	push	{r7}
2000362e:	b083      	sub	sp, #12
20003630:	af00      	add	r7, sp, #0
20003632:	6078      	str	r0, [r7, #4]
    SystemCoreClock = standby_clk;
20003634:	f244 2334 	movw	r3, #16948	; 0x4234
20003638:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000363c:	687a      	ldr	r2, [r7, #4]
2000363e:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK0 = standby_clk;
20003640:	f244 2338 	movw	r3, #16952	; 0x4238
20003644:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003648:	687a      	ldr	r2, [r7, #4]
2000364a:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK1 = standby_clk;
2000364c:	f244 233c 	movw	r3, #16956	; 0x423c
20003650:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003654:	687a      	ldr	r2, [r7, #4]
20003656:	601a      	str	r2, [r3, #0]
    g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
20003658:	f244 2340 	movw	r3, #16960	; 0x4240
2000365c:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003660:	f64a 72e0 	movw	r2, #45024	; 0xafe0
20003664:	f2c0 221d 	movt	r2, #541	; 0x21d
20003668:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC0 = standby_clk;
2000366a:	f244 2344 	movw	r3, #16964	; 0x4244
2000366e:	f2c2 0300 	movt	r3, #8192	; 0x2000
20003672:	687a      	ldr	r2, [r7, #4]
20003674:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC1 = standby_clk;
20003676:	f244 2348 	movw	r3, #16968	; 0x4248
2000367a:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000367e:	687a      	ldr	r2, [r7, #4]
20003680:	601a      	str	r2, [r3, #0]
    g_FrequencyFIC64 = standby_clk;
20003682:	f244 234c 	movw	r3, #16972	; 0x424c
20003686:	f2c2 0300 	movt	r3, #8192	; 0x2000
2000368a:	687a      	ldr	r2, [r7, #4]
2000368c:	601a      	str	r2, [r3, #0]
}
2000368e:	f107 070c 	add.w	r7, r7, #12
20003692:	46bd      	mov	sp, r7
20003694:	bc80      	pop	{r7}
20003696:	4770      	bx	lr

20003698 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
20003698:	b480      	push	{r7}
2000369a:	b083      	sub	sp, #12
2000369c:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
2000369e:	f248 0300 	movw	r3, #32768	; 0x8000
200036a2:	f2c4 0303 	movt	r3, #16387	; 0x4003
200036a6:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
200036aa:	607b      	str	r3, [r7, #4]
    switch(device_version)
200036ac:	687a      	ldr	r2, [r7, #4]
200036ae:	f64f 0302 	movw	r3, #63490	; 0xf802
200036b2:	429a      	cmp	r2, r3
200036b4:	d006      	beq.n	200036c4 <get_silicon_revision+0x2c>
200036b6:	f64f 0302 	movw	r3, #63490	; 0xf802
200036ba:	f2c0 0301 	movt	r3, #1
200036be:	429a      	cmp	r2, r3
200036c0:	d004      	beq.n	200036cc <get_silicon_revision+0x34>
200036c2:	e007      	b.n	200036d4 <get_silicon_revision+0x3c>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
200036c4:	f04f 0301 	mov.w	r3, #1
200036c8:	603b      	str	r3, [r7, #0]
            break;
200036ca:	e006      	b.n	200036da <get_silicon_revision+0x42>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
200036cc:	f04f 0302 	mov.w	r3, #2
200036d0:	603b      	str	r3, [r7, #0]
            break;
200036d2:	e002      	b.n	200036da <get_silicon_revision+0x42>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
200036d4:	f04f 0300 	mov.w	r3, #0
200036d8:	603b      	str	r3, [r7, #0]
            break;
    }

    return silicon_revision;
200036da:	683b      	ldr	r3, [r7, #0]
}
200036dc:	4618      	mov	r0, r3
200036de:	f107 070c 	add.w	r7, r7, #12
200036e2:	46bd      	mov	sp, r7
200036e4:	bc80      	pop	{r7}
200036e6:	4770      	bx	lr

200036e8 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
200036e8:	b580      	push	{r7, lr}
200036ea:	b082      	sub	sp, #8
200036ec:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
200036ee:	f7ff ffd3 	bl	20003698 <get_silicon_revision>
200036f2:	4603      	mov	r3, r0
200036f4:	607b      	str	r3, [r7, #4]

    switch(silicon_revision)
200036f6:	687b      	ldr	r3, [r7, #4]
200036f8:	2b01      	cmp	r3, #1
200036fa:	d101      	bne.n	20003700 <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
200036fc:	f000 f804 	bl	20003708 <m2s050_rev_a_workarounds>
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
    }
}
20003700:	f107 0708 	add.w	r7, r7, #8
20003704:	46bd      	mov	sp, r7
20003706:	bd80      	pop	{r7, pc}

20003708 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
20003708:	b480      	push	{r7}
2000370a:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
2000370c:	f248 0300 	movw	r3, #32768	; 0x8000
20003710:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003714:	f248 0200 	movw	r2, #32768	; 0x8000
20003718:	f2c4 0203 	movt	r2, #16387	; 0x4003
2000371c:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
20003720:	f442 7280 	orr.w	r2, r2, #256	; 0x100
20003724:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
20003728:	f248 0300 	movw	r3, #32768	; 0x8000
2000372c:	f2c4 0303 	movt	r3, #16387	; 0x4003
20003730:	f248 0200 	movw	r2, #32768	; 0x8000
20003734:	f2c4 0203 	movt	r2, #16387	; 0x4003
20003738:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
2000373c:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
20003740:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
}
20003744:	46bd      	mov	sp, r7
20003746:	bc80      	pop	{r7}
20003748:	4770      	bx	lr
2000374a:	bf00      	nop

2000374c <__libc_init_array>:
2000374c:	b570      	push	{r4, r5, r6, lr}
2000374e:	f244 2628 	movw	r6, #16936	; 0x4228
20003752:	f244 2528 	movw	r5, #16936	; 0x4228
20003756:	f2c2 0600 	movt	r6, #8192	; 0x2000
2000375a:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000375e:	1b76      	subs	r6, r6, r5
20003760:	10b6      	asrs	r6, r6, #2
20003762:	d006      	beq.n	20003772 <__libc_init_array+0x26>
20003764:	2400      	movs	r4, #0
20003766:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
2000376a:	3401      	adds	r4, #1
2000376c:	4798      	blx	r3
2000376e:	42a6      	cmp	r6, r4
20003770:	d8f9      	bhi.n	20003766 <__libc_init_array+0x1a>
20003772:	f244 2528 	movw	r5, #16936	; 0x4228
20003776:	f244 262c 	movw	r6, #16940	; 0x422c
2000377a:	f2c2 0500 	movt	r5, #8192	; 0x2000
2000377e:	f2c2 0600 	movt	r6, #8192	; 0x2000
20003782:	1b76      	subs	r6, r6, r5
20003784:	f000 fd44 	bl	20004210 <_init>
20003788:	10b6      	asrs	r6, r6, #2
2000378a:	d006      	beq.n	2000379a <__libc_init_array+0x4e>
2000378c:	2400      	movs	r4, #0
2000378e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
20003792:	3401      	adds	r4, #1
20003794:	4798      	blx	r3
20003796:	42a6      	cmp	r6, r4
20003798:	d8f9      	bhi.n	2000378e <__libc_init_array+0x42>
2000379a:	bd70      	pop	{r4, r5, r6, pc}
2000379c:	0d0a0d0a 	.word	0x0d0a0d0a
200037a0:	65725020 	.word	0x65725020
200037a4:	6e207373 	.word	0x6e207373
200037a8:	65626d75 	.word	0x65626d75
200037ac:	6f662072 	.word	0x6f662072
200037b0:	63412072 	.word	0x63412072
200037b4:	6e6f6974 	.word	0x6e6f6974
200037b8:	0a0d0a20 	.word	0x0a0d0a20
200037bc:	2031200d 	.word	0x2031200d
200037c0:	61655220 	.word	0x61655220
200037c4:	50462064 	.word	0x50462064
200037c8:	52204147 	.word	0x52204147
200037cc:	73696765 	.word	0x73696765
200037d0:	73726574 	.word	0x73726574
200037d4:	200d0a20 	.word	0x200d0a20
200037d8:	52202032 	.word	0x52202032
200037dc:	74657365 	.word	0x74657365
200037e0:	63655220 	.word	0x63655220
200037e4:	65766965 	.word	0x65766965
200037e8:	46494620 	.word	0x46494620
200037ec:	0d0a204f 	.word	0x0d0a204f
200037f0:	20203320 	.word	0x20203320
200037f4:	65736552 	.word	0x65736552
200037f8:	72542074 	.word	0x72542074
200037fc:	6d736e61 	.word	0x6d736e61
20003800:	46207469 	.word	0x46207469
20003804:	204f4649 	.word	0x204f4649
20003808:	34200d0a 	.word	0x34200d0a
2000380c:	72542020 	.word	0x72542020
20003810:	6d736e61 	.word	0x6d736e61
20003814:	53207469 	.word	0x53207469
20003818:	6c676e69 	.word	0x6c676e69
2000381c:	61502065 	.word	0x61502065
20003820:	74656b63 	.word	0x74656b63
20003824:	49202d20 	.word	0x49202d20
20003828:	5245544e 	.word	0x5245544e
2000382c:	204c414e 	.word	0x204c414e
20003830:	706f6f4c 	.word	0x706f6f4c
20003834:	6b636162 	.word	0x6b636162
20003838:	200d0a20 	.word	0x200d0a20
2000383c:	52202035 	.word	0x52202035
20003840:	69656365 	.word	0x69656365
20003844:	53206576 	.word	0x53206576
20003848:	6c676e69 	.word	0x6c676e69
2000384c:	61502065 	.word	0x61502065
20003850:	74656b63 	.word	0x74656b63
20003854:	646e6120 	.word	0x646e6120
20003858:	65684320 	.word	0x65684320
2000385c:	2d206b63 	.word	0x2d206b63
20003860:	544e4920 	.word	0x544e4920
20003864:	414e5245 	.word	0x414e5245
20003868:	6f4c204c 	.word	0x6f4c204c
2000386c:	6162706f 	.word	0x6162706f
20003870:	0a206b63 	.word	0x0a206b63
20003874:	2036200d 	.word	0x2036200d
20003878:	6f6f4c20 	.word	0x6f6f4c20
2000387c:	63616270 	.word	0x63616270
20003880:	6150206b 	.word	0x6150206b
20003884:	74656b63 	.word	0x74656b63
20003888:	72662073 	.word	0x72662073
2000388c:	38206d6f 	.word	0x38206d6f
20003890:	206f7420 	.word	0x206f7420
20003894:	33323031 	.word	0x33323031
20003898:	74794220 	.word	0x74794220
2000389c:	26207365 	.word	0x26207365
200038a0:	65684320 	.word	0x65684320
200038a4:	2d206b63 	.word	0x2d206b63
200038a8:	544e4920 	.word	0x544e4920
200038ac:	414e5245 	.word	0x414e5245
200038b0:	6f4c204c 	.word	0x6f4c204c
200038b4:	6162706f 	.word	0x6162706f
200038b8:	0a206b63 	.word	0x0a206b63
200038bc:	2037200d 	.word	0x2037200d
200038c0:	61725420 	.word	0x61725420
200038c4:	696d736e 	.word	0x696d736e
200038c8:	69532074 	.word	0x69532074
200038cc:	656c676e 	.word	0x656c676e
200038d0:	63615020 	.word	0x63615020
200038d4:	2074656b 	.word	0x2074656b
200038d8:	5845202d 	.word	0x5845202d
200038dc:	4e524554 	.word	0x4e524554
200038e0:	4c204c41 	.word	0x4c204c41
200038e4:	62706f6f 	.word	0x62706f6f
200038e8:	206b6361 	.word	0x206b6361
200038ec:	38200d0a 	.word	0x38200d0a
200038f0:	65522020 	.word	0x65522020
200038f4:	76696563 	.word	0x76696563
200038f8:	69532065 	.word	0x69532065
200038fc:	656c676e 	.word	0x656c676e
20003900:	63615020 	.word	0x63615020
20003904:	2074656b 	.word	0x2074656b
20003908:	20646e61 	.word	0x20646e61
2000390c:	63656843 	.word	0x63656843
20003910:	202d206b 	.word	0x202d206b
20003914:	45545845 	.word	0x45545845
20003918:	4c414e52 	.word	0x4c414e52
2000391c:	6f6f4c20 	.word	0x6f6f4c20
20003920:	63616270 	.word	0x63616270
20003924:	0d0a206b 	.word	0x0d0a206b
20003928:	20203920 	.word	0x20203920
2000392c:	6e617254 	.word	0x6e617254
20003930:	74696d73 	.word	0x74696d73
20003934:	63615020 	.word	0x63615020
20003938:	7374656b 	.word	0x7374656b
2000393c:	6f726620 	.word	0x6f726620
20003940:	2038206d 	.word	0x2038206d
20003944:	31206f74 	.word	0x31206f74
20003948:	20333230 	.word	0x20333230
2000394c:	65747942 	.word	0x65747942
20003950:	20262073 	.word	0x20262073
20003954:	63656843 	.word	0x63656843
20003958:	202d206b 	.word	0x202d206b
2000395c:	45545845 	.word	0x45545845
20003960:	4c414e52 	.word	0x4c414e52
20003964:	6f6f4c20 	.word	0x6f6f4c20
20003968:	63616270 	.word	0x63616270
2000396c:	0d0a206b 	.word	0x0d0a206b
20003970:	20206120 	.word	0x20206120
20003974:	6e617254 	.word	0x6e617254
20003978:	74696d73 	.word	0x74696d73
2000397c:	616f4220 	.word	0x616f4220
20003980:	32206472 	.word	0x32206472
20003984:	616f4220 	.word	0x616f4220
20003988:	53206472 	.word	0x53206472
2000398c:	6c676e69 	.word	0x6c676e69
20003990:	61502065 	.word	0x61502065
20003994:	74656b63 	.word	0x74656b63
20003998:	200d0a20 	.word	0x200d0a20
2000399c:	52202062 	.word	0x52202062
200039a0:	69656365 	.word	0x69656365
200039a4:	42206576 	.word	0x42206576
200039a8:	6472616f 	.word	0x6472616f
200039ac:	42203220 	.word	0x42203220
200039b0:	6472616f 	.word	0x6472616f
200039b4:	6e695320 	.word	0x6e695320
200039b8:	20656c67 	.word	0x20656c67
200039bc:	6b636150 	.word	0x6b636150
200039c0:	61207465 	.word	0x61207465
200039c4:	4320646e 	.word	0x4320646e
200039c8:	6b636568 	.word	0x6b636568
200039cc:	200d0a20 	.word	0x200d0a20
200039d0:	54202063 	.word	0x54202063
200039d4:	736e6172 	.word	0x736e6172
200039d8:	2074696d 	.word	0x2074696d
200039dc:	72616f42 	.word	0x72616f42
200039e0:	20322064 	.word	0x20322064
200039e4:	72616f42 	.word	0x72616f42
200039e8:	754d2064 	.word	0x754d2064
200039ec:	7069746c 	.word	0x7069746c
200039f0:	5020656c 	.word	0x5020656c
200039f4:	656b6361 	.word	0x656b6361
200039f8:	0a207374 	.word	0x0a207374
200039fc:	2064200d 	.word	0x2064200d
20003a00:	63655220 	.word	0x63655220
20003a04:	65766965 	.word	0x65766965
20003a08:	616f4220 	.word	0x616f4220
20003a0c:	32206472 	.word	0x32206472
20003a10:	616f4220 	.word	0x616f4220
20003a14:	4d206472 	.word	0x4d206472
20003a18:	69746c75 	.word	0x69746c75
20003a1c:	20656c70 	.word	0x20656c70
20003a20:	6b636150 	.word	0x6b636150
20003a24:	20737465 	.word	0x20737465
20003a28:	65200d0a 	.word	0x65200d0a
20003a2c:	72542020 	.word	0x72542020
20003a30:	6d736e61 	.word	0x6d736e61
20003a34:	50207469 	.word	0x50207469
20003a38:	656b6361 	.word	0x656b6361
20003a3c:	6c422074 	.word	0x6c422074
20003a40:	65747361 	.word	0x65747361
20003a44:	0a202e72 	.word	0x0a202e72
20003a48:	2066200d 	.word	0x2066200d
20003a4c:	73655220 	.word	0x73655220
20003a50:	46207465 	.word	0x46207465
20003a54:	20414750 	.word	0x20414750
20003a58:	69676f4c 	.word	0x69676f4c
20003a5c:	0a202e63 	.word	0x0a202e63
20003a60:	2067200d 	.word	0x2067200d
20003a64:	616c4220 	.word	0x616c4220
20003a68:	72657473 	.word	0x72657473
20003a6c:	63615020 	.word	0x63615020
20003a70:	2074656b 	.word	0x2074656b
20003a74:	706f6f4c 	.word	0x706f6f4c
20003a78:	6b636162 	.word	0x6b636162
20003a7c:	200d0a20 	.word	0x200d0a20
20003a80:	54202069 	.word	0x54202069
20003a84:	736e6172 	.word	0x736e6172
20003a88:	2074696d 	.word	0x2074696d
20003a8c:	20423242 	.word	0x20423242
20003a90:	73616c42 	.word	0x73616c42
20003a94:	20726574 	.word	0x20726574
20003a98:	6b636150 	.word	0x6b636150
20003a9c:	0a207465 	.word	0x0a207465
20003aa0:	206a200d 	.word	0x206a200d
20003aa4:	63655220 	.word	0x63655220
20003aa8:	65766965 	.word	0x65766965
20003aac:	42324220 	.word	0x42324220
20003ab0:	616c4220 	.word	0x616c4220
20003ab4:	72657473 	.word	0x72657473
20003ab8:	63615020 	.word	0x63615020
20003abc:	2074656b 	.word	0x2074656b
20003ac0:	00000d0a 	.word	0x00000d0a
20003ac4:	0d0a0d0a 	.word	0x0d0a0d0a
20003ac8:	00000000 	.word	0x00000000
20003acc:	0d0a0d0a 	.word	0x0d0a0d0a
20003ad0:	73655220 	.word	0x73655220
20003ad4:	52207465 	.word	0x52207465
20003ad8:	69656365 	.word	0x69656365
20003adc:	46206576 	.word	0x46206576
20003ae0:	2e4f4649 	.word	0x2e4f4649
20003ae4:	0a202e2e 	.word	0x0a202e2e
20003ae8:	0000000d 	.word	0x0000000d
20003aec:	0d0a0d0a 	.word	0x0d0a0d0a
20003af0:	73655220 	.word	0x73655220
20003af4:	54207465 	.word	0x54207465
20003af8:	736e6172 	.word	0x736e6172
20003afc:	2074696d 	.word	0x2074696d
20003b00:	4f464946 	.word	0x4f464946
20003b04:	202e2e2e 	.word	0x202e2e2e
20003b08:	00000d0a 	.word	0x00000d0a
20003b0c:	0d0a0d0a 	.word	0x0d0a0d0a
20003b10:	61725420 	.word	0x61725420
20003b14:	696d736e 	.word	0x696d736e
20003b18:	6e697474 	.word	0x6e697474
20003b1c:	69532067 	.word	0x69532067
20003b20:	656c676e 	.word	0x656c676e
20003b24:	63615020 	.word	0x63615020
20003b28:	2074656b 	.word	0x2074656b
20003b2c:	6e49202d 	.word	0x6e49202d
20003b30:	6e726574 	.word	0x6e726574
20003b34:	4c206c61 	.word	0x4c206c61
20003b38:	62706f6f 	.word	0x62706f6f
20003b3c:	2e6b6361 	.word	0x2e6b6361
20003b40:	0a202e2e 	.word	0x0a202e2e
20003b44:	0000000d 	.word	0x0000000d
20003b48:	0d0a0d0a 	.word	0x0d0a0d0a
20003b4c:	63655220 	.word	0x63655220
20003b50:	65766965 	.word	0x65766965
20003b54:	67695320 	.word	0x67695320
20003b58:	20656c6e 	.word	0x20656c6e
20003b5c:	6b636150 	.word	0x6b636150
20003b60:	61207465 	.word	0x61207465
20003b64:	4320646e 	.word	0x4320646e
20003b68:	6b636568 	.word	0x6b636568
20003b6c:	49202d20 	.word	0x49202d20
20003b70:	7265746e 	.word	0x7265746e
20003b74:	206c616e 	.word	0x206c616e
20003b78:	706f6f4c 	.word	0x706f6f4c
20003b7c:	6b636162 	.word	0x6b636162
20003b80:	202e2e2e 	.word	0x202e2e2e
20003b84:	00000d0a 	.word	0x00000d0a
20003b88:	0d0a0d0a 	.word	0x0d0a0d0a
20003b8c:	6f6f4c20 	.word	0x6f6f4c20
20003b90:	676e6970 	.word	0x676e6970
20003b94:	63614220 	.word	0x63614220
20003b98:	6150206b 	.word	0x6150206b
20003b9c:	74656b63 	.word	0x74656b63
20003ba0:	61522073 	.word	0x61522073
20003ba4:	6e69676e 	.word	0x6e69676e
20003ba8:	6e692067 	.word	0x6e692067
20003bac:	7a695320 	.word	0x7a695320
20003bb0:	72662065 	.word	0x72662065
20003bb4:	38206d6f 	.word	0x38206d6f
20003bb8:	74794220 	.word	0x74794220
20003bbc:	74207365 	.word	0x74207365
20003bc0:	3032206f 	.word	0x3032206f
20003bc4:	42203830 	.word	0x42203830
20003bc8:	73657479 	.word	0x73657479
20003bcc:	49202d20 	.word	0x49202d20
20003bd0:	7265746e 	.word	0x7265746e
20003bd4:	206c616e 	.word	0x206c616e
20003bd8:	706f6f4c 	.word	0x706f6f4c
20003bdc:	6b636162 	.word	0x6b636162
20003be0:	202e2e2e 	.word	0x202e2e2e
20003be4:	000d0a20 	.word	0x000d0a20
20003be8:	0d0a0d0a 	.word	0x0d0a0d0a
20003bec:	61725420 	.word	0x61725420
20003bf0:	696d736e 	.word	0x696d736e
20003bf4:	6e697474 	.word	0x6e697474
20003bf8:	69532067 	.word	0x69532067
20003bfc:	656c676e 	.word	0x656c676e
20003c00:	63615020 	.word	0x63615020
20003c04:	2074656b 	.word	0x2074656b
20003c08:	5845202d 	.word	0x5845202d
20003c0c:	4e524554 	.word	0x4e524554
20003c10:	4c204c41 	.word	0x4c204c41
20003c14:	62706f6f 	.word	0x62706f6f
20003c18:	2e6b6361 	.word	0x2e6b6361
20003c1c:	0a202e2e 	.word	0x0a202e2e
20003c20:	0000000d 	.word	0x0000000d
20003c24:	0d0a0d0a 	.word	0x0d0a0d0a
20003c28:	63655220 	.word	0x63655220
20003c2c:	65766965 	.word	0x65766965
20003c30:	6e695320 	.word	0x6e695320
20003c34:	20656c67 	.word	0x20656c67
20003c38:	6b636150 	.word	0x6b636150
20003c3c:	61207465 	.word	0x61207465
20003c40:	4320646e 	.word	0x4320646e
20003c44:	6b636568 	.word	0x6b636568
20003c48:	45202d20 	.word	0x45202d20
20003c4c:	52455458 	.word	0x52455458
20003c50:	204c414e 	.word	0x204c414e
20003c54:	706f6f4c 	.word	0x706f6f4c
20003c58:	6b636162 	.word	0x6b636162
20003c5c:	202e2e2e 	.word	0x202e2e2e
20003c60:	00000d0a 	.word	0x00000d0a
20003c64:	0d0a0d0a 	.word	0x0d0a0d0a
20003c68:	6f6f4c20 	.word	0x6f6f4c20
20003c6c:	676e6970 	.word	0x676e6970
20003c70:	63614220 	.word	0x63614220
20003c74:	6150206b 	.word	0x6150206b
20003c78:	74656b63 	.word	0x74656b63
20003c7c:	61522073 	.word	0x61522073
20003c80:	2065676e 	.word	0x2065676e
20003c84:	6f742038 	.word	0x6f742038
20003c88:	30303220 	.word	0x30303220
20003c8c:	79422038 	.word	0x79422038
20003c90:	20736574 	.word	0x20736574
20003c94:	5845202d 	.word	0x5845202d
20003c98:	4e524554 	.word	0x4e524554
20003c9c:	4c204c41 	.word	0x4c204c41
20003ca0:	62706f6f 	.word	0x62706f6f
20003ca4:	2e6b6361 	.word	0x2e6b6361
20003ca8:	20202e2e 	.word	0x20202e2e
20003cac:	00000d0a 	.word	0x00000d0a
20003cb0:	0d0a0d0a 	.word	0x0d0a0d0a
20003cb4:	61725420 	.word	0x61725420
20003cb8:	696d736e 	.word	0x696d736e
20003cbc:	676e6974 	.word	0x676e6974
20003cc0:	616f4220 	.word	0x616f4220
20003cc4:	74206472 	.word	0x74206472
20003cc8:	6f42206f 	.word	0x6f42206f
20003ccc:	20647261 	.word	0x20647261
20003cd0:	676e6953 	.word	0x676e6953
20003cd4:	5020656c 	.word	0x5020656c
20003cd8:	656b6361 	.word	0x656b6361
20003cdc:	2e2e2e74 	.word	0x2e2e2e74
20003ce0:	000d0a20 	.word	0x000d0a20
20003ce4:	0d0a0d0a 	.word	0x0d0a0d0a
20003ce8:	63655220 	.word	0x63655220
20003cec:	69766965 	.word	0x69766965
20003cf0:	4220676e 	.word	0x4220676e
20003cf4:	6472616f 	.word	0x6472616f
20003cf8:	206f7420 	.word	0x206f7420
20003cfc:	72616f42 	.word	0x72616f42
20003d00:	69532064 	.word	0x69532064
20003d04:	656c676e 	.word	0x656c676e
20003d08:	63615020 	.word	0x63615020
20003d0c:	2074656b 	.word	0x2074656b
20003d10:	20646e61 	.word	0x20646e61
20003d14:	63656843 	.word	0x63656843
20003d18:	2e2e2e6b 	.word	0x2e2e2e6b
20003d1c:	000d0a20 	.word	0x000d0a20
20003d20:	0d0a0d0a 	.word	0x0d0a0d0a
20003d24:	61725420 	.word	0x61725420
20003d28:	696d736e 	.word	0x696d736e
20003d2c:	6e697474 	.word	0x6e697474
20003d30:	6f422067 	.word	0x6f422067
20003d34:	20647261 	.word	0x20647261
20003d38:	42206f74 	.word	0x42206f74
20003d3c:	6472616f 	.word	0x6472616f
20003d40:	6c754d20 	.word	0x6c754d20
20003d44:	6c706974 	.word	0x6c706974
20003d48:	61502065 	.word	0x61502065
20003d4c:	74656b63 	.word	0x74656b63
20003d50:	2e2e2e73 	.word	0x2e2e2e73
20003d54:	000d0a20 	.word	0x000d0a20
20003d58:	0d0a0d0a 	.word	0x0d0a0d0a
20003d5c:	63655220 	.word	0x63655220
20003d60:	69766965 	.word	0x69766965
20003d64:	4220676e 	.word	0x4220676e
20003d68:	6472616f 	.word	0x6472616f
20003d6c:	206f7420 	.word	0x206f7420
20003d70:	72616f42 	.word	0x72616f42
20003d74:	754d2064 	.word	0x754d2064
20003d78:	7069746c 	.word	0x7069746c
20003d7c:	5020656c 	.word	0x5020656c
20003d80:	656b6361 	.word	0x656b6361
20003d84:	2e2e7374 	.word	0x2e2e7374
20003d88:	0d0a202e 	.word	0x0d0a202e
20003d8c:	00000000 	.word	0x00000000
20003d90:	0d0a0d0a 	.word	0x0d0a0d0a
20003d94:	61725420 	.word	0x61725420
20003d98:	696d736e 	.word	0x696d736e
20003d9c:	61502074 	.word	0x61502074
20003da0:	74656b63 	.word	0x74656b63
20003da4:	616c4220 	.word	0x616c4220
20003da8:	72657473 	.word	0x72657473
20003dac:	0d0a202e 	.word	0x0d0a202e
20003db0:	00000000 	.word	0x00000000
20003db4:	0d0a0d0a 	.word	0x0d0a0d0a
20003db8:	73655220 	.word	0x73655220
20003dbc:	46207465 	.word	0x46207465
20003dc0:	20414750 	.word	0x20414750
20003dc4:	69676f4c 	.word	0x69676f4c
20003dc8:	0a202e63 	.word	0x0a202e63
20003dcc:	0000000d 	.word	0x0000000d
20003dd0:	0d0a0d0a 	.word	0x0d0a0d0a
20003dd4:	616c4220 	.word	0x616c4220
20003dd8:	72657473 	.word	0x72657473
20003ddc:	63615020 	.word	0x63615020
20003de0:	2074656b 	.word	0x2074656b
20003de4:	706f6f4c 	.word	0x706f6f4c
20003de8:	6b636162 	.word	0x6b636162
20003dec:	000d0a20 	.word	0x000d0a20
20003df0:	0d0a0d0a 	.word	0x0d0a0d0a
20003df4:	61725420 	.word	0x61725420
20003df8:	696d736e 	.word	0x696d736e
20003dfc:	32422074 	.word	0x32422074
20003e00:	6c422042 	.word	0x6c422042
20003e04:	65747361 	.word	0x65747361
20003e08:	61502072 	.word	0x61502072
20003e0c:	74656b63 	.word	0x74656b63
20003e10:	000d0a20 	.word	0x000d0a20
20003e14:	0d0a0d0a 	.word	0x0d0a0d0a
20003e18:	63655220 	.word	0x63655220
20003e1c:	65766965 	.word	0x65766965
20003e20:	42324220 	.word	0x42324220
20003e24:	616c4220 	.word	0x616c4220
20003e28:	72657473 	.word	0x72657473
20003e2c:	63615020 	.word	0x63615020
20003e30:	2074656b 	.word	0x2074656b
20003e34:	00000d0a 	.word	0x00000d0a
20003e38:	0d0a0d0a 	.word	0x0d0a0d0a
20003e3c:	65725020 	.word	0x65725020
20003e40:	61207373 	.word	0x61207373
20003e44:	6e20796e 	.word	0x6e20796e
20003e48:	65626d75 	.word	0x65626d75
20003e4c:	2e2e2e72 	.word	0x2e2e2e72
20003e50:	0a0d0a20 	.word	0x0a0d0a20
20003e54:	0000000d 	.word	0x0000000d
20003e58:	45200d0a 	.word	0x45200d0a
20003e5c:	7265746e 	.word	0x7265746e
20003e60:	0020203a 	.word	0x0020203a
20003e64:	0d0a0d0a 	.word	0x0d0a0d0a
20003e68:	50462020 	.word	0x50462020
20003e6c:	52204147 	.word	0x52204147
20003e70:	73697665 	.word	0x73697665
20003e74:	206e6f69 	.word	0x206e6f69
20003e78:	69676552 	.word	0x69676552
20003e7c:	72657473 	.word	0x72657473
20003e80:	2020203a 	.word	0x2020203a
20003e84:	20202020 	.word	0x20202020
20003e88:	00007830 	.word	0x00007830
20003e8c:	20200d0a 	.word	0x20200d0a
20003e90:	41475046 	.word	0x41475046
20003e94:	72635320 	.word	0x72635320
20003e98:	68637461 	.word	0x68637461
20003e9c:	64615020 	.word	0x64615020
20003ea0:	67655220 	.word	0x67655220
20003ea4:	65747369 	.word	0x65747369
20003ea8:	20203a72 	.word	0x20203a72
20003eac:	78302020 	.word	0x78302020
20003eb0:	00000000 	.word	0x00000000
20003eb4:	20200d0a 	.word	0x20200d0a
20003eb8:	41475046 	.word	0x41475046
20003ebc:	6e6f4320 	.word	0x6e6f4320
20003ec0:	6c6f7274 	.word	0x6c6f7274
20003ec4:	67655220 	.word	0x67655220
20003ec8:	65747369 	.word	0x65747369
20003ecc:	20203a72 	.word	0x20203a72
20003ed0:	20202020 	.word	0x20202020
20003ed4:	78302020 	.word	0x78302020
20003ed8:	00000000 	.word	0x00000000
20003edc:	20200d0a 	.word	0x20200d0a
20003ee0:	41475046 	.word	0x41475046
20003ee4:	746e4920 	.word	0x746e4920
20003ee8:	75727265 	.word	0x75727265
20003eec:	52207470 	.word	0x52207470
20003ef0:	73696765 	.word	0x73696765
20003ef4:	3a726574 	.word	0x3a726574
20003ef8:	20202020 	.word	0x20202020
20003efc:	78302020 	.word	0x78302020
20003f00:	00000000 	.word	0x00000000
20003f04:	20200d0a 	.word	0x20200d0a
20003f08:	41475046 	.word	0x41475046
20003f0c:	746e4920 	.word	0x746e4920
20003f10:	75727265 	.word	0x75727265
20003f14:	4d207470 	.word	0x4d207470
20003f18:	206b7361 	.word	0x206b7361
20003f1c:	69676552 	.word	0x69676552
20003f20:	72657473 	.word	0x72657473
20003f24:	7830203a 	.word	0x7830203a
20003f28:	00000000 	.word	0x00000000
20003f2c:	20200d0a 	.word	0x20200d0a
20003f30:	41475046 	.word	0x41475046
20003f34:	61745320 	.word	0x61745320
20003f38:	20737574 	.word	0x20737574
20003f3c:	69676552 	.word	0x69676552
20003f40:	72657473 	.word	0x72657473
20003f44:	2020203a 	.word	0x2020203a
20003f48:	20202020 	.word	0x20202020
20003f4c:	78302020 	.word	0x78302020
20003f50:	00000000 	.word	0x00000000
20003f54:	20200d0a 	.word	0x20200d0a
20003f58:	41475046 	.word	0x41475046
20003f5c:	67694820 	.word	0x67694820
20003f60:	64412068 	.word	0x64412068
20003f64:	73657264 	.word	0x73657264
20003f68:	65522073 	.word	0x65522073
20003f6c:	74736967 	.word	0x74736967
20003f70:	203a7265 	.word	0x203a7265
20003f74:	78302020 	.word	0x78302020
20003f78:	00000000 	.word	0x00000000
20003f7c:	20200d0a 	.word	0x20200d0a
20003f80:	41475046 	.word	0x41475046
20003f84:	776f4c20 	.word	0x776f4c20
20003f88:	64644120 	.word	0x64644120
20003f8c:	73736572 	.word	0x73736572
20003f90:	67655220 	.word	0x67655220
20003f94:	65747369 	.word	0x65747369
20003f98:	20203a72 	.word	0x20203a72
20003f9c:	78302020 	.word	0x78302020
20003fa0:	00000000 	.word	0x00000000
20003fa4:	20200d0a 	.word	0x20200d0a
20003fa8:	46205854 	.word	0x46205854
20003fac:	204f4649 	.word	0x204f4649
20003fb0:	45444e55 	.word	0x45444e55
20003fb4:	4e555252 	.word	0x4e555252
20003fb8:	544e4920 	.word	0x544e4920
20003fbc:	55525245 	.word	0x55525245
20003fc0:	00005450 	.word	0x00005450
20003fc4:	20200d0a 	.word	0x20200d0a
20003fc8:	46205854 	.word	0x46205854
20003fcc:	204f4649 	.word	0x204f4649
20003fd0:	5245564f 	.word	0x5245564f
20003fd4:	574f4c46 	.word	0x574f4c46
20003fd8:	544e4920 	.word	0x544e4920
20003fdc:	55525245 	.word	0x55525245
20003fe0:	00005450 	.word	0x00005450
20003fe4:	20200d0a 	.word	0x20200d0a
20003fe8:	43205854 	.word	0x43205854
20003fec:	494c4c4f 	.word	0x494c4c4f
20003ff0:	4e4f4953 	.word	0x4e4f4953
20003ff4:	544e4920 	.word	0x544e4920
20003ff8:	55525245 	.word	0x55525245
20003ffc:	00005450 	.word	0x00005450
20004000:	20200d0a 	.word	0x20200d0a
20004004:	46205852 	.word	0x46205852
20004008:	204f4649 	.word	0x204f4649
2000400c:	45444e55 	.word	0x45444e55
20004010:	4e555252 	.word	0x4e555252
20004014:	544e4920 	.word	0x544e4920
20004018:	55525245 	.word	0x55525245
2000401c:	00005450 	.word	0x00005450
20004020:	20200d0a 	.word	0x20200d0a
20004024:	46205852 	.word	0x46205852
20004028:	204f4649 	.word	0x204f4649
2000402c:	5245564f 	.word	0x5245564f
20004030:	574f4c46 	.word	0x574f4c46
20004034:	544e4920 	.word	0x544e4920
20004038:	55525245 	.word	0x55525245
2000403c:	00005450 	.word	0x00005450
20004040:	20200d0a 	.word	0x20200d0a
20004044:	43205852 	.word	0x43205852
20004048:	45204352 	.word	0x45204352
2000404c:	524f5252 	.word	0x524f5252
20004050:	544e4920 	.word	0x544e4920
20004054:	55525245 	.word	0x55525245
20004058:	00005450 	.word	0x00005450
2000405c:	21200d0a 	.word	0x21200d0a
20004060:	21212121 	.word	0x21212121
20004064:	41462021 	.word	0x41462021
20004068:	44454c49 	.word	0x44454c49
2000406c:	20585220 	.word	0x20585220
20004070:	4b434150 	.word	0x4b434150
20004074:	00005445 	.word	0x00005445
20004078:	50200d0a 	.word	0x50200d0a
2000407c:	20535341 	.word	0x20535341
20004080:	50205852 	.word	0x50205852
20004084:	454b4341 	.word	0x454b4341
20004088:	00000054 	.word	0x00000054
2000408c:	41200d0a 	.word	0x41200d0a
20004090:	50204c4c 	.word	0x50204c4c
20004094:	454b4341 	.word	0x454b4341
20004098:	50205354 	.word	0x50205354
2000409c:	45535341 	.word	0x45535341
200040a0:	2e2e2e44 	.word	0x2e2e2e44
200040a4:	000d0a20 	.word	0x000d0a20
200040a8:	48200d0a 	.word	0x48200d0a
200040ac:	20686769 	.word	0x20686769
200040b0:	72646441 	.word	0x72646441
200040b4:	20737365 	.word	0x20737365
200040b8:	6c696146 	.word	0x6c696146
200040bc:	00002020 	.word	0x00002020
200040c0:	50462020 	.word	0x50462020
200040c4:	49204147 	.word	0x49204147
200040c8:	7265746e 	.word	0x7265746e
200040cc:	74707572 	.word	0x74707572
200040d0:	67655220 	.word	0x67655220
200040d4:	65747369 	.word	0x65747369
200040d8:	20203a72 	.word	0x20203a72
200040dc:	00783020 	.word	0x00783020
200040e0:	20202020 	.word	0x20202020
200040e4:	65707845 	.word	0x65707845
200040e8:	64657463 	.word	0x64657463
200040ec:	2020203a 	.word	0x2020203a
200040f0:	00007830 	.word	0x00007830
200040f4:	20202020 	.word	0x20202020
200040f8:	75746341 	.word	0x75746341
200040fc:	203a6c61 	.word	0x203a6c61
20004100:	78302020 	.word	0x78302020
20004104:	00000000 	.word	0x00000000
20004108:	4c200d0a 	.word	0x4c200d0a
2000410c:	4120776f 	.word	0x4120776f
20004110:	65726464 	.word	0x65726464
20004114:	46207373 	.word	0x46207373
20004118:	206c6961 	.word	0x206c6961
2000411c:	00002020 	.word	0x00002020
20004120:	48200d0a 	.word	0x48200d0a
20004124:	20686769 	.word	0x20686769
20004128:	676e654c 	.word	0x676e654c
2000412c:	46206874 	.word	0x46206874
20004130:	206c6961 	.word	0x206c6961
20004134:	00002020 	.word	0x00002020
20004138:	4c200d0a 	.word	0x4c200d0a
2000413c:	4c20776f 	.word	0x4c20776f
20004140:	74676e65 	.word	0x74676e65
20004144:	61462068 	.word	0x61462068
20004148:	20206c69 	.word	0x20206c69
2000414c:	00002020 	.word	0x00002020
20004150:	44200d0a 	.word	0x44200d0a
20004154:	20617461 	.word	0x20617461
20004158:	6c696146 	.word	0x6c696146
2000415c:	20202020 	.word	0x20202020
20004160:	20202020 	.word	0x20202020
20004164:	00002020 	.word	0x00002020

20004168 <g_config_reg_lut>:
20004168:	40013000 40013004 40013008 4001300c     .0.@.0.@.0.@.0.@
20004178:	40013010 40013014 40013018 4001301c     .0.@.0.@.0.@.0.@
20004188:	40013020 40013024 40013028 4001302c      0.@$0.@(0.@,0.@
20004198:	40013030 40013034 40013038 4001303c     00.@40.@80.@<0.@
200041a8:	40013040 40013044 40013048 4001304c     @0.@D0.@H0.@L0.@
200041b8:	40013050 40013054 40013058 4001305c     P0.@T0.@X0.@\0.@
200041c8:	40013060 40013064 40013068 4001306c     `0.@d0.@h0.@l0.@
200041d8:	40013070 40013074 40013078 4001307c     p0.@t0.@x0.@|0.@

200041e8 <g_gpio_irqn_lut>:
200041e8:	35343332 39383736 3d3c3b3a 41403f3e     23456789:;<=>?@A
200041f8:	45444342 49484746 4d4c4b4a 51504f4e     BCDEFGHIJKLMNOPQ

20004208 <C.18.3527>:
20004208:	01000100 03030202                       ........

20004210 <_init>:
20004210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20004212:	bf00      	nop
20004214:	bcf8      	pop	{r3, r4, r5, r6, r7}
20004216:	bc08      	pop	{r3}
20004218:	469e      	mov	lr, r3
2000421a:	4770      	bx	lr

2000421c <_fini>:
2000421c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000421e:	bf00      	nop
20004220:	bcf8      	pop	{r3, r4, r5, r6, r7}
20004222:	bc08      	pop	{r3}
20004224:	469e      	mov	lr, r3
20004226:	4770      	bx	lr

20004228 <__frame_dummy_init_array_entry>:
20004228:	04d5 2000                                   ... 

2000422c <__do_global_dtors_aux_fini_array_entry>:
2000422c:	04c1 2000                                   ... 
